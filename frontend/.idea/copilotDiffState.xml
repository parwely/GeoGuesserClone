<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    alias(libs.plugins.hilt.android)&#10;    alias(libs.plugins.ksp)&#10;    alias(libs.plugins.kotlin.serialization)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.example.geoguessrclone&quot;&#10;    compileSdk = 35&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.geoguessrclone&quot;&#10;        minSdk = 26&#10;        targetSdk = 35&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;        vectorDrawables {&#10;            useSupportLibrary = true&#10;        }&#10;&#10;        // Performance Optimierungen&#10;        multiDexEnabled = true&#10;&#10;        // ProGuard optimierte Konfiguration&#10;        ndk {&#10;            debugSymbolLevel = &quot;SYMBOL_TABLE&quot;&#10;        }&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = true // Aktiviert für bessere Performance&#10;            isShrinkResources = true // Entfernt unbenutzte Ressourcen&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;            buildConfigField(&quot;String&quot;, &quot;BASE_URL&quot;, &quot;\&quot;https://your-app.vercel.app\&quot;&quot;)&#10;            buildConfigField(&quot;String&quot;, &quot;SOCKET_URL&quot;, &quot;\&quot;wss://your-app.vercel.app\&quot;&quot;)&#10;&#10;            // Performance Optimierungen für Release&#10;            isDebuggable = false&#10;            renderscriptOptimLevel = 3&#10;        }&#10;        debug {&#10;            buildConfigField(&quot;String&quot;, &quot;BASE_URL&quot;, &quot;\&quot;https://your-app.vercel.app\&quot;&quot;)&#10;            buildConfigField(&quot;String&quot;, &quot;SOCKET_URL&quot;, &quot;\&quot;wss://your-app.vercel.app\&quot;&quot;)&#10;&#10;            // Debug Performance Optimierungen&#10;            isMinifyEnabled = false&#10;            applicationIdSuffix = &quot;.debug&quot;&#10;        }&#10;    }&#10;&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_17 // Upgrade für bessere Performance&#10;        targetCompatibility = JavaVersion.VERSION_17&#10;        isCoreLibraryDesugaringEnabled = true&#10;    }&#10;&#10;    kotlinOptions {&#10;        jvmTarget = &quot;17&quot;&#10;&#10;        // Kotlin Compiler Optimierungen&#10;        freeCompilerArgs += listOf(&#10;            &quot;-opt-in=androidx.compose.material3.ExperimentalMaterial3Api&quot;,&#10;            &quot;-opt-in=androidx.compose.foundation.ExperimentalFoundationApi&quot;,&#10;            &quot;-opt-in=kotlinx.coroutines.ExperimentalCoroutinesApi&quot;,&#10;            &quot;-Xjvm-default=all&quot;, // Bessere Java Interop Performance&#10;            &quot;-Xbackend-threads=4&quot; // Parallele Compilation&#10;        )&#10;    }&#10;&#10;    buildFeatures {&#10;        compose = true&#10;        buildConfig = true&#10;&#10;        // Deaktiviere unbenutzte Features für bessere Build Performance&#10;        viewBinding = false&#10;        dataBinding = false&#10;        aidl = false&#10;        renderScript = false&#10;        shaders = false&#10;    }&#10;&#10;    composeOptions {&#10;        kotlinCompilerExtensionVersion = &quot;1.5.15&quot;&#10;    }&#10;&#10;    packaging {&#10;        resources {&#10;            excludes += &quot;/META-INF/{AL2.0,LGPL2.1}&quot;&#10;            excludes += &quot;/META-INF/DEPENDENCIES&quot;&#10;            excludes += &quot;/META-INF/LICENSE&quot;&#10;            excludes += &quot;/META-INF/LICENSE.txt&quot;&#10;            excludes += &quot;/META-INF/NOTICE&quot;&#10;            excludes += &quot;/META-INF/NOTICE.txt&quot;&#10;        }&#10;    }&#10;&#10;    // Build Performance Optimierungen&#10;    androidResources {&#10;        generateLocaleConfig = true&#10;    }&#10;&#10;    // Kompilierungs-Cache Optimierungen&#10;    compileSdk = 35&#10;&#10;    bundle {&#10;        language {&#10;            enableSplit = true&#10;        }&#10;        density {&#10;            enableSplit = true&#10;        }&#10;        abi {&#10;            enableSplit = true&#10;        }&#10;    }&#10;}&#10;&#10;dependencies {&#10;    // Core Library Desugaring - MUSS ZUERST STEHEN&#10;    coreLibraryDesugaring(&quot;com.android.tools:desugar_jdk_libs:2.0.4&quot;)&#10;&#10;    // Core Android &amp; Compose&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;&#10;    // Hilt&#10;    implementation(libs.hilt.android)&#10;    ksp(libs.hilt.compiler)&#10;    implementation(libs.hilt.navigation.compose)&#10;&#10;    // Networking&#10;    implementation(libs.retrofit)&#10;    implementation(libs.retrofit.gson)&#10;    implementation(libs.okhttp)&#10;    implementation(libs.okhttp.logging)&#10;&#10;    // Room&#10;    implementation(libs.room.runtime)&#10;    implementation(libs.room.ktx)&#10;    ksp(libs.room.compiler)&#10;&#10;    // Navigation&#10;    implementation(libs.navigation.compose)&#10;&#10;    // Image Loading&#10;    implementation(libs.coil.compose)&#10;&#10;    // OSM Maps&#10;    implementation(libs.osmdroid.android)&#10;&#10;    // WorkManager für Background Tasks&#10;    implementation(&quot;androidx.work:work-runtime-ktx:2.9.0&quot;)&#10;    implementation(&quot;androidx.hilt:hilt-work:1.1.0&quot;)&#10;&#10;    // Testing&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;}&#10;" />
              <option name="updatedContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    alias(libs.plugins.hilt.android)&#10;    alias(libs.plugins.ksp)&#10;    alias(libs.plugins.kotlin.serialization)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.example.geoguessrclone&quot;&#10;    compileSdk = 35&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.geoguessrclone&quot;&#10;        minSdk = 26&#10;        targetSdk = 35&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;        vectorDrawables {&#10;            useSupportLibrary = true&#10;        }&#10;&#10;        // Performance Optimierungen&#10;        multiDexEnabled = true&#10;&#10;        // ProGuard optimierte Konfiguration&#10;        ndk {&#10;            debugSymbolLevel = &quot;SYMBOL_TABLE&quot;&#10;        }&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = true // Aktiviert für bessere Performance&#10;            isShrinkResources = true // Entfernt unbenutzte Ressourcen&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;            buildConfigField(&quot;String&quot;, &quot;BASE_URL&quot;, &quot;\&quot;https://your-app.vercel.app\&quot;&quot;)&#10;            buildConfigField(&quot;String&quot;, &quot;SOCKET_URL&quot;, &quot;\&quot;wss://your-app.vercel.app\&quot;&quot;)&#10;&#10;            // Performance Optimierungen für Release&#10;            isDebuggable = false&#10;            renderscriptOptimLevel = 3&#10;        }&#10;        debug {&#10;            buildConfigField(&quot;String&quot;, &quot;BASE_URL&quot;, &quot;\&quot;https://your-app.vercel.app\&quot;&quot;)&#10;            buildConfigField(&quot;String&quot;, &quot;SOCKET_URL&quot;, &quot;\&quot;wss://your-app.vercel.app\&quot;&quot;)&#10;&#10;            // Debug Performance Optimierungen&#10;            isMinifyEnabled = false&#10;            applicationIdSuffix = &quot;.debug&quot;&#10;        }&#10;    }&#10;&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_17 // Upgrade für bessere Performance&#10;        targetCompatibility = JavaVersion.VERSION_17&#10;        isCoreLibraryDesugaringEnabled = true&#10;    }&#10;&#10;    kotlinOptions {&#10;        jvmTarget = &quot;17&quot;&#10;&#10;        // Kotlin Compiler Optimierungen&#10;        freeCompilerArgs += listOf(&#10;            &quot;-opt-in=androidx.compose.material3.ExperimentalMaterial3Api&quot;,&#10;            &quot;-opt-in=androidx.compose.foundation.ExperimentalFoundationApi&quot;,&#10;            &quot;-opt-in=kotlinx.coroutines.ExperimentalCoroutinesApi&quot;,&#10;            &quot;-Xjvm-default=all&quot;, // Bessere Java Interop Performance&#10;            &quot;-Xbackend-threads=4&quot; // Parallele Compilation&#10;        )&#10;    }&#10;&#10;    buildFeatures {&#10;        compose = true&#10;        buildConfig = true&#10;&#10;        // Deaktiviere unbenutzte Features für bessere Build Performance&#10;        viewBinding = false&#10;        dataBinding = false&#10;        aidl = false&#10;        renderScript = false&#10;        shaders = false&#10;    }&#10;&#10;    composeOptions {&#10;        kotlinCompilerExtensionVersion = &quot;1.5.15&quot;&#10;    }&#10;&#10;    packaging {&#10;        resources {&#10;            excludes += &quot;/META-INF/{AL2.0,LGPL2.1}&quot;&#10;            excludes += &quot;/META-INF/DEPENDENCIES&quot;&#10;            excludes += &quot;/META-INF/LICENSE&quot;&#10;            excludes += &quot;/META-INF/LICENSE.txt&quot;&#10;            excludes += &quot;/META-INF/NOTICE&quot;&#10;            excludes += &quot;/META-INF/NOTICE.txt&quot;&#10;        }&#10;    }&#10;&#10;    // Build Performance Optimierungen&#10;    androidResources {&#10;        // generateLocaleConfig = true - Entfernt da resources.properties fehlt&#10;    }&#10;&#10;    // Kompilierungs-Cache Optimierungen&#10;    compileSdk = 35&#10;&#10;    bundle {&#10;        language {&#10;            enableSplit = true&#10;        }&#10;        density {&#10;            enableSplit = true&#10;        }&#10;        abi {&#10;            enableSplit = true&#10;        }&#10;    }&#10;}&#10;&#10;dependencies {&#10;    // Core Library Desugaring - MUSS ZUERST STEHEN&#10;    coreLibraryDesugaring(&quot;com.android.tools:desugar_jdk_libs:2.0.4&quot;)&#10;&#10;    // Core Android &amp; Compose&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;&#10;    // Hilt&#10;    implementation(libs.hilt.android)&#10;    ksp(libs.hilt.compiler)&#10;    implementation(libs.hilt.navigation.compose)&#10;&#10;    // Networking&#10;    implementation(libs.retrofit)&#10;    implementation(libs.retrofit.gson)&#10;    implementation(libs.okhttp)&#10;    implementation(libs.okhttp.logging)&#10;&#10;    // Room&#10;    implementation(libs.room.runtime)&#10;    implementation(libs.room.ktx)&#10;    ksp(libs.room.compiler)&#10;&#10;    // Navigation&#10;    implementation(libs.navigation.compose)&#10;&#10;    // Image Loading&#10;    implementation(libs.coil.compose)&#10;&#10;    // OSM Maps&#10;    implementation(libs.osmdroid.android)&#10;&#10;    // WorkManager für Background Tasks&#10;    implementation(&quot;androidx.work:work-runtime-ktx:2.9.0&quot;)&#10;    implementation(&quot;androidx.hilt:hilt-work:1.1.0&quot;)&#10;&#10;    // Testing&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/proguard-rules.pro">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/proguard-rules.pro" />
              <option name="originalContent" value="# Add project specific ProGuard rules here.&#10;# You can control the set of applied configuration files using the&#10;# proguardFiles setting in build.gradle.&#10;#&#10;# For more details, see&#10;#   http://developer.android.com/guide/developing/tools/proguard.html&#10;&#10;# If your project uses WebView with JS, uncomment the following&#10;# and specify the fully qualified class name to the JavaScript interface&#10;# class:&#10;#-keepclassmembers class fqcn.of.javascript.interface.for.webview {&#10;#   public *;&#10;#}&#10;&#10;# Uncomment this to preserve the line number information for&#10;# debugging stack traces.&#10;#-keepattributes SourceFile,LineNumberTable&#10;&#10;# If you keep the line number information, uncomment this to&#10;# hide the original source file name.&#10;#-renamesourcefileattribute SourceFile" />
              <option name="updatedContent" value="# Add project specific ProGuard rules here.&#10;# You can control the set of applied configuration files using the&#10;# proguardFiles setting in build.gradle.&#10;#&#10;# For more details, see&#10;#   http://developer.android.com/guide/developing/tools/proguard.html&#10;&#10;# If your project uses WebView with JS, uncomment the following&#10;# and specify the fully qualified class name to the JavaScript interface&#10;# class:&#10;#-keepclassmembers class fqcn.of.javascript.interface.for.webview {&#10;#   public *;&#10;#}&#10;&#10;# Uncomment this to preserve the line number information for&#10;# debugging stack traces.&#10;#-keepattributes SourceFile,LineNumberTable&#10;&#10;# If you keep the line number information, uncomment this to&#10;# hide the original source file name.&#10;#-renamesourcefileattribute SourceFile&#10;&#10;# Performance optimizations&#10;-optimizationpasses 5&#10;-allowaccessmodification&#10;-mergeinterfacesaggressively&#10;&#10;# Retrofit&#10;-keepattributes Signature, InnerClasses, EnclosingMethod&#10;-keepattributes RuntimeVisibleAnnotations, RuntimeVisibleParameterAnnotations&#10;-keepattributes AnnotationDefault&#10;-keepclassmembers,allowshrinking,allowobfuscation interface * {&#10;    @retrofit2.http.* &lt;methods&gt;;&#10;}&#10;-dontwarn org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement&#10;-dontwarn javax.annotation.**&#10;-dontwarn kotlin.Unit&#10;-dontwarn retrofit2.KotlinExtensions&#10;&#10;# OkHttp&#10;-dontwarn okhttp3.**&#10;-dontwarn okio.**&#10;-dontwarn javax.annotation.**&#10;-keepnames class okhttp3.internal.publicsuffix.PublicSuffixDatabase&#10;&#10;# Room&#10;-keepattributes *Annotation*&#10;-keepclassmembers class * extends androidx.room.RoomDatabase {&#10;    *;&#10;}&#10;-keepclassmembers @androidx.room.Entity class * {&#10;    *;&#10;}&#10;&#10;# Coil&#10;-dontwarn coil.**&#10;&#10;# OSMDroid&#10;-dontwarn org.osmdroid.**&#10;&#10;# Hilt&#10;-dontwarn dagger.hilt.**&#10;&#10;# Kotlin Coroutines&#10;-keepnames class kotlinx.coroutines.internal.MainDispatcherFactory {}&#10;-keepnames class kotlinx.coroutines.CoroutineExceptionHandler {}&#10;-keepclassmembers class kotlinx.coroutines.** {&#10;    volatile &lt;fields&gt;;&#10;}&#10;&#10;# Remove logging in release&#10;-assumenosideeffects class android.util.Log {&#10;    public static *** d(...);&#10;    public static *** v(...);&#10;    public static *** i(...);&#10;}&#10;&#10;# Performance: Remove debug info&#10;-keepattributes !SourceFile,!LineNumberTable" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;!-- Permissions --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:name=&quot;com.example.geogeusserclone.GeoGuessrApplication&quot;&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.GeoGeusserClone&quot;&#10;        android:usesCleartextTraffic=&quot;true&quot;&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;com.example.geogeusserclone.ui.activities.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:theme=&quot;@style/Theme.GeoGeusserClone&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;com.example.geogeusserclone.ui.activities.AuthActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:theme=&quot;@style/Theme.GeoGeusserClone&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;com.example.geogeusserclone.ui.activities.MenuActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:theme=&quot;@style/Theme.GeoGeusserClone&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;com.example.geogeusserclone.ui.activities.GameActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:theme=&quot;@style/Theme.GeoGeusserClone&quot; /&gt;&#10;&#10;    &lt;/application&gt;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;!-- Permissions --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:name=&quot;com.example.geogeusserclone.GeoGuessrApplication&quot;&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.GeoGeusserClone&quot;&#10;        android:usesCleartextTraffic=&quot;true&quot;&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;com.example.geogeusserclone.ui.activities.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:theme=&quot;@style/Theme.GeoGeusserClone&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;com.example.geogeusserclone.ui.activities.AuthActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:theme=&quot;@style/Theme.GeoGeusserClone&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;com.example.geogeusserclone.ui.activities.MenuActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:theme=&quot;@style/Theme.GeoGeusserClone&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;com.example.geogeusserclone.ui.activities.GameActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:theme=&quot;@style/Theme.GeoGeusserClone&quot; /&gt;&#10;&#10;    &lt;/application&gt;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/DatabaseModule.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/DatabaseModule.kt" />
              <option name="originalContent" value="package com.example.geogeusserclone&#10;&#10;import android.content.Context&#10;import androidx.room.Room&#10;import androidx.room.migration.Migration&#10;import androidx.sqlite.db.SupportSQLiteDatabase&#10;import com.example.geogeusserclone.data.database.AppDatabase&#10;import dagger.Module&#10;import dagger.Provides&#10;import dagger.hilt.InstallIn&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#10;import dagger.hilt.components.SingletonComponent&#10;import java.util.concurrent.Executors&#10;import javax.inject.Singleton&#10;&#10;@Module&#10;@InstallIn(SingletonComponent::class)&#10;object DatabaseModule {&#10;&#10;    private val MIGRATION_1_2 = object : Migration(1, 2) {&#10;        override fun migrate(database: SupportSQLiteDatabase) {&#10;            // Add indices&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_guesses_gameId` ON `guesses` (`gameId`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_guesses_locationId` ON `guesses` (`locationId`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_guesses_submittedAt` ON `guesses` (`submittedAt`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_userId` ON `games` (`userId`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_createdAt` ON `games` (`createdAt`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_isCompleted` ON `games` (`isCompleted`)&quot;)&#10;        }&#10;    }&#10;&#10;    private val MIGRATION_2_3 = object : Migration(2, 3) {&#10;        override fun migrate(database: SupportSQLiteDatabase) {&#10;            // Add missing columns to users table&#10;            database.execSQL(&quot;ALTER TABLE users ADD COLUMN totalScore INTEGER NOT NULL DEFAULT 0&quot;)&#10;            database.execSQL(&quot;ALTER TABLE users ADD COLUMN gamesPlayed INTEGER NOT NULL DEFAULT 0&quot;)&#10;            database.execSQL(&quot;ALTER TABLE users ADD COLUMN bestScore INTEGER NOT NULL DEFAULT 0&quot;)&#10;            database.execSQL(&quot;ALTER TABLE users ADD COLUMN lastLoginAt INTEGER NOT NULL DEFAULT 0&quot;)&#10;            database.execSQL(&quot;ALTER TABLE users ADD COLUMN createdAt INTEGER NOT NULL DEFAULT 0&quot;)&#10;            database.execSQL(&quot;ALTER TABLE locations ADD COLUMN isUsed INTEGER NOT NULL DEFAULT 0&quot;)&#10;        }&#10;    }&#10;&#10;    private val MIGRATION_3_4 = object : Migration(3, 4) {&#10;        override fun migrate(database: SupportSQLiteDatabase) {&#10;            // Performance-optimierte Indizes hinzufügen&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_locations_isUsed_isCached` ON `locations` (`isUsed`, `isCached`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_locations_difficulty` ON `locations` (`difficulty`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_users_authToken` ON `users` (`authToken`)&quot;)&#10;&#10;            // Game Performance Indizes&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_userId_isCompleted` ON `games` (`userId`, `isCompleted`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_guesses_gameId_submittedAt` ON `guesses` (`gameId`, `submittedAt`)&quot;)&#10;        }&#10;    }&#10;&#10;    private val MIGRATION_4_5 = object : Migration(4, 5) {&#10;        override fun migrate(database: SupportSQLiteDatabase) {&#10;            // Version 5: Optimierung für bessere Performance und Memory Management&#10;&#10;            // Neue Game Spalten für erweiterte Statistiken&#10;            database.execSQL(&quot;ALTER TABLE games ADD COLUMN startedAt INTEGER&quot;)&#10;            database.execSQL(&quot;ALTER TABLE games ADD COLUMN completedAt INTEGER&quot;)&#10;            database.execSQL(&quot;ALTER TABLE games ADD COLUMN duration INTEGER&quot;)&#10;&#10;            // Location Cache Optimierungen&#10;            database.execSQL(&quot;ALTER TABLE locations ADD COLUMN cachedAt INTEGER NOT NULL DEFAULT ${System.currentTimeMillis()}&quot;)&#10;&#10;            // Performance-kritische Indizes&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_locations_cachedAt` ON `locations` (`cachedAt`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_completedAt` ON `games` (`completedAt`)&quot;)&#10;&#10;            // Cleanup alter Daten&#10;            database.execSQL(&quot;DELETE FROM locations WHERE isCached = 0 AND isUsed = 1 AND cachedAt &lt; ${System.currentTimeMillis() - (7 * 24 * 60 * 60 * 1000)}&quot;)&#10;        }&#10;    }&#10;&#10;    private val MIGRATION_5_6 = object : Migration(5, 6) {&#10;        override fun migrate(database: SupportSQLiteDatabase) {&#10;            // Version 6: Foreign Key und Offline Mode Fixes&#10;&#10;            // Prüfe ob games Tabelle existiert bevor wir sie bearbeiten&#10;            val cursor = database.query(&quot;SELECT name FROM sqlite_master WHERE type='table' AND name='games'&quot;)&#10;            val gamesTableExists = cursor.moveToFirst()&#10;            cursor.close()&#10;&#10;            if (gamesTableExists) {&#10;                // Temporäre Tabellen erstellen ohne Foreign Key Constraints&#10;                database.execSQL(&quot;&quot;&quot;&#10;                    CREATE TABLE games_temp (&#10;                        id TEXT PRIMARY KEY NOT NULL,&#10;                        userId TEXT NOT NULL,&#10;                        gameMode TEXT NOT NULL DEFAULT 'classic',&#10;                        totalRounds INTEGER NOT NULL DEFAULT 5,&#10;                        currentRound INTEGER NOT NULL DEFAULT 1,&#10;                        score INTEGER NOT NULL DEFAULT 0,&#10;                        isCompleted INTEGER NOT NULL DEFAULT 0,&#10;                        createdAt INTEGER NOT NULL DEFAULT ${System.currentTimeMillis()},&#10;                        startedAt INTEGER,&#10;                        completedAt INTEGER,&#10;                        duration INTEGER&#10;                    )&#10;                &quot;&quot;&quot;)&#10;&#10;                // Daten kopieren falls Tabelle Daten hat&#10;                try {&#10;                    database.execSQL(&quot;&quot;&quot;&#10;                        INSERT INTO games_temp &#10;                        SELECT id, userId, gameMode, totalRounds, currentRound, score, isCompleted, createdAt, startedAt, completedAt, duration &#10;                        FROM games&#10;                    &quot;&quot;&quot;)&#10;                } catch (e: Exception) {&#10;                    // Falls Spalten fehlen, erstelle nur Basis-Daten&#10;                    database.execSQL(&quot;&quot;&quot;&#10;                        INSERT INTO games_temp (id, userId, gameMode, totalRounds, currentRound, score, isCompleted, createdAt)&#10;                        SELECT id, userId, &#10;                               COALESCE(gameMode, 'classic') as gameMode,&#10;                               COALESCE(totalRounds, 5) as totalRounds,&#10;                               COALESCE(currentRound, 1) as currentRound,&#10;                               COALESCE(score, 0) as score,&#10;                               COALESCE(isCompleted, 0) as isCompleted,&#10;                               COALESCE(createdAt, ${System.currentTimeMillis()}) as createdAt&#10;                        FROM games&#10;                    &quot;&quot;&quot;)&#10;                }&#10;&#10;                // Alte Tabelle löschen und neue umbenennen&#10;                database.execSQL(&quot;DROP TABLE games&quot;)&#10;                database.execSQL(&quot;ALTER TABLE games_temp RENAME TO games&quot;)&#10;            } else {&#10;                // Falls games Tabelle nicht existiert, erstelle sie neu&#10;                database.execSQL(&quot;&quot;&quot;&#10;                    CREATE TABLE games (&#10;                        id TEXT PRIMARY KEY NOT NULL,&#10;                        userId TEXT NOT NULL,&#10;                        gameMode TEXT NOT NULL DEFAULT 'classic',&#10;                        totalRounds INTEGER NOT NULL DEFAULT 5,&#10;                        currentRound INTEGER NOT NULL DEFAULT 1,&#10;                        score INTEGER NOT NULL DEFAULT 0,&#10;                        isCompleted INTEGER NOT NULL DEFAULT 0,&#10;                        createdAt INTEGER NOT NULL DEFAULT ${System.currentTimeMillis()},&#10;                        startedAt INTEGER,&#10;                        completedAt INTEGER,&#10;                        duration INTEGER&#10;                    )&#10;                &quot;&quot;&quot;)&#10;            }&#10;&#10;            // Indizes neu erstellen ohne Foreign Key Constraints&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_userId` ON `games` (`userId`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_isCompleted` ON `games` (`isCompleted`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_createdAt` ON `games` (`createdAt`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_completedAt` ON `games` (`completedAt`)&quot;)&#10;&#10;            // Prüfe ob users Tabelle existiert&#10;            val usersCursor = database.query(&quot;SELECT name FROM sqlite_master WHERE type='table' AND name='users'&quot;)&#10;            val usersTableExists = usersCursor.moveToFirst()&#10;            usersCursor.close()&#10;&#10;            if (!usersTableExists) {&#10;                // Erstelle users Tabelle falls sie nicht existiert&#10;                database.execSQL(&quot;&quot;&quot;&#10;                    CREATE TABLE users (&#10;                        id TEXT PRIMARY KEY NOT NULL,&#10;                        username TEXT NOT NULL,&#10;                        email TEXT NOT NULL,&#10;                        authToken TEXT,&#10;                        totalScore INTEGER NOT NULL DEFAULT 0,&#10;                        gamesPlayed INTEGER NOT NULL DEFAULT 0,&#10;                        bestScore INTEGER NOT NULL DEFAULT 0,&#10;                        lastLoginAt INTEGER NOT NULL DEFAULT 0,&#10;                        createdAt INTEGER NOT NULL DEFAULT ${System.currentTimeMillis()}&#10;                    )&#10;                &quot;&quot;&quot;)&#10;            }&#10;&#10;            // Emergency User erstellen falls nicht vorhanden&#10;            database.execSQL(&quot;&quot;&quot;&#10;                INSERT OR IGNORE INTO users (id, username, email, authToken, totalScore, gamesPlayed, bestScore, lastLoginAt, createdAt)&#10;                VALUES ('emergency_user', 'Emergency User', 'emergency@local.com', NULL, 0, 0, 0, ${System.currentTimeMillis()}, ${System.currentTimeMillis()})&#10;            &quot;&quot;&quot;)&#10;        }&#10;    }&#10;&#10;    private val MIGRATION_6_7 = object : Migration(6, 7) {&#10;        override fun migrate(database: SupportSQLiteDatabase) {&#10;            // Version 7: Sanfte Bereinigung der Database-Probleme ohne komplettes Löschen&#10;&#10;            // Prüfe welche Tabellen existieren&#10;            val gamesCursor = database.query(&quot;SELECT name FROM sqlite_master WHERE type='table' AND name='games'&quot;)&#10;            val gamesTableExists = gamesCursor.moveToFirst()&#10;            gamesCursor.close()&#10;&#10;            val locationsCursor = database.query(&quot;SELECT name FROM sqlite_master WHERE type='table' AND name='locations'&quot;)&#10;            val locationsTableExists = locationsCursor.moveToFirst()&#10;            locationsCursor.close()&#10;&#10;            val guessesCursor = database.query(&quot;SELECT name FROM sqlite_master WHERE type='table' AND name='guesses'&quot;)&#10;            val guessesTableExists = guessesCursor.moveToFirst()&#10;            guessesCursor.close()&#10;&#10;            // Nur problematische games Tabelle neu erstellen (wegen &quot;duration&quot; Spalten-Problem)&#10;            if (gamesTableExists) {&#10;                database.execSQL(&quot;DROP TABLE IF EXISTS games&quot;)&#10;            }&#10;&#10;            // Erstelle games Tabelle neu mit korrekter Struktur&#10;            database.execSQL(&quot;&quot;&quot;&#10;                CREATE TABLE games (&#10;                    id TEXT PRIMARY KEY NOT NULL,&#10;                    userId TEXT NOT NULL,&#10;                    gameMode TEXT NOT NULL DEFAULT 'classic',&#10;                    totalRounds INTEGER NOT NULL DEFAULT 5,&#10;                    currentRound INTEGER NOT NULL DEFAULT 1,&#10;                    score INTEGER NOT NULL DEFAULT 0,&#10;                    isCompleted INTEGER NOT NULL DEFAULT 0,&#10;                    createdAt INTEGER NOT NULL,&#10;                    startedAt INTEGER,&#10;                    completedAt INTEGER,&#10;                    duration INTEGER&#10;                )&#10;            &quot;&quot;&quot;)&#10;&#10;            // Erstelle locations Tabelle nur wenn sie nicht existiert&#10;            if (!locationsTableExists) {&#10;                database.execSQL(&quot;&quot;&quot;&#10;                    CREATE TABLE locations (&#10;                        id TEXT PRIMARY KEY NOT NULL,&#10;                        latitude REAL NOT NULL,&#10;                        longitude REAL NOT NULL,&#10;                        imageUrl TEXT NOT NULL,&#10;                        country TEXT,&#10;                        city TEXT,&#10;                        difficulty INTEGER NOT NULL DEFAULT 1,&#10;                        isCached INTEGER NOT NULL DEFAULT 0,&#10;                        isUsed INTEGER NOT NULL DEFAULT 0,&#10;                        cachedAt INTEGER NOT NULL DEFAULT ${System.currentTimeMillis()}&#10;                    )&#10;                &quot;&quot;&quot;)&#10;            }&#10;&#10;            // Erstelle guesses Tabelle nur wenn sie nicht existiert&#10;            if (!guessesTableExists) {&#10;                database.execSQL(&quot;&quot;&quot;&#10;                    CREATE TABLE guesses (&#10;                        id TEXT PRIMARY KEY NOT NULL,&#10;                        gameId TEXT NOT NULL,&#10;                        locationId TEXT NOT NULL,&#10;                        guessLat REAL NOT NULL,&#10;                        guessLng REAL NOT NULL,&#10;                        actualLat REAL NOT NULL,&#10;                        actualLng REAL NOT NULL,&#10;                        distance REAL NOT NULL,&#10;                        score INTEGER NOT NULL,&#10;                        timeSpent INTEGER NOT NULL,&#10;                        submittedAt INTEGER NOT NULL&#10;                    )&#10;                &quot;&quot;&quot;)&#10;            }&#10;&#10;            // Erstelle alle Indizes neu (falls sie nicht existieren)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_userId` ON `games` (`userId`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_isCompleted` ON `games` (`isCompleted`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_createdAt` ON `games` (`createdAt`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_guesses_gameId` ON `guesses` (`gameId`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_guesses_locationId` ON `guesses` (`locationId`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_locations_isUsed_isCached` ON `locations` (`isUsed`, `isCached`)&quot;)&#10;&#10;            // Stelle sicher, dass users Tabelle existiert&#10;            val usersCursor = database.query(&quot;SELECT name FROM sqlite_master WHERE type='table' AND name='users'&quot;)&#10;            val usersTableExists = usersCursor.moveToFirst()&#10;            usersCursor.close()&#10;&#10;            if (!usersTableExists) {&#10;                database.execSQL(&quot;&quot;&quot;&#10;                    CREATE TABLE users (&#10;                        id TEXT PRIMARY KEY NOT NULL,&#10;                        username TEXT NOT NULL,&#10;                        email TEXT NOT NULL,&#10;                        authToken TEXT,&#10;                        totalScore INTEGER NOT NULL DEFAULT 0,&#10;                        gamesPlayed INTEGER NOT NULL DEFAULT 0,&#10;                        bestScore INTEGER NOT NULL DEFAULT 0,&#10;                        lastLoginAt INTEGER NOT NULL DEFAULT 0,&#10;                        createdAt INTEGER NOT NULL DEFAULT ${System.currentTimeMillis()}&#10;                    )&#10;                &quot;&quot;&quot;)&#10;            }&#10;&#10;            // Emergency User erstellen&#10;            database.execSQL(&quot;&quot;&quot;&#10;                INSERT OR IGNORE INTO users (id, username, email, authToken, totalScore, gamesPlayed, bestScore, lastLoginAt, createdAt)&#10;                VALUES ('emergency_user', 'Emergency User', 'emergency@local.com', NULL, 0, 0, 0, ${System.currentTimeMillis()}, ${System.currentTimeMillis()})&#10;            &quot;&quot;&quot;)&#10;&#10;            // Füge Standard-Fallback-Locations hinzu falls locations Tabelle leer ist&#10;            try {&#10;                val countCursor = database.query(&quot;SELECT COUNT(*) FROM locations&quot;)&#10;                val hasLocations = if (countCursor.moveToFirst()) {&#10;                    countCursor.getInt(0) &gt; 0&#10;                } else {&#10;                    false&#10;                }&#10;                countCursor.close()&#10;&#10;                if (!hasLocations) {&#10;                    // Füge eine Fallback-Location hinzu&#10;                    database.execSQL(&quot;&quot;&quot;&#10;                        INSERT INTO locations (id, latitude, longitude, imageUrl, country, city, difficulty, isCached, isUsed, cachedAt)&#10;                        VALUES ('fallback_paris', 48.8566, 2.3522, 'https://images.unsplash.com/photo-1502602898536-47ad22581b52?w=800', 'France', 'Paris', 2, 1, 0, ${System.currentTimeMillis()})&#10;                    &quot;&quot;&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                // Silent fail - Fallback-Location konnte nicht eingefügt werden&#10;            }&#10;        }&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {&#10;        return Room.databaseBuilder(&#10;            context,&#10;            AppDatabase::class.java,&#10;            &quot;geoguesser_database&quot;&#10;        )&#10;        .addMigrations(&#10;            MIGRATION_1_2,&#10;            MIGRATION_2_3,&#10;            MIGRATION_3_4,&#10;            MIGRATION_4_5,&#10;            MIGRATION_5_6,&#10;            MIGRATION_6_7&#10;        )&#10;        .setQueryExecutor(Executors.newFixedThreadPool(4))&#10;        .setTransactionExecutor(Executors.newFixedThreadPool(2))&#10;        // Fallback Strategy für Development&#10;        .fallbackToDestructiveMigration()&#10;        .build()&#10;    }&#10;&#10;    @Provides&#10;    fun provideUserDao(database: AppDatabase) = database.userDao()&#10;&#10;    @Provides&#10;    fun provideLocationDao(database: AppDatabase) = database.locationDao()&#10;&#10;    @Provides&#10;    fun provideGameDao(database: AppDatabase) = database.gameDao()&#10;&#10;    @Provides&#10;    fun provideGuessDao(database: AppDatabase) = database.guessDao()&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.geogeusserclone&#10;&#10;import android.content.Context&#10;import androidx.room.Room&#10;import androidx.room.migration.Migration&#10;import androidx.sqlite.db.SupportSQLiteDatabase&#10;import com.example.geogeusserclone.data.database.AppDatabase&#10;import dagger.Module&#10;import dagger.Provides&#10;import dagger.hilt.InstallIn&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#10;import dagger.hilt.components.SingletonComponent&#10;import java.util.concurrent.Executors&#10;import javax.inject.Singleton&#10;&#10;@Module&#10;@InstallIn(SingletonComponent::class)&#10;object DatabaseModule {&#10;&#10;    private val MIGRATION_1_2 = object : Migration(1, 2) {&#10;        override fun migrate(database: SupportSQLiteDatabase) {&#10;            // Add indices&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_guesses_gameId` ON `guesses` (`gameId`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_guesses_locationId` ON `guesses` (`locationId`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_guesses_submittedAt` ON `guesses` (`submittedAt`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_userId` ON `games` (`userId`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_createdAt` ON `games` (`createdAt`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_isCompleted` ON `games` (`isCompleted`)&quot;)&#10;        }&#10;    }&#10;&#10;    private val MIGRATION_2_3 = object : Migration(2, 3) {&#10;        override fun migrate(database: SupportSQLiteDatabase) {&#10;            // Add missing columns to users table&#10;            database.execSQL(&quot;ALTER TABLE users ADD COLUMN totalScore INTEGER NOT NULL DEFAULT 0&quot;)&#10;            database.execSQL(&quot;ALTER TABLE users ADD COLUMN gamesPlayed INTEGER NOT NULL DEFAULT 0&quot;)&#10;            database.execSQL(&quot;ALTER TABLE users ADD COLUMN bestScore INTEGER NOT NULL DEFAULT 0&quot;)&#10;            database.execSQL(&quot;ALTER TABLE users ADD COLUMN lastLoginAt INTEGER NOT NULL DEFAULT 0&quot;)&#10;            database.execSQL(&quot;ALTER TABLE users ADD COLUMN createdAt INTEGER NOT NULL DEFAULT 0&quot;)&#10;            database.execSQL(&quot;ALTER TABLE locations ADD COLUMN isUsed INTEGER NOT NULL DEFAULT 0&quot;)&#10;        }&#10;    }&#10;&#10;    private val MIGRATION_3_4 = object : Migration(3, 4) {&#10;        override fun migrate(database: SupportSQLiteDatabase) {&#10;            // Performance-optimierte Indizes hinzufügen&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_locations_isUsed_isCached` ON `locations` (`isUsed`, `isCached`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_locations_difficulty` ON `locations` (`difficulty`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_users_authToken` ON `users` (`authToken`)&quot;)&#10;&#10;            // Game Performance Indizes&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_userId_isCompleted` ON `games` (`userId`, `isCompleted`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_guesses_gameId_submittedAt` ON `guesses` (`gameId`, `submittedAt`)&quot;)&#10;        }&#10;    }&#10;&#10;    private val MIGRATION_4_5 = object : Migration(4, 5) {&#10;        override fun migrate(database: SupportSQLiteDatabase) {&#10;            // Version 5: Optimierung für bessere Performance und Memory Management&#10;&#10;            // Neue Game Spalten für erweiterte Statistiken&#10;            database.execSQL(&quot;ALTER TABLE games ADD COLUMN startedAt INTEGER&quot;)&#10;            database.execSQL(&quot;ALTER TABLE games ADD COLUMN completedAt INTEGER&quot;)&#10;            database.execSQL(&quot;ALTER TABLE games ADD COLUMN duration INTEGER&quot;)&#10;&#10;            // Location Cache Optimierungen&#10;            database.execSQL(&quot;ALTER TABLE locations ADD COLUMN cachedAt INTEGER NOT NULL DEFAULT ${System.currentTimeMillis()}&quot;)&#10;&#10;            // Performance-kritische Indizes&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_locations_cachedAt` ON `locations` (`cachedAt`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_completedAt` ON `games` (`completedAt`)&quot;)&#10;&#10;            // Cleanup alter Daten&#10;            database.execSQL(&quot;DELETE FROM locations WHERE isCached = 0 AND isUsed = 1 AND cachedAt &lt; ${System.currentTimeMillis() - (7 * 24 * 60 * 60 * 1000)}&quot;)&#10;        }&#10;    }&#10;&#10;    private val MIGRATION_5_6 = object : Migration(5, 6) {&#10;        override fun migrate(database: SupportSQLiteDatabase) {&#10;            // Version 6: Foreign Key und Offline Mode Fixes&#10;&#10;            // Prüfe ob games Tabelle existiert bevor wir sie bearbeiten&#10;            val cursor = database.query(&quot;SELECT name FROM sqlite_master WHERE type='table' AND name='games'&quot;)&#10;            val gamesTableExists = cursor.moveToFirst()&#10;            cursor.close()&#10;&#10;            if (gamesTableExists) {&#10;                // Temporäre Tabellen erstellen ohne Foreign Key Constraints&#10;                database.execSQL(&quot;&quot;&quot;&#10;                    CREATE TABLE games_temp (&#10;                        id TEXT PRIMARY KEY NOT NULL,&#10;                        userId TEXT NOT NULL,&#10;                        gameMode TEXT NOT NULL DEFAULT 'classic',&#10;                        totalRounds INTEGER NOT NULL DEFAULT 5,&#10;                        currentRound INTEGER NOT NULL DEFAULT 1,&#10;                        score INTEGER NOT NULL DEFAULT 0,&#10;                        isCompleted INTEGER NOT NULL DEFAULT 0,&#10;                        createdAt INTEGER NOT NULL DEFAULT ${System.currentTimeMillis()},&#10;                        startedAt INTEGER,&#10;                        completedAt INTEGER,&#10;                        duration INTEGER&#10;                    )&#10;                &quot;&quot;&quot;)&#10;&#10;                // Daten kopieren falls Tabelle Daten hat&#10;                try {&#10;                    database.execSQL(&quot;&quot;&quot;&#10;                        INSERT INTO games_temp &#10;                        SELECT id, userId, gameMode, totalRounds, currentRound, score, isCompleted, createdAt, startedAt, completedAt, duration &#10;                        FROM games&#10;                    &quot;&quot;&quot;)&#10;                } catch (e: Exception) {&#10;                    // Falls Spalten fehlen, erstelle nur Basis-Daten&#10;                    database.execSQL(&quot;&quot;&quot;&#10;                        INSERT INTO games_temp (id, userId, gameMode, totalRounds, currentRound, score, isCompleted, createdAt)&#10;                        SELECT id, userId, &#10;                               COALESCE(gameMode, 'classic') as gameMode,&#10;                               COALESCE(totalRounds, 5) as totalRounds,&#10;                               COALESCE(currentRound, 1) as currentRound,&#10;                               COALESCE(score, 0) as score,&#10;                               COALESCE(isCompleted, 0) as isCompleted,&#10;                               COALESCE(createdAt, ${System.currentTimeMillis()}) as createdAt&#10;                        FROM games&#10;                    &quot;&quot;&quot;)&#10;                }&#10;&#10;                // Alte Tabelle löschen und neue umbenennen&#10;                database.execSQL(&quot;DROP TABLE games&quot;)&#10;                database.execSQL(&quot;ALTER TABLE games_temp RENAME TO games&quot;)&#10;            } else {&#10;                // Falls games Tabelle nicht existiert, erstelle sie neu&#10;                database.execSQL(&quot;&quot;&quot;&#10;                    CREATE TABLE games (&#10;                        id TEXT PRIMARY KEY NOT NULL,&#10;                        userId TEXT NOT NULL,&#10;                        gameMode TEXT NOT NULL DEFAULT 'classic',&#10;                        totalRounds INTEGER NOT NULL DEFAULT 5,&#10;                        currentRound INTEGER NOT NULL DEFAULT 1,&#10;                        score INTEGER NOT NULL DEFAULT 0,&#10;                        isCompleted INTEGER NOT NULL DEFAULT 0,&#10;                        createdAt INTEGER NOT NULL DEFAULT ${System.currentTimeMillis()},&#10;                        startedAt INTEGER,&#10;                        completedAt INTEGER,&#10;                        duration INTEGER&#10;                    )&#10;                &quot;&quot;&quot;)&#10;            }&#10;&#10;            // Indizes neu erstellen ohne Foreign Key Constraints&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_userId` ON `games` (`userId`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_isCompleted` ON `games` (`isCompleted`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_createdAt` ON `games` (`createdAt`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_completedAt` ON `games` (`completedAt`)&quot;)&#10;&#10;            // Prüfe ob users Tabelle existiert&#10;            val usersCursor = database.query(&quot;SELECT name FROM sqlite_master WHERE type='table' AND name='users'&quot;)&#10;            val usersTableExists = usersCursor.moveToFirst()&#10;            usersCursor.close()&#10;&#10;            if (!usersTableExists) {&#10;                // Erstelle users Tabelle falls sie nicht existiert&#10;                database.execSQL(&quot;&quot;&quot;&#10;                    CREATE TABLE users (&#10;                        id TEXT PRIMARY KEY NOT NULL,&#10;                        username TEXT NOT NULL,&#10;                        email TEXT NOT NULL,&#10;                        authToken TEXT,&#10;                        totalScore INTEGER NOT NULL DEFAULT 0,&#10;                        gamesPlayed INTEGER NOT NULL DEFAULT 0,&#10;                        bestScore INTEGER NOT NULL DEFAULT 0,&#10;                        lastLoginAt INTEGER NOT NULL DEFAULT 0,&#10;                        createdAt INTEGER NOT NULL DEFAULT ${System.currentTimeMillis()}&#10;                    )&#10;                &quot;&quot;&quot;)&#10;            }&#10;&#10;            // Emergency User erstellen falls nicht vorhanden&#10;            database.execSQL(&quot;&quot;&quot;&#10;                INSERT OR IGNORE INTO users (id, username, email, authToken, totalScore, gamesPlayed, bestScore, lastLoginAt, createdAt)&#10;                VALUES ('emergency_user', 'Emergency User', 'emergency@local.com', NULL, 0, 0, 0, ${System.currentTimeMillis()}, ${System.currentTimeMillis()})&#10;            &quot;&quot;&quot;)&#10;        }&#10;    }&#10;&#10;    private val MIGRATION_6_7 = object : Migration(6, 7) {&#10;        override fun migrate(database: SupportSQLiteDatabase) {&#10;            // Version 7: Sanfte Bereinigung der Database-Probleme ohne komplettes Löschen&#10;&#10;            // Prüfe welche Tabellen existieren&#10;            val gamesCursor = database.query(&quot;SELECT name FROM sqlite_master WHERE type='table' AND name='games'&quot;)&#10;            val gamesTableExists = gamesCursor.moveToFirst()&#10;            gamesCursor.close()&#10;&#10;            val locationsCursor = database.query(&quot;SELECT name FROM sqlite_master WHERE type='table' AND name='locations'&quot;)&#10;            val locationsTableExists = locationsCursor.moveToFirst()&#10;            locationsCursor.close()&#10;&#10;            val guessesCursor = database.query(&quot;SELECT name FROM sqlite_master WHERE type='table' AND name='guesses'&quot;)&#10;            val guessesTableExists = guessesCursor.moveToFirst()&#10;            guessesCursor.close()&#10;&#10;            // Nur problematische games Tabelle neu erstellen (wegen &quot;duration&quot; Spalten-Problem)&#10;            if (gamesTableExists) {&#10;                database.execSQL(&quot;DROP TABLE IF EXISTS games&quot;)&#10;            }&#10;&#10;            // Erstelle games Tabelle neu mit korrekter Struktur&#10;            database.execSQL(&quot;&quot;&quot;&#10;                CREATE TABLE games (&#10;                    id TEXT PRIMARY KEY NOT NULL,&#10;                    userId TEXT NOT NULL,&#10;                    gameMode TEXT NOT NULL DEFAULT 'classic',&#10;                    totalRounds INTEGER NOT NULL DEFAULT 5,&#10;                    currentRound INTEGER NOT NULL DEFAULT 1,&#10;                    score INTEGER NOT NULL DEFAULT 0,&#10;                    isCompleted INTEGER NOT NULL DEFAULT 0,&#10;                    createdAt INTEGER NOT NULL,&#10;                    startedAt INTEGER,&#10;                    completedAt INTEGER,&#10;                    duration INTEGER&#10;                )&#10;            &quot;&quot;&quot;)&#10;&#10;            // Erstelle locations Tabelle nur wenn sie nicht existiert&#10;            if (!locationsTableExists) {&#10;                database.execSQL(&quot;&quot;&quot;&#10;                    CREATE TABLE locations (&#10;                        id TEXT PRIMARY KEY NOT NULL,&#10;                        latitude REAL NOT NULL,&#10;                        longitude REAL NOT NULL,&#10;                        imageUrl TEXT NOT NULL,&#10;                        country TEXT,&#10;                        city TEXT,&#10;                        difficulty INTEGER NOT NULL DEFAULT 1,&#10;                        isCached INTEGER NOT NULL DEFAULT 0,&#10;                        isUsed INTEGER NOT NULL DEFAULT 0,&#10;                        cachedAt INTEGER NOT NULL DEFAULT ${System.currentTimeMillis()}&#10;                    )&#10;                &quot;&quot;&quot;)&#10;            }&#10;&#10;            // Erstelle guesses Tabelle nur wenn sie nicht existiert&#10;            if (!guessesTableExists) {&#10;                database.execSQL(&quot;&quot;&quot;&#10;                    CREATE TABLE guesses (&#10;                        id TEXT PRIMARY KEY NOT NULL,&#10;                        gameId TEXT NOT NULL,&#10;                        locationId TEXT NOT NULL,&#10;                        guessLat REAL NOT NULL,&#10;                        guessLng REAL NOT NULL,&#10;                        actualLat REAL NOT NULL,&#10;                        actualLng REAL NOT NULL,&#10;                        distance REAL NOT NULL,&#10;                        score INTEGER NOT NULL,&#10;                        timeSpent INTEGER NOT NULL,&#10;                        submittedAt INTEGER NOT NULL&#10;                    )&#10;                &quot;&quot;&quot;)&#10;            }&#10;&#10;            // Erstelle alle Indizes neu (falls sie nicht existieren)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_userId` ON `games` (`userId`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_isCompleted` ON `games` (`isCompleted`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_createdAt` ON `games` (`createdAt`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_guesses_gameId` ON `guesses` (`gameId`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_guesses_locationId` ON `guesses` (`locationId`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_locations_isUsed_isCached` ON `locations` (`isUsed`, `isCached`)&quot;)&#10;&#10;            // Stelle sicher, dass users Tabelle existiert&#10;            val usersCursor = database.query(&quot;SELECT name FROM sqlite_master WHERE type='table' AND name='users'&quot;)&#10;            val usersTableExists = usersCursor.moveToFirst()&#10;            usersCursor.close()&#10;&#10;            if (!usersTableExists) {&#10;                database.execSQL(&quot;&quot;&quot;&#10;                    CREATE TABLE users (&#10;                        id TEXT PRIMARY KEY NOT NULL,&#10;                        username TEXT NOT NULL,&#10;                        email TEXT NOT NULL,&#10;                        authToken TEXT,&#10;                        totalScore INTEGER NOT NULL DEFAULT 0,&#10;                        gamesPlayed INTEGER NOT NULL DEFAULT 0,&#10;                        bestScore INTEGER NOT NULL DEFAULT 0,&#10;                        lastLoginAt INTEGER NOT NULL DEFAULT 0,&#10;                        createdAt INTEGER NOT NULL DEFAULT ${System.currentTimeMillis()}&#10;                    )&#10;                &quot;&quot;&quot;)&#10;            }&#10;&#10;            // Emergency User erstellen&#10;            database.execSQL(&quot;&quot;&quot;&#10;                INSERT OR IGNORE INTO users (id, username, email, authToken, totalScore, gamesPlayed, bestScore, lastLoginAt, createdAt)&#10;                VALUES ('emergency_user', 'Emergency User', 'emergency@local.com', NULL, 0, 0, 0, ${System.currentTimeMillis()}, ${System.currentTimeMillis()})&#10;            &quot;&quot;&quot;)&#10;&#10;            // Füge Standard-Fallback-Locations hinzu falls locations Tabelle leer ist&#10;            try {&#10;                val countCursor = database.query(&quot;SELECT COUNT(*) FROM locations&quot;)&#10;                val hasLocations = if (countCursor.moveToFirst()) {&#10;                    countCursor.getInt(0) &gt; 0&#10;                } else {&#10;                    false&#10;                }&#10;                countCursor.close()&#10;&#10;                if (!hasLocations) {&#10;                    // Füge eine Fallback-Location hinzu&#10;                    database.execSQL(&quot;&quot;&quot;&#10;                        INSERT INTO locations (id, latitude, longitude, imageUrl, country, city, difficulty, isCached, isUsed, cachedAt)&#10;                        VALUES ('fallback_paris', 48.8566, 2.3522, 'https://images.unsplash.com/photo-1502602898536-47ad22581b52?w=800', 'France', 'Paris', 2, 1, 0, ${System.currentTimeMillis()})&#10;                    &quot;&quot;&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                // Silent fail - Fallback-Location konnte nicht eingefügt werden&#10;            }&#10;        }&#10;    }&#10;&#10;    private val MIGRATION_7_8 = object : Migration(7, 8) {&#10;        override fun migrate(database: SupportSQLiteDatabase) {&#10;            // Version 8: Radikaler Clean-Slate. Löscht alle Tabellen und erstellt sie neu.&#10;            // Dies behebt alle vorherigen Migrationsprobleme garantiert.&#10;&#10;            // 1. Alle alten Tabellen löschen&#10;            database.execSQL(&quot;DROP TABLE IF EXISTS `games`&quot;)&#10;            database.execSQL(&quot;DROP TABLE IF EXISTS `guesses`&quot;)&#10;            database.execSQL(&quot;DROP TABLE IF EXISTS `locations`&quot;)&#10;            database.execSQL(&quot;DROP TABLE IF EXISTS `users`&quot;)&#10;&#10;            // 2. Alle Tabellen mit der korrekten, aktuellen Struktur neu erstellen&#10;            database.execSQL(&quot;&quot;&quot;&#10;                CREATE TABLE `users` (&#10;                    `id` TEXT NOT NULL, &#10;                    `username` TEXT NOT NULL, &#10;                    `email` TEXT NOT NULL, &#10;                    `authToken` TEXT, &#10;                    `totalScore` INTEGER NOT NULL DEFAULT 0, &#10;                    `gamesPlayed` INTEGER NOT NULL DEFAULT 0, &#10;                    `bestScore` INTEGER NOT NULL DEFAULT 0, &#10;                    `lastLoginAt` INTEGER NOT NULL DEFAULT 0, &#10;                    `createdAt` INTEGER NOT NULL, &#10;                    PRIMARY KEY(`id`)&#10;                )&#10;            &quot;&quot;&quot;)&#10;&#10;            database.execSQL(&quot;&quot;&quot;&#10;                CREATE TABLE `locations` (&#10;                    `id` TEXT NOT NULL, &#10;                    `latitude` REAL NOT NULL, &#10;                    `longitude` REAL NOT NULL, &#10;                    `imageUrl` TEXT NOT NULL, &#10;                    `country` TEXT, &#10;                    `city` TEXT, &#10;                    `difficulty` INTEGER NOT NULL DEFAULT 1, &#10;                    `isCached` INTEGER NOT NULL DEFAULT 0, &#10;                    `isUsed` INTEGER NOT NULL DEFAULT 0, &#10;                    `cachedAt` INTEGER NOT NULL, &#10;                    PRIMARY KEY(`id`)&#10;                )&#10;            &quot;&quot;&quot;)&#10;&#10;            database.execSQL(&quot;&quot;&quot;&#10;                CREATE TABLE `games` (&#10;                    `id` TEXT NOT NULL, &#10;                    `userId` TEXT NOT NULL, &#10;                    `gameMode` TEXT NOT NULL, &#10;                    `totalRounds` INTEGER NOT NULL, &#10;                    `currentRound` INTEGER NOT NULL, &#10;                    `score` INTEGER NOT NULL, &#10;                    `isCompleted` INTEGER NOT NULL, &#10;                    `createdAt` INTEGER NOT NULL, &#10;                    `startedAt` INTEGER, &#10;                    `completedAt` INTEGER, &#10;                    `duration` INTEGER, &#10;                    PRIMARY KEY(`id`)&#10;                )&#10;            &quot;&quot;&quot;)&#10;            &#10;            database.execSQL(&quot;&quot;&quot;&#10;                CREATE TABLE `guesses` (&#10;                    `id` TEXT NOT NULL, &#10;                    `gameId` TEXT NOT NULL, &#10;                    `locationId` TEXT NOT NULL, &#10;                    `guessLat` REAL NOT NULL, &#10;                    `guessLng` REAL NOT NULL, &#10;                    `actualLat` REAL NOT NULL, &#10;                    `actualLng` REAL NOT NULL, &#10;                    `distance` REAL NOT NULL, &#10;                    `score` INTEGER NOT NULL, &#10;                    `timeSpent` INTEGER NOT NULL, &#10;                    `submittedAt` INTEGER NOT NULL, &#10;                    PRIMARY KEY(`id`)&#10;                )&#10;            &quot;&quot;&quot;)&#10;&#10;            // 3. Alle Indizes neu erstellen&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_userId` ON `games` (`userId`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_locations_isUsed_isCached` ON `locations` (`isUsed`, `isCached`)&quot;)&#10;&#10;            // 4. Notwendige Start-Daten einfügen&#10;            database.execSQL(&quot;&quot;&quot;&#10;                INSERT INTO users (id, username, email, createdAt) &#10;                VALUES ('emergency_user', 'Emergency User', 'emergency@local.com', ${System.currentTimeMillis()})&#10;            &quot;&quot;&quot;)&#10;            database.execSQL(&quot;&quot;&quot;&#10;                INSERT INTO locations (id, latitude, longitude, imageUrl, country, city, cachedAt)&#10;                VALUES ('fallback_paris', 48.8566, 2.3522, 'https://images.unsplash.com/photo-1502602898536-47ad22581b52?w=800', 'France', 'Paris', ${System.currentTimeMillis()})&#10;            &quot;&quot;&quot;)&#10;        }&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {&#10;        return Room.databaseBuilder(&#10;            context,&#10;            AppDatabase::class.java,&#10;            &quot;geoguesser_database&quot;&#10;        )&#10;        .addMigrations(&#10;            MIGRATION_1_2,&#10;            MIGRATION_2_3,&#10;            MIGRATION_3_4,&#10;            MIGRATION_4_5,&#10;            MIGRATION_5_6,&#10;            MIGRATION_6_7,&#10;            MIGRATION_7_8 // Neue, saubere Migration&#10;        )&#10;        .setQueryExecutor(Executors.newFixedThreadPool(4))&#10;        .setTransactionExecutor(Executors.newFixedThreadPool(2))&#10;        // Fallback Strategy für Development&#10;        .fallbackToDestructiveMigration()&#10;        .build()&#10;    }&#10;&#10;    @Provides&#10;    fun provideUserDao(database: AppDatabase) = database.userDao()&#10;&#10;    @Provides&#10;    fun provideLocationDao(database: AppDatabase) = database.locationDao()&#10;&#10;    @Provides&#10;    fun provideGameDao(database: AppDatabase) = database.gameDao()&#10;&#10;    @Provides&#10;    fun provideGuessDao(database: AppDatabase) = database.guessDao()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/GeoGuessrApplication.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/GeoGuessrApplication.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone&#10;&#10;import android.app.Application&#10;import dagger.hilt.android.HiltAndroidApp&#10;&#10;@HiltAndroidApp&#10;class GeoGuessrApplication : Application() {&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/Networkmodule.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/Networkmodule.kt" />
              <option name="originalContent" value="package com.example.geogeusserclone&#10;&#10;import android.content.Context&#10;import com.example.geogeusserclone.data.network.ApiService&#10;import com.example.geogeusserclone.data.network.AuthInterceptor&#10;import com.example.geogeusserclone.utils.Constants&#10;import dagger.Module&#10;import dagger.Provides&#10;import dagger.hilt.InstallIn&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#10;import dagger.hilt.components.SingletonComponent&#10;import okhttp3.Cache&#10;import okhttp3.OkHttpClient&#10;import okhttp3.logging.HttpLoggingInterceptor&#10;import retrofit2.Retrofit&#10;import retrofit2.converter.gson.GsonConverterFactory&#10;import javax.inject.Named&#10;import javax.inject.Singleton&#10;import java.util.concurrent.TimeUnit&#10;&#10;@Module&#10;@InstallIn(SingletonComponent::class)&#10;object NetworkModule {&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideCache(@ApplicationContext context: Context): Cache {&#10;        val cacheSize = 10 * 1024 * 1024L // 10 MB&#10;        return Cache(context.cacheDir, cacheSize)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideAuthInterceptor(tokenManager: TokenManager): AuthInterceptor {&#10;        return AuthInterceptor(tokenManager)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideOkHttpClient(&#10;        authInterceptor: AuthInterceptor,&#10;        cache: Cache&#10;    ): OkHttpClient {&#10;        val loggingInterceptor = HttpLoggingInterceptor().apply {&#10;            level = HttpLoggingInterceptor.Level.BODY&#10;        }&#10;&#10;        return OkHttpClient.Builder()&#10;            .addInterceptor(authInterceptor)&#10;            .addInterceptor(loggingInterceptor)&#10;            .cache(cache)&#10;            .connectTimeout(Constants.CONNECT_TIMEOUT, TimeUnit.SECONDS)&#10;            .readTimeout(Constants.READ_TIMEOUT, TimeUnit.SECONDS)&#10;            .writeTimeout(Constants.WRITE_TIMEOUT, TimeUnit.SECONDS)&#10;            .build()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {&#10;        return Retrofit.Builder()&#10;            .baseUrl(Constants.BASE_URL)&#10;            .client(okHttpClient)&#10;            .addConverterFactory(GsonConverterFactory.create())&#10;            .build()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideApiService(retrofit: Retrofit): ApiService {&#10;        return retrofit.create(ApiService::class.java)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    @Named(&quot;mapillary&quot;)&#10;    fun provideMapillaryRetrofit(): Retrofit {&#10;        val loggingInterceptor = HttpLoggingInterceptor().apply {&#10;            level = HttpLoggingInterceptor.Level.BASIC&#10;        }&#10;&#10;        val mapillaryClient = OkHttpClient.Builder()&#10;            .addInterceptor(loggingInterceptor)&#10;            .connectTimeout(Constants.CONNECT_TIMEOUT, TimeUnit.SECONDS)&#10;            .readTimeout(Constants.READ_TIMEOUT, TimeUnit.SECONDS)&#10;            .writeTimeout(Constants.WRITE_TIMEOUT, TimeUnit.SECONDS)&#10;            .build()&#10;&#10;        return Retrofit.Builder()&#10;            .baseUrl(Constants.MAPILLARY_BASE_URL)&#10;            .client(mapillaryClient)&#10;            .addConverterFactory(GsonConverterFactory.create())&#10;            .build()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideMapillaryApiService(@Named(&quot;mapillary&quot;) retrofit: Retrofit): com.example.geogeusserclone.data.network.MapillaryApiService {&#10;        return retrofit.create(com.example.geogeusserclone.data.network.MapillaryApiService::class.java)&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.geogeusserclone&#13;&#10;&#13;&#10;import android.content.Context&#13;&#10;import com.example.geogeusserclone.data.network.ApiService&#13;&#10;import com.example.geogeusserclone.data.network.AuthInterceptor&#13;&#10;import com.example.geogeusserclone.data.network.TokenManager&#13;&#10;import com.example.geogeusserclone.utils.Constants&#13;&#10;import dagger.Module&#13;&#10;import dagger.Provides&#13;&#10;import dagger.hilt.InstallIn&#13;&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#13;&#10;import dagger.hilt.components.SingletonComponent&#13;&#10;import okhttp3.Cache&#13;&#10;import okhttp3.OkHttpClient&#13;&#10;import okhttp3.logging.HttpLoggingInterceptor&#13;&#10;import retrofit2.Retrofit&#13;&#10;import retrofit2.converter.gson.GsonConverterFactory&#13;&#10;import javax.inject.Named&#13;&#10;import javax.inject.Singleton&#13;&#10;import java.util.concurrent.TimeUnit&#13;&#10;&#13;&#10;@Module&#13;&#10;@InstallIn(SingletonComponent::class)&#13;&#10;object NetworkModule {&#13;&#10;&#13;&#10;    @Provides&#13;&#10;    @Singleton&#13;&#10;    fun provideTokenManager(@ApplicationContext context: Context): TokenManager {&#13;&#10;        return TokenManager(context)&#13;&#10;    }&#13;&#10;&#13;&#10;    @Provides&#13;&#10;    @Singleton&#13;&#10;    fun provideCache(@ApplicationContext context: Context): Cache {&#13;&#10;        val cacheSize = 10 * 1024 * 1024L // 10 MB&#13;&#10;        return Cache(context.cacheDir, cacheSize)&#13;&#10;    }&#13;&#10;&#13;&#10;    @Provides&#13;&#10;    @Singleton&#13;&#10;    fun provideAuthInterceptor(tokenManager: TokenManager): AuthInterceptor {&#13;&#10;        return AuthInterceptor(tokenManager)&#13;&#10;    }&#13;&#10;&#13;&#10;    @Provides&#13;&#10;    @Singleton&#13;&#10;    fun provideOkHttpClient(&#13;&#10;        authInterceptor: AuthInterceptor,&#13;&#10;        cache: Cache&#13;&#10;    ): OkHttpClient {&#13;&#10;        val loggingInterceptor = HttpLoggingInterceptor().apply {&#13;&#10;            level = HttpLoggingInterceptor.Level.BODY&#13;&#10;        }&#13;&#10;&#13;&#10;        return OkHttpClient.Builder()&#13;&#10;            .addInterceptor(authInterceptor)&#13;&#10;            .addInterceptor(loggingInterceptor)&#13;&#10;            .cache(cache)&#13;&#10;            .connectTimeout(Constants.CONNECT_TIMEOUT, TimeUnit.SECONDS)&#13;&#10;            .readTimeout(Constants.READ_TIMEOUT, TimeUnit.SECONDS)&#13;&#10;            .writeTimeout(Constants.WRITE_TIMEOUT, TimeUnit.SECONDS)&#13;&#10;            .build()&#13;&#10;    }&#13;&#10;&#13;&#10;    @Provides&#13;&#10;    @Singleton&#13;&#10;    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {&#13;&#10;        return Retrofit.Builder()&#13;&#10;            .baseUrl(Constants.BASE_URL)&#13;&#10;            .client(okHttpClient)&#13;&#10;            .addConverterFactory(GsonConverterFactory.create())&#13;&#10;            .build()&#13;&#10;    }&#13;&#10;&#13;&#10;    @Provides&#13;&#10;    @Singleton&#13;&#10;    fun provideApiService(retrofit: Retrofit): ApiService {&#13;&#10;        return retrofit.create(ApiService::class.java)&#13;&#10;    }&#13;&#10;&#13;&#10;    @Provides&#13;&#10;    @Singleton&#13;&#10;    @Named(&quot;mapillary&quot;)&#13;&#10;    fun provideMapillaryRetrofit(): Retrofit {&#13;&#10;        val loggingInterceptor = HttpLoggingInterceptor().apply {&#13;&#10;            level = HttpLoggingInterceptor.Level.BASIC&#13;&#10;        }&#13;&#10;&#13;&#10;        val mapillaryClient = OkHttpClient.Builder()&#13;&#10;            .addInterceptor(loggingInterceptor)&#13;&#10;            .connectTimeout(Constants.CONNECT_TIMEOUT, TimeUnit.SECONDS)&#13;&#10;            .readTimeout(Constants.READ_TIMEOUT, TimeUnit.SECONDS)&#13;&#10;            .writeTimeout(Constants.WRITE_TIMEOUT, TimeUnit.SECONDS)&#13;&#10;            .build()&#13;&#10;&#13;&#10;        return Retrofit.Builder()&#13;&#10;            .baseUrl(Constants.MAPILLARY_BASE_URL)&#13;&#10;            .client(mapillaryClient)&#13;&#10;            .addConverterFactory(GsonConverterFactory.create())&#13;&#10;            .build()&#13;&#10;    }&#13;&#10;&#13;&#10;    @Provides&#13;&#10;    @Singleton&#13;&#10;    fun provideMapillaryApiService(@Named(&quot;mapillary&quot;) retrofit: Retrofit): com.example.geogeusserclone.data.network.MapillaryApiService {&#13;&#10;        return retrofit.create(com.example.geogeusserclone.data.network.MapillaryApiService::class.java)&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/RepositoryModule.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/RepositoryModule.kt" />
              <option name="originalContent" value="package com.example.geogeusserclone&#10;&#10;import com.example.geogeusserclone.data.database.AppDatabase&#10;import com.example.geogeusserclone.data.network.ApiService&#10;import com.example.geogeusserclone.data.network.AuthInterceptor&#10;import com.example.geogeusserclone.data.repositories.*&#10;import dagger.Module&#10;import dagger.Provides&#10;import dagger.hilt.InstallIn&#10;import dagger.hilt.components.SingletonComponent&#10;import javax.inject.Singleton&#10;@Module&#10;@InstallIn(SingletonComponent::class)&#10;object RepositoryModule {&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideUserRepository(&#10;        apiService: ApiService,&#10;        database: AppDatabase,&#10;        authInterceptor: AuthInterceptor&#10;    ): UserRepository {&#10;        return UserRepository(&#10;            apiService = apiService,&#10;            userDao = database.userDao(),&#10;            authInterceptor = authInterceptor&#10;        )&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideLocationRepository(&#10;        apiService: ApiService,&#10;        database: AppDatabase&#10;    ): LocationRepository {&#10;        return LocationRepository(&#10;            apiService = apiService,&#10;            locationDao = database.locationDao()&#10;        )&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideGameRepository(&#10;        apiService: ApiService,&#10;        database: AppDatabase,&#10;        userRepository: UserRepository&#10;    ): GameRepository {&#10;        return GameRepository(&#10;            apiService = apiService,&#10;            gameDao = database.gameDao(),&#10;            guessDao = database.guessDao(),&#10;            userRepository = userRepository&#10;        )&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideLocationCacheRepository(&#10;        apiService: ApiService,&#10;        database: AppDatabase&#10;    ): LocationCacheRepository {&#10;        return LocationCacheRepository(&#10;            apiService = apiService,&#10;            locationDao = database.locationDao()&#10;        )&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.example.geogeusserclone&#10;&#10;import com.example.geogeusserclone.data.database.AppDatabase&#10;import com.example.geogeusserclone.data.network.ApiService&#10;import com.example.geogeusserclone.data.network.AuthInterceptor&#10;import com.example.geogeusserclone.data.network.MapillaryApiService&#10;import com.example.geogeusserclone.data.repositories.*&#10;import dagger.Module&#10;import dagger.Provides&#10;import dagger.hilt.InstallIn&#10;import dagger.hilt.components.SingletonComponent&#10;import javax.inject.Singleton&#10;@Module&#10;@InstallIn(SingletonComponent::class)&#10;object RepositoryModule {&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideUserRepository(&#10;        apiService: ApiService,&#10;        database: AppDatabase,&#10;        authInterceptor: AuthInterceptor&#10;    ): UserRepository {&#10;        return UserRepository(&#10;            apiService = apiService,&#10;            userDao = database.userDao(),&#10;            authInterceptor = authInterceptor&#10;        )&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideLocationRepository(&#10;        apiService: ApiService,&#10;        mapillaryApiService: MapillaryApiService,&#10;        database: AppDatabase&#10;    ): LocationRepository {&#10;        return LocationRepository(&#10;            apiService = apiService,&#10;            mapillaryApiService = mapillaryApiService,&#10;            locationDao = database.locationDao()&#10;        )&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideGameRepository(&#10;        apiService: ApiService,&#10;        database: AppDatabase,&#10;        userRepository: UserRepository&#10;    ): GameRepository {&#10;        return GameRepository(&#10;            apiService = apiService,&#10;            gameDao = database.gameDao(),&#10;            guessDao = database.guessDao(),&#10;            locationDao = database.locationDao(),&#10;            userRepository = userRepository&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/database/AppDatabase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/database/AppDatabase.kt" />
              <option name="originalContent" value="package com.example.geogeusserclone.data.database&#10;&#10;import androidx.room.Database&#10;import androidx.room.Room&#10;import androidx.room.RoomDatabase&#10;import com.example.geogeusserclone.data.database.dao.*&#10;import com.example.geogeusserclone.data.database.entities.*&#10;&#10;@Database(&#10;    entities = [&#10;        UserEntity::class,&#10;        LocationEntity::class,&#10;        GameEntity::class,&#10;        GuessEntity::class&#10;    ],&#10;    version = 7, // Version erhöht von 6 auf 7&#10;    exportSchema = false&#10;)&#10;abstract class AppDatabase : RoomDatabase() {&#10;&#10;    abstract fun userDao(): UserDao&#10;    abstract fun locationDao(): LocationDao&#10;    abstract fun gameDao(): GameDao&#10;    abstract fun guessDao(): GuessDao&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.database&#10;&#10;import androidx.room.Database&#10;import androidx.room.Room&#10;import androidx.room.RoomDatabase&#10;import com.example.geogeusserclone.data.database.dao.*&#10;import com.example.geogeusserclone.data.database.entities.*&#10;&#10;@Database(&#10;    entities = [&#10;        UserEntity::class,&#10;        LocationEntity::class,&#10;        GameEntity::class,&#10;        GuessEntity::class&#10;    ],&#10;    version = 8, // Version erhöht von 7 auf 8&#10;    exportSchema = false&#10;)&#10;abstract class AppDatabase : RoomDatabase() {&#10;&#10;    abstract fun userDao(): UserDao&#10;    abstract fun locationDao(): LocationDao&#10;    abstract fun gameDao(): GameDao&#10;    abstract fun guessDao(): GuessDao&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/database/dao/GameDao.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/database/dao/GameDao.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.database.dao&#10;&#10;import androidx.room.*&#10;import com.example.geogeusserclone.data.database.entities.GameEntity&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;@Dao&#10;interface GameDao {&#10;&#10;    @Query(&quot;SELECT * FROM games WHERE id = :gameId&quot;)&#10;    suspend fun getGameById(gameId: String): GameEntity?&#10;&#10;    @Query(&quot;SELECT * FROM games WHERE userId = :userId ORDER BY createdAt DESC&quot;)&#10;    fun getGamesByUser(userId: String): Flow&lt;List&lt;GameEntity&gt;&gt;&#10;&#10;    @Query(&quot;SELECT * FROM games WHERE userId = :userId AND isCompleted = 0 LIMIT 1&quot;)&#10;    suspend fun getCurrentGameForUser(userId: String): GameEntity?&#10;&#10;    @Query(&quot;SELECT * FROM games WHERE userId = :userId AND isCompleted = 1 ORDER BY score DESC LIMIT 1&quot;)&#10;    suspend fun getBestGameForUser(userId: String): GameEntity?&#10;&#10;    @Query(&quot;SELECT * FROM games ORDER BY createdAt DESC LIMIT :limit&quot;)&#10;    suspend fun getRecentGames(limit: Int = 10): List&lt;GameEntity&gt;&#10;&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertGame(game: GameEntity)&#10;&#10;    @Update&#10;    suspend fun updateGame(game: GameEntity)&#10;&#10;    @Delete&#10;    suspend fun deleteGame(game: GameEntity)&#10;&#10;    @Query(&quot;DELETE FROM games WHERE userId = :userId&quot;)&#10;    suspend fun deleteGamesByUser(userId: String)&#10;&#10;    @Query(&quot;SELECT COUNT(*) FROM games WHERE userId = :userId&quot;)&#10;    suspend fun getGameCountByUser(userId: String): Int&#10;&#10;    @Query(&quot;SELECT COUNT(*) FROM games WHERE userId = :userId AND isCompleted = 1&quot;)&#10;    suspend fun getCompletedGameCountByUser(userId: String): Int&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/database/dao/GuessDao.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/database/dao/GuessDao.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.database.dao&#10;&#10;import androidx.room.*&#10;import com.example.geogeusserclone.data.database.entities.GuessEntity&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;@Dao&#10;interface GuessDao {&#10;&#10;    @Query(&quot;SELECT * FROM guesses WHERE id = :guessId&quot;)&#10;    suspend fun getGuessById(guessId: String): GuessEntity?&#10;&#10;    @Query(&quot;SELECT * FROM guesses WHERE gameId = :gameId ORDER BY submittedAt ASC&quot;)&#10;    fun getGuessesByGame(gameId: String): Flow&lt;List&lt;GuessEntity&gt;&gt;&#10;&#10;    @Query(&quot;SELECT * FROM guesses WHERE gameId = :gameId ORDER BY submittedAt ASC&quot;)&#10;    suspend fun getGuessesByGameSync(gameId: String): List&lt;GuessEntity&gt;&#10;&#10;    @Query(&quot;SELECT * FROM guesses WHERE locationId = :locationId&quot;)&#10;    suspend fun getGuessesByLocation(locationId: String): List&lt;GuessEntity&gt;&#10;&#10;    @Query(&quot;SELECT AVG(score) FROM guesses WHERE gameId IN (SELECT id FROM games WHERE userId = :userId)&quot;)&#10;    suspend fun getAverageScoreByUser(userId: String): Double?&#10;&#10;    @Query(&quot;SELECT MAX(score) FROM guesses WHERE gameId IN (SELECT id FROM games WHERE userId = :userId)&quot;)&#10;    suspend fun getBestScoreByUser(userId: String): Int?&#10;&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertGuess(guess: GuessEntity)&#10;&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertGuesses(guesses: List&lt;GuessEntity&gt;)&#10;&#10;    @Update&#10;    suspend fun updateGuess(guess: GuessEntity)&#10;&#10;    @Delete&#10;    suspend fun deleteGuess(guess: GuessEntity)&#10;&#10;    @Query(&quot;DELETE FROM guesses WHERE gameId = :gameId&quot;)&#10;    suspend fun deleteGuessesByGame(gameId: String)&#10;&#10;    @Query(&quot;SELECT COUNT(*) FROM guesses WHERE gameId = :gameId&quot;)&#10;    suspend fun getGuessCountByGame(gameId: String): Int&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/database/dao/LocationDao.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/database/dao/LocationDao.kt" />
              <option name="originalContent" value="package com.example.geogeusserclone.data.database.dao&#10;&#10;import androidx.room.*&#10;import com.example.geogeusserclone.data.database.entities.LocationEntity&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;@Dao&#10;interface LocationDao {&#10;&#10;    @Query(&quot;SELECT * FROM locations WHERE isCached = 1&quot;)&#10;    fun getCachedLocations(): Flow&lt;List&lt;LocationEntity&gt;&gt;&#10;&#10;    @Query(&quot;SELECT * FROM locations WHERE id = :locationId&quot;)&#10;    suspend fun getLocationById(locationId: String): LocationEntity?&#10;&#10;    @Query(&quot;SELECT * FROM locations ORDER BY RANDOM() LIMIT :count&quot;)&#10;    suspend fun getRandomLocations(count: Int): List&lt;LocationEntity&gt;&#10;&#10;    @Query(&quot;SELECT * FROM locations WHERE isUsed = 0 ORDER BY RANDOM() LIMIT 1&quot;)&#10;    suspend fun getRandomUnusedLocation(): LocationEntity?&#10;&#10;    @Query(&quot;SELECT * FROM locations&quot;)&#10;    suspend fun getAllLocations(): List&lt;LocationEntity&gt;&#10;&#10;    @Query(&quot;UPDATE locations SET isUsed = 1 WHERE id = :locationId&quot;)&#10;    suspend fun markLocationAsUsed(locationId: String)&#10;&#10;    @Query(&quot;UPDATE locations SET isUsed = 0&quot;)&#10;    suspend fun resetAllLocationsUsage()&#10;&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertLocation(location: LocationEntity)&#10;&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertLocations(locations: List&lt;LocationEntity&gt;)&#10;&#10;    @Update&#10;    suspend fun updateLocation(location: LocationEntity)&#10;&#10;    @Query(&quot;DELETE FROM locations WHERE isCached = 0&quot;)&#10;    suspend fun deleteNonCachedLocations()&#10;&#10;    @Query(&quot;SELECT COUNT(*) FROM locations WHERE isCached = 1&quot;)&#10;    suspend fun getCachedLocationCount(): Int&#10;}" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.database.dao&#13;&#10;&#13;&#10;import androidx.room.*&#13;&#10;import com.example.geogeusserclone.data.database.entities.LocationEntity&#13;&#10;import kotlinx.coroutines.flow.Flow&#13;&#10;&#13;&#10;@Dao&#13;&#10;interface LocationDao {&#13;&#10;&#13;&#10;    @Query(&quot;SELECT * FROM locations WHERE isCached = 1&quot;)&#13;&#10;    fun getCachedLocations(): Flow&lt;List&lt;LocationEntity&gt;&gt;&#13;&#10;&#13;&#10;    @Query(&quot;SELECT * FROM locations WHERE id = :locationId&quot;)&#13;&#10;    suspend fun getLocationById(locationId: String): LocationEntity?&#13;&#10;&#13;&#10;    @Query(&quot;SELECT * FROM locations ORDER BY RANDOM() LIMIT :count&quot;)&#13;&#10;    suspend fun getRandomLocations(count: Int): List&lt;LocationEntity&gt;&#13;&#10;&#13;&#10;    @Query(&quot;SELECT * FROM locations WHERE isUsed = 0 ORDER BY RANDOM() LIMIT 1&quot;)&#13;&#10;    suspend fun getRandomUnusedLocation(): LocationEntity?&#13;&#10;&#13;&#10;    @Query(&quot;SELECT * FROM locations WHERE isUsed = 0 ORDER BY RANDOM() LIMIT :count&quot;)&#13;&#10;    suspend fun getUnusedLocations(count: Int): List&lt;LocationEntity&gt;&#13;&#10;&#13;&#10;    @Query(&quot;SELECT * FROM locations&quot;)&#13;&#10;    suspend fun getAllLocations(): List&lt;LocationEntity&gt;&#13;&#10;&#13;&#10;    @Query(&quot;UPDATE locations SET isUsed = 1 WHERE id = :locationId&quot;)&#13;&#10;    suspend fun markLocationAsUsed(locationId: String)&#13;&#10;&#13;&#10;    @Query(&quot;UPDATE locations SET isUsed = 0&quot;)&#13;&#10;    suspend fun resetAllLocationsUsage()&#13;&#10;&#13;&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#13;&#10;    suspend fun insertLocation(location: LocationEntity)&#13;&#10;&#13;&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#13;&#10;    suspend fun insertLocations(locations: List&lt;LocationEntity&gt;)&#13;&#10;&#13;&#10;    @Update&#13;&#10;    suspend fun updateLocation(location: LocationEntity)&#13;&#10;&#13;&#10;    @Query(&quot;DELETE FROM locations WHERE isCached = 0&quot;)&#13;&#10;    suspend fun deleteNonCachedLocations()&#13;&#10;&#13;&#10;    @Query(&quot;SELECT COUNT(*) FROM locations WHERE isCached = 1&quot;)&#13;&#10;    suspend fun getCachedLocationCount(): Int&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/database/dao/UserDao.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/database/dao/UserDao.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.database.dao&#10;&#10;import androidx.room.*&#10;import com.example.geogeusserclone.data.database.entities.UserEntity&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;@Dao&#10;interface UserDao {&#10;&#10;    @Query(&quot;SELECT * FROM users WHERE id = :userId&quot;)&#10;    suspend fun getUserById(userId: String): UserEntity?&#10;&#10;    @Query(&quot;SELECT * FROM users LIMIT 1&quot;)&#10;    suspend fun getCurrentUser(): UserEntity?&#10;&#10;    @Query(&quot;SELECT * FROM users ORDER BY totalScore DESC&quot;)&#10;    fun getAllUsers(): Flow&lt;List&lt;UserEntity&gt;&gt;&#10;&#10;    @Query(&quot;SELECT * FROM users ORDER BY totalScore DESC LIMIT :limit&quot;)&#10;    suspend fun getTopUsers(limit: Int = 10): List&lt;UserEntity&gt;&#10;&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertUser(user: UserEntity)&#10;&#10;    @Update&#10;    suspend fun updateUser(user: UserEntity)&#10;&#10;    @Delete&#10;    suspend fun deleteUser(user: UserEntity)&#10;&#10;    @Query(&quot;DELETE FROM users&quot;)&#10;    suspend fun clearCurrentUser()&#10;&#10;    @Query(&quot;SELECT COUNT(*) FROM users&quot;)&#10;    suspend fun getUserCount(): Int&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/database/entities/GameEntity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/database/entities/GameEntity.kt" />
              <option name="originalContent" value="package com.example.geogeusserclone.data.database.entities&#10;&#10;import androidx.room.Entity&#10;import androidx.room.ForeignKey&#10;import androidx.room.Index&#10;import androidx.room.PrimaryKey&#10;&#10;@Entity(&#10;    tableName = &quot;games&quot;,&#10;    foreignKeys = [&#10;        ForeignKey(&#10;            entity = UserEntity::class,&#10;            parentColumns = [&quot;id&quot;],&#10;            childColumns = [&quot;userId&quot;],&#10;            onDelete = ForeignKey.CASCADE&#10;        )&#10;    ],&#10;    indices = [&#10;        Index(value = [&quot;userId&quot;]),&#10;        Index(value = [&quot;isCompleted&quot;]),&#10;        Index(value = [&quot;createdAt&quot;])&#10;    ]&#10;)&#10;data class GameEntity(&#10;    @PrimaryKey&#10;    val id: String,&#10;    val userId: String,&#10;    val gameMode: String = &quot;classic&quot;,&#10;    val totalRounds: Int = 5,&#10;    val currentRound: Int = 1,&#10;    val score: Int = 0,&#10;    val isCompleted: Boolean = false,&#10;    val createdAt: Long = System.currentTimeMillis(),&#10;    val startedAt: Long? = null,&#10;    val completedAt: Long? = null,&#10;    val duration: Long? = null&#10;)&#10;" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.database.entities&#13;&#10;&#13;&#10;import androidx.room.Entity&#13;&#10;import androidx.room.Index&#13;&#10;import androidx.room.PrimaryKey&#13;&#10;&#13;&#10;@Entity(&#13;&#10;    tableName = &quot;games&quot;,&#13;&#10;    indices = [&#13;&#10;        Index(value = [&quot;userId&quot;]),&#13;&#10;        Index(value = [&quot;isCompleted&quot;]),&#13;&#10;        Index(value = [&quot;createdAt&quot;])&#13;&#10;    ]&#13;&#10;)&#13;&#10;data class GameEntity(&#13;&#10;    @PrimaryKey&#13;&#10;    val id: String,&#13;&#10;    val userId: String,&#13;&#10;    val gameMode: String = &quot;classic&quot;,&#13;&#10;    val totalRounds: Int = 5,&#13;&#10;    val currentRound: Int = 1,&#13;&#10;    val score: Int = 0,&#13;&#10;    val isCompleted: Boolean = false,&#13;&#10;    val createdAt: Long = System.currentTimeMillis(),&#13;&#10;    val startedAt: Long? = null,&#13;&#10;    val completedAt: Long? = null,&#13;&#10;    val duration: Long? = null&#13;&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/database/entities/GuessEntity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/database/entities/GuessEntity.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.database.entities&#10;&#10;import androidx.room.Entity&#10;import androidx.room.ForeignKey&#10;import androidx.room.Index&#10;import androidx.room.PrimaryKey&#10;&#10;@Entity(&#10;    tableName = &quot;guesses&quot;,&#10;    foreignKeys = [&#10;        ForeignKey(&#10;            entity = GameEntity::class,&#10;            parentColumns = [&quot;id&quot;],&#10;            childColumns = [&quot;gameId&quot;],&#10;            onDelete = ForeignKey.CASCADE&#10;        ),&#10;        ForeignKey(&#10;            entity = LocationEntity::class,&#10;            parentColumns = [&quot;id&quot;],&#10;            childColumns = [&quot;locationId&quot;],&#10;            onDelete = ForeignKey.CASCADE&#10;        )&#10;    ],&#10;    indices = [&#10;        Index(value = [&quot;gameId&quot;]),&#10;        Index(value = [&quot;locationId&quot;]),&#10;        Index(value = [&quot;submittedAt&quot;])&#10;    ]&#10;)&#10;data class GuessEntity(&#10;    @PrimaryKey&#10;    val id: String,&#10;    val gameId: String,&#10;    val locationId: String,&#10;    val guessLat: Double,&#10;    val guessLng: Double,&#10;    val actualLat: Double,&#10;    val actualLng: Double,&#10;    val distance: Double,&#10;    val score: Int,&#10;    val timeSpent: Long,&#10;    val submittedAt: Long = System.currentTimeMillis()&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/database/entities/LocationEntity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/database/entities/LocationEntity.kt" />
              <option name="originalContent" value="&#10;import androidx.room.Entity&#10;import androidx.room.PrimaryKey&#10;&#10;@Entity(tableName = &quot;locations&quot;)&#10;data class LocationEntity(&#10;    @PrimaryKey&#10;    val id: String,&#10;    val latitude: Double,&#10;    val longitude: Double,&#10;    val imageUrl: String,&#10;    val country: String? = null,&#10;    val city: String? = null,&#10;    val difficulty: Int = 1,&#10;    val isCached: Boolean = false,&#10;    val isUsed: Boolean = false,&#10;    val cachedAt: Long = System.currentTimeMillis()&#10;)" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.database.entities&#10;&#10;import androidx.room.Entity&#10;import androidx.room.PrimaryKey&#10;&#10;@Entity(tableName = &quot;locations&quot;)&#10;data class LocationEntity(&#10;    @PrimaryKey&#10;    val id: String,&#10;    val latitude: Double,&#10;    val longitude: Double,&#10;    val imageUrl: String,&#10;    val country: String? = null,&#10;    val city: String? = null,&#10;    val difficulty: Int = 1,&#10;    val isCached: Boolean = false,&#10;    val isUsed: Boolean = false,&#10;    val cachedAt: Long = System.currentTimeMillis()&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/database/entities/UserEntity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/database/entities/UserEntity.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.database.entities&#10;&#10;import androidx.room.Entity&#10;import androidx.room.PrimaryKey&#10;&#10;@Entity(tableName = &quot;users&quot;)&#10;data class UserEntity(&#10;    @PrimaryKey&#10;    val id: String,&#10;    val username: String,&#10;    val email: String,&#10;    val authToken: String? = null,&#10;    val totalScore: Int = 0,&#10;    val gamesPlayed: Int = 0,&#10;    val bestScore: Int = 0,&#10;    val lastLoginAt: Long = 0L,&#10;    val createdAt: Long = System.currentTimeMillis()&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/models/GameState.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/models/GameState.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.models&#10;&#10;data class GameState(&#10;    val currentGame: com.example.geogeusserclone.data.database.entities.GameEntity? = null,&#10;    val currentLocation: com.example.geogeusserclone.data.database.entities.LocationEntity? = null,&#10;    val isLoading: Boolean = false,&#10;    val error: String? = null,&#10;    val showMap: Boolean = false,&#10;    val showRoundResult: Boolean = false,&#10;    val showGameCompletion: Boolean = false,&#10;    val revealGuessResult: com.example.geogeusserclone.data.database.entities.GuessEntity? = null,&#10;    val timeRemaining: Long = 120000L, // 2 Minuten default&#10;    val currentRound: Int = 1,&#10;    val totalRounds: Int = 5,&#10;    val gameScore: Int = 0&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/models/GameStats.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/models/GameStats.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.models&#10;&#10;data class GameStats(&#10;    val totalGames: Int = 0,&#10;    val totalScore: Int = 0,&#10;    val averageScore: Double = 0.0,&#10;    val bestScore: Int = 0,&#10;    val perfectGuesses: Int = 0,&#10;    val averageDistance: Double = 0.0,&#10;    val bestDistance: Double = Double.MAX_VALUE,&#10;    val totalTimeSpent: Long = 0L,&#10;    val averageTimePerRound: Long = 0L,&#10;    val gamesWon: Int = 0,&#10;    val winRate: Double = 0.0,&#10;    val favoriteCountry: String? = null,&#10;    val monthlyStats: List&lt;MonthlyGameStats&gt; = emptyList()&#10;)&#10;&#10;data class MonthlyGameStats(&#10;    val month: String,&#10;    val year: Int,&#10;    val gamesPlayed: Int,&#10;    val totalScore: Int,&#10;    val averageScore: Double&#10;)&#10;&#10;data class UserStats(&#10;    val userId: String,&#10;    val username: String,&#10;    val totalGames: Int,&#10;    val totalScore: Int,&#10;    val averageScore: Double,&#10;    val bestScore: Int,&#10;    val rank: Int = 0,&#10;    val lastActive: Long = 0L&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/network/ApiService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/network/ApiService.kt" />
              <option name="originalContent" value="package com.example.geogeusserclone.data.network&#10;&#10;import com.example.geogeusserclone.data.network.LocationResponse&#10;import com.example.geogeusserclone.data.network.LocationsResponse&#10;import retrofit2.Response&#10;import retrofit2.http.*&#10;&#10;interface ApiService {&#10;&#10;    // Auth Endpoints (dein Backend)&#10;    @POST(&quot;auth/register&quot;)&#10;    suspend fun register(&#10;        @Body request: RegisterRequest&#10;    ): Response&lt;AuthResponse&gt;&#10;&#10;    @POST(&quot;auth/login&quot;)&#10;    suspend fun login(&#10;        @Body request: LoginRequest&#10;    ): Response&lt;AuthResponse&gt;&#10;&#10;    @POST(&quot;auth/refresh&quot;)&#10;    suspend fun refreshToken(): Response&lt;RefreshResponse&gt;&#10;&#10;    @POST(&quot;auth/logout&quot;)&#10;    suspend fun logout(): Response&lt;BaseResponse&gt;&#10;&#10;    // Location Endpoints (Google Maps Backend)&#10;    @GET(&quot;locations/random&quot;)&#10;    suspend fun getRandomLocations(&#10;        @Query(&quot;count&quot;) count: Int = 5,&#10;        @Query(&quot;difficulty&quot;) difficulty: Int? = null,&#10;        @Query(&quot;category&quot;) category: String? = null&#10;    ): Response&lt;RandomLocationsResponse&gt;&#10;&#10;    @GET(&quot;locations/{id}&quot;)&#10;    suspend fun getLocationById(&#10;        @Path(&quot;id&quot;) locationId: String&#10;    ): Response&lt;LocationDetailResponse&gt;&#10;&#10;    @GET(&quot;locations/{id}/streetview&quot;)&#10;    suspend fun getStreetViewImage(&#10;        @Path(&quot;id&quot;) locationId: String,&#10;        @Query(&quot;heading&quot;) heading: Int? = null,&#10;        @Query(&quot;multiple&quot;) multiple: Boolean = false,&#10;        @Query(&quot;responsive&quot;) responsive: Boolean = false&#10;    ): Response&lt;StreetViewResponse&gt;&#10;&#10;    @GET(&quot;locations/stats/overview&quot;)&#10;    suspend fun getLocationStats(): Response&lt;LocationStatsResponse&gt;&#10;&#10;    // Game Endpoints (dein Backend)&#10;    @POST(&quot;games/single&quot;)&#10;    suspend fun createSinglePlayerGame(&#10;        @Body request: CreateSingleGameRequest&#10;    ): Response&lt;GameCreationResponse&gt;&#10;&#10;    @PUT(&quot;games/{gameId}/result&quot;)&#10;    suspend fun submitGameResult(&#10;        @Path(&quot;gameId&quot;) gameId: String,&#10;        @Body request: GameResultSubmissionRequest&#10;    ): Response&lt;GameResultResponse&gt;&#10;&#10;    // Health Check&#10;    @GET(&quot;health&quot;)&#10;    suspend fun healthCheck(): Response&lt;HealthResponse&gt;&#10;}&#10;&#10;// Auth Models (angepasst an dein Backend)&#10;data class LoginRequest(&#10;    val usernameOrEmail: String,&#10;    val password: String&#10;)&#10;&#10;data class RegisterRequest(&#10;    val username: String,&#10;    val email: String,&#10;    val password: String&#10;)&#10;&#10;data class AuthResponse(&#10;    val success: Boolean,&#10;    val data: AuthData&#10;)&#10;&#10;data class AuthData(&#10;    val user: BackendUser,&#10;    val token: String,&#10;    val expiresIn: String = &quot;7d&quot;&#10;)&#10;&#10;data class BackendUser(&#10;    val id: String,&#10;    val username: String,&#10;    val email: String&#10;)&#10;&#10;data class RefreshResponse(&#10;    val success: Boolean,&#10;    val data: RefreshData&#10;)&#10;&#10;data class RefreshData(&#10;    val token: String,&#10;    val expiresIn: String&#10;)&#10;&#10;data class BaseResponse(&#10;    val success: Boolean,&#10;    val message: String&#10;)&#10;&#10;// Location Models (Google Maps Backend)&#10;data class RandomLocationsResponse(&#10;    val success: Boolean,&#10;    val data: LocationsData&#10;)&#10;&#10;data class LocationsData(&#10;    val count: Int,&#10;    val locations: List&lt;BackendLocation&gt;&#10;)&#10;&#10;data class BackendLocation(&#10;    val id: String,&#10;    val name: String? = null,&#10;    val country: String,&#10;    val city: String,&#10;    val coordinates: Coordinates,&#10;    val difficulty: Int,&#10;    val difficultyName: String,&#10;    val category: String,&#10;    val imageUrls: List&lt;String&gt; = emptyList(),&#10;    val hints: Map&lt;String, Any&gt; = emptyMap(),&#10;    val viewCount: Int = 0&#10;)&#10;&#10;data class Coordinates(&#10;    val latitude: Double,&#10;    val longitude: Double&#10;)&#10;&#10;data class LocationDetailResponse(&#10;    val success: Boolean,&#10;    val data: LocationDetailData&#10;)&#10;&#10;data class LocationDetailData(&#10;    val location: BackendLocation&#10;)&#10;&#10;data class StreetViewResponse(&#10;    val success: Boolean,&#10;    val data: StreetViewData&#10;)&#10;&#10;data class StreetViewData(&#10;    val location: StreetViewLocation,&#10;    val streetViewUrl: String? = null,&#10;    val streetViewUrls: Any? = null // Kann Map oder Array sein&#10;)&#10;&#10;data class StreetViewLocation(&#10;    val id: String,&#10;    val coordinates: Coordinates&#10;)&#10;&#10;// Game Models (dein Backend)&#10;data class CreateSingleGameRequest(&#10;    val difficulty: Int = 2,&#10;    val category: String = &quot;urban&quot;,&#10;    val rounds: Int = 5&#10;)&#10;&#10;data class GameCreationResponse(&#10;    val success: Boolean,&#10;    val data: GameCreationData&#10;)&#10;&#10;data class GameCreationData(&#10;    val gameId: String,&#10;    val locations: List&lt;BackendLocation&gt;,&#10;    val settings: GameSettings,&#10;    val createdAt: String&#10;)&#10;&#10;data class GameSettings(&#10;    val difficulty: Int,&#10;    val category: String,&#10;    val rounds: Int&#10;)&#10;&#10;data class GameResultSubmissionRequest(&#10;    val totalScore: Int,&#10;    val totalDistance: Double,&#10;    val accuracy: Double,&#10;    val timeTaken: Long,&#10;    val roundsData: List&lt;RoundData&gt;&#10;)&#10;&#10;data class RoundData(&#10;    val locationId: String,&#10;    val guessLatitude: Double,&#10;    val guessLongitude: Double,&#10;    val actualLatitude: Double,&#10;    val actualLongitude: Double,&#10;    val distance: Double,&#10;    val score: Int,&#10;    val timeSpent: Long&#10;)&#10;&#10;data class GameResultResponse(&#10;    val success: Boolean,&#10;    val data: GameResultData&#10;)&#10;&#10;data class GameResultData(&#10;    val resultId: String,&#10;    val gameId: String,&#10;    val totalScore: Int,&#10;    val submittedAt: String&#10;)&#10;&#10;// Stats Models&#10;data class LocationStatsResponse(&#10;    val success: Boolean,&#10;    val data: StatsData&#10;)&#10;&#10;data class StatsData(&#10;    val stats: LocationStats&#10;)&#10;&#10;data class LocationStats(&#10;    val total: Int,&#10;    val difficulties: Map&lt;String, Int&gt;,&#10;    val categories: Map&lt;String, Int&gt;&#10;)&#10;&#10;// Health Models&#10;data class HealthResponse(&#10;    val status: String,&#10;    val timestamp: String,&#10;    val uptime: Long,&#10;    val database: String&#10;)&#10;" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.network&#10;&#10;import retrofit2.Response&#10;import retrofit2.http.*&#10;&#10;interface ApiService {&#10;&#10;    // Authentication Endpoints&#10;    @POST(&quot;auth/register&quot;)&#10;    suspend fun register(&#10;        @Body request: RegisterRequest&#10;    ): Response&lt;AuthResponse&gt;&#10;&#10;    @POST(&quot;auth/login&quot;)&#10;    suspend fun login(&#10;        @Body request: LoginRequest&#10;    ): Response&lt;AuthResponse&gt;&#10;&#10;    @POST(&quot;auth/refresh&quot;)&#10;    suspend fun refreshToken(): Response&lt;TokenResponse&gt;&#10;&#10;    @POST(&quot;auth/logout&quot;)&#10;    suspend fun logout(): Response&lt;MessageResponse&gt;&#10;&#10;    // Location Endpoints&#10;    @GET(&quot;locations/random&quot;)&#10;    suspend fun getRandomLocations(&#10;        @Query(&quot;count&quot;) count: Int = 5,&#10;        @Query(&quot;difficulty&quot;) difficulty: Int? = null,&#10;        @Query(&quot;category&quot;) category: String? = null&#10;    ): Response&lt;LocationsResponse&gt;&#10;&#10;    @GET(&quot;locations/{id}&quot;)&#10;    suspend fun getLocationById(&#10;        @Path(&quot;id&quot;) locationId: Int&#10;    ): Response&lt;LocationResponse&gt;&#10;&#10;    @GET(&quot;locations/{id}/streetview&quot;)&#10;    suspend fun getStreetView(&#10;        @Path(&quot;id&quot;) locationId: Int,&#10;        @Query(&quot;heading&quot;) heading: Int? = null,&#10;        @Query(&quot;multiple&quot;) multiple: Boolean = false,&#10;        @Query(&quot;responsive&quot;) responsive: Boolean = false&#10;    ): Response&lt;StreetViewResponse&gt;&#10;&#10;    @GET(&quot;locations/stats/overview&quot;)&#10;    suspend fun getLocationStats(): Response&lt;StatsResponse&gt;&#10;&#10;    // Game Endpoints&#10;    @POST(&quot;games/single&quot;)&#10;    suspend fun createSinglePlayerGame(&#10;        @Body request: GameCreateRequest&#10;    ): Response&lt;GameCreateResponse&gt;&#10;&#10;    @PUT(&quot;games/{gameId}/result&quot;)&#10;    suspend fun submitGameResult(&#10;        @Path(&quot;gameId&quot;) gameId: Int,&#10;        @Body request: GameResultRequest&#10;    ): Response&lt;GameResultResponse&gt;&#10;&#10;    // Health Check&#10;    @GET(&quot;health&quot;)&#10;    suspend fun getHealth(): Response&lt;HealthResponse&gt;&#10;}&#10;&#10;// Auth Models&#10;data class LoginRequest(&#10;    val usernameOrEmail: String,&#10;    val password: String&#10;)&#10;&#10;data class RegisterRequest(&#10;    val username: String,&#10;    val email: String,&#10;    val password: String&#10;)&#10;&#10;data class AuthResponse(&#10;    val success: Boolean,&#10;    val data: AuthData&#10;)&#10;&#10;data class AuthData(&#10;    val user: BackendUser,&#10;    val token: String,&#10;    val expiresIn: String = &quot;7d&quot;&#10;)&#10;&#10;data class BackendUser(&#10;    val id: Int,&#10;    val username: String,&#10;    val email: String,&#10;    val totalScore: Int = 0,&#10;    val gamesPlayed: Int = 0,&#10;    val bestScore: Int = 0&#10;)&#10;&#10;data class TokenResponse(&#10;    val success: Boolean,&#10;    val data: TokenData&#10;)&#10;&#10;data class TokenData(&#10;    val token: String,&#10;    val expiresIn: String&#10;)&#10;&#10;data class MessageResponse(&#10;    val success: Boolean,&#10;    val message: String&#10;)&#10;&#10;// Location Models&#10;data class LocationsResponse(&#10;    val success: Boolean,&#10;    val data: LocationsData&#10;)&#10;&#10;data class LocationsData(&#10;    val count: Int,&#10;    val locations: List&lt;BackendLocation&gt;&#10;)&#10;&#10;data class LocationResponse(&#10;    val success: Boolean,&#10;    val data: LocationDetailData&#10;)&#10;&#10;data class LocationDetailData(&#10;    val location: BackendLocation&#10;)&#10;&#10;data class BackendLocation(&#10;    val id: Int,&#10;    val name: String? = null,&#10;    val country: String,&#10;    val city: String,&#10;    val coordinates: Coordinates,&#10;    val difficulty: Int,&#10;    val difficultyName: String,&#10;    val category: String,&#10;    val imageUrls: List&lt;String&gt; = emptyList(),&#10;    val hints: Map&lt;String, Any&gt; = emptyMap(),&#10;    val viewCount: Int = 0&#10;)&#10;&#10;data class Coordinates(&#10;    val latitude: Double,&#10;    val longitude: Double&#10;)&#10;&#10;data class StreetViewResponse(&#10;    val success: Boolean,&#10;    val data: StreetViewData&#10;)&#10;&#10;data class StreetViewData(&#10;    val location: StreetViewLocation,&#10;    val streetViewUrl: String? = null,&#10;    val streetViewUrls: Any? = null // Kann Map oder Array sein je nach responsive Parameter&#10;)&#10;&#10;data class StreetViewLocation(&#10;    val id: Int,&#10;    val coordinates: Coordinates&#10;)&#10;&#10;// Game Models&#10;data class GameCreateRequest(&#10;    val difficulty: Int = 2,&#10;    val category: String = &quot;urban&quot;,&#10;    val rounds: Int = 5&#10;)&#10;&#10;data class GameCreateResponse(&#10;    val success: Boolean,&#10;    val data: GameCreateData&#10;)&#10;&#10;data class GameCreateData(&#10;    val gameId: Int,&#10;    val locations: List&lt;BackendLocation&gt;,&#10;    val settings: GameSettings,&#10;    val createdAt: String&#10;)&#10;&#10;data class GameSettings(&#10;    val difficulty: Int,&#10;    val category: String,&#10;    val rounds: Int&#10;)&#10;&#10;data class GameResultRequest(&#10;    val totalScore: Int,&#10;    val totalDistance: Double,&#10;    val accuracy: Double,&#10;    val timeTaken: Long,&#10;    val roundsData: List&lt;RoundData&gt;&#10;)&#10;&#10;data class RoundData(&#10;    val locationId: Int,&#10;    val guessLatitude: Double,&#10;    val guessLongitude: Double,&#10;    val actualLatitude: Double,&#10;    val actualLongitude: Double,&#10;    val distance: Double,&#10;    val score: Int,&#10;    val timeSpent: Long&#10;)&#10;&#10;data class GameResultResponse(&#10;    val success: Boolean,&#10;    val data: GameResultData&#10;)&#10;&#10;data class GameResultData(&#10;    val resultId: Int,&#10;    val gameId: Int,&#10;    val totalScore: Int,&#10;    val submittedAt: String&#10;)&#10;&#10;// Stats Models&#10;data class StatsResponse(&#10;    val success: Boolean,&#10;    val data: StatsData&#10;)&#10;&#10;data class StatsData(&#10;    val stats: LocationStats&#10;)&#10;&#10;data class LocationStats(&#10;    val total: Int,&#10;    val difficulties: Map&lt;String, Int&gt;,&#10;    val categories: Map&lt;String, Int&gt;&#10;)&#10;&#10;// Health Models&#10;data class HealthResponse(&#10;    val status: String,&#10;    val timestamp: String,&#10;    val uptime: Long,&#10;    val database: String&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/network/AuthInterceptor.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/network/AuthInterceptor.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.network&#10;&#10;import okhttp3.Interceptor&#10;import okhttp3.Response&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class AuthInterceptor @Inject constructor(&#10;    private val tokenManager: TokenManager&#10;) : Interceptor {&#10;&#10;    private var currentToken: String? = null&#10;&#10;    override fun intercept(chain: Interceptor.Chain): Response {&#10;        val originalRequest = chain.request()&#10;        &#10;        // Hole aktuellen Token&#10;        val token = currentToken ?: tokenManager.getToken()&#10;        &#10;        // Prüfe ob dieser Request Authentication benötigt&#10;        val needsAuth = needsAuthentication(originalRequest.url.encodedPath)&#10;        &#10;        return if (token != null &amp;&amp; needsAuth) {&#10;            // Füge Authorization Header hinzu&#10;            val authenticatedRequest = originalRequest.newBuilder()&#10;                .header(&quot;Authorization&quot;, &quot;Bearer $token&quot;)&#10;                .build()&#10;            &#10;            val response = chain.proceed(authenticatedRequest)&#10;            &#10;            // Handle 401 Unauthorized&#10;            if (response.code == 401) {&#10;                response.close()&#10;                &#10;                // Versuche Token zu refreshen&#10;                val refreshToken = tokenManager.getRefreshToken()&#10;                if (refreshToken != null) {&#10;                    // Hier könnte Token Refresh Logic implementiert werden&#10;                    // Für jetzt loggen wir nur aus&#10;                    tokenManager.clearTokens()&#10;                    currentToken = null&#10;                }&#10;                &#10;                // Retry ohne Token&#10;                val retryRequest = originalRequest.newBuilder().build()&#10;                chain.proceed(retryRequest)&#10;            } else {&#10;                response&#10;            }&#10;        } else {&#10;            // Kein Token oder kein Auth benötigt&#10;            chain.proceed(originalRequest)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Prüft ob der Request Authentication benötigt&#10;     */&#10;    private fun needsAuthentication(path: String): Boolean {&#10;        return when {&#10;            path.contains(&quot;/auth/refresh&quot;) -&gt; true&#10;            path.contains(&quot;/auth/logout&quot;) -&gt; true&#10;            path.contains(&quot;/games/&quot;) -&gt; true&#10;            path.contains(&quot;/user/&quot;) -&gt; true&#10;            // Public Endpoints benötigen keine Auth&#10;            path.contains(&quot;/auth/login&quot;) -&gt; false&#10;            path.contains(&quot;/auth/register&quot;) -&gt; false&#10;            path.contains(&quot;/locations/random&quot;) -&gt; false&#10;            path.contains(&quot;/locations/&quot;) &amp;&amp; path.contains(&quot;/streetview&quot;) -&gt; false&#10;            path.contains(&quot;/health&quot;) -&gt; false&#10;            else -&gt; false&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Setzt den Auth Token für nachfolgende Requests&#10;     */&#10;    fun setAuthToken(token: String?) {&#10;        currentToken = token&#10;        if (token != null) {&#10;            tokenManager.saveToken(token)&#10;        } else {&#10;            tokenManager.clearTokens()&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Gibt den aktuellen Token zurück&#10;     */&#10;    fun getCurrentToken(): String? {&#10;        return currentToken ?: tokenManager.getToken()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/network/LocationResponse.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/network/LocationResponse.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.network&#10;&#10;data class LocationResponse(&#10;    val id: String,&#10;    val latitude: Double,&#10;    val longitude: Double,&#10;    val imageUrl: String,&#10;    val country: String? = null,&#10;    val city: String? = null,&#10;    val difficulty: Int = 1&#10;)&#10;&#10;data class LocationsResponse(&#10;    val locations: List&lt;LocationResponse&gt;,&#10;    val total: Int = 0,&#10;    val page: Int = 1,&#10;    val limit: Int = 10&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/network/MapillaryApiService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/network/MapillaryApiService.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.network&#10;&#10;import retrofit2.Response&#10;import retrofit2.http.GET&#10;import retrofit2.http.Query&#10;import retrofit2.http.Path&#10;&#10;interface MapillaryApiService {&#10;&#10;    /**&#10;     * Sucht 360° Panorama-Bilder in der Nähe einer Koordinate&#10;     */&#10;    @GET(&quot;images&quot;)&#10;    suspend fun getImagesNearby(&#10;        @Query(&quot;bbox&quot;) bbox: String, // Format: &quot;lng1,lat1,lng2,lat2&quot;&#10;        @Query(&quot;is_pano&quot;) isPano: Boolean = true, // Nur 360° Panoramen&#10;        @Query(&quot;limit&quot;) limit: Int = 10,&#10;        @Query(&quot;access_token&quot;) accessToken: String&#10;    ): Response&lt;MapillaryImagesResponse&gt;&#10;&#10;    /**&#10;     * Holt ein spezifisches Bild mit Download-URL&#10;     */&#10;    @GET(&quot;images/{image_id}&quot;)&#10;    suspend fun getImageDetails(&#10;        @Path(&quot;image_id&quot;) imageId: String,&#10;        @Query(&quot;access_token&quot;) accessToken: String&#10;    ): Response&lt;MapillaryImageDetails&gt;&#10;}&#10;&#10;data class MapillaryImagesResponse(&#10;    val data: List&lt;MapillaryImage&gt;,&#10;    val links: MapillaryLinks? = null&#10;)&#10;&#10;data class MapillaryImage(&#10;    val id: String,&#10;    val geometry: MapillaryGeometry,&#10;    val is_pano: Boolean,&#10;    val captured_at: String,&#10;    val compass_angle: Double? = null,&#10;    val thumb_256_url: String? = null,&#10;    val thumb_1024_url: String? = null,&#10;    val thumb_2048_url: String? = null&#10;)&#10;&#10;data class MapillaryImageDetails(&#10;    val id: String,&#10;    val geometry: MapillaryGeometry,&#10;    val is_pano: Boolean,&#10;    val captured_at: String,&#10;    val compass_angle: Double? = null,&#10;    val thumb_256_url: String? = null,&#10;    val thumb_1024_url: String? = null,&#10;    val thumb_2048_url: String? = null,&#10;    val width: Int? = null,&#10;    val height: Int? = null&#10;)&#10;&#10;data class MapillaryGeometry(&#10;    val type: String = &quot;Point&quot;,&#10;    val coordinates: List&lt;Double&gt; // [lng, lat]&#10;)&#10;&#10;data class MapillaryLinks(&#10;    val prev: String? = null,&#10;    val next: String? = null&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/network/NetworkConfig.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/network/NetworkConfig.kt" />
              <option name="originalContent" value="package com.example.geogeusserclone.data.network&#10;&#10;import com.example.geogeusserclone.BuildConfig&#10;&#10;object NetworkConfig {&#10;    // Android Emulator&#10;    const val EMULATOR_BASE_URL = &quot;http://10.0.2.2:3000/api/&quot;&#10;&#10;    // Lokales Netzwerk (IP-Adresse anpassen)&#10;    const val LOCAL_BASE_URL = &quot;http://192.168.1.100:3000/api/&quot;&#10;&#10;    // Production (falls vorhanden)&#10;    const val PROD_BASE_URL = &quot;https://your-domain.com/api/&quot;&#10;&#10;    val BASE_URL = if (BuildConfig.DEBUG) {&#10;        EMULATOR_BASE_URL // Für Android Emulator&#10;        // LOCAL_BASE_URL // Uncomment für echtes Gerät&#10;    } else {&#10;        PROD_BASE_URL&#10;    }&#10;&#10;    // Timeout-Konfiguration&#10;    const val CONNECT_TIMEOUT = 30L&#10;    const val READ_TIMEOUT = 30L&#10;    const val WRITE_TIMEOUT = 30L&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.network&#10;&#10;object NetworkConfig {&#10;    // Android Emulator&#10;    const val EMULATOR_BASE_URL = &quot;http://10.0.2.2:3000/api/&quot;&#10;&#10;    // Lokales Netzwerk (IP-Adresse anpassen)&#10;    const val LOCAL_BASE_URL = &quot;http://192.168.1.100:3000/api/&quot;&#10;&#10;    // Production (falls vorhanden)&#10;    const val PROD_BASE_URL = &quot;https://your-domain.com/api/&quot;&#10;&#10;    val BASE_URL = EMULATOR_BASE_URL // Verwende Emulator URL direkt&#10;&#10;    // Timeout-Konfiguration&#10;    const val CONNECT_TIMEOUT = 30L&#10;    const val READ_TIMEOUT = 30L&#10;    const val WRITE_TIMEOUT = 30L&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/network/NetworkResult.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/network/NetworkResult.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.network&#10;&#10;sealed class NetworkResult&lt;T&gt; {&#10;    data class Success&lt;T&gt;(val data: T) : NetworkResult&lt;T&gt;()&#10;    data class Error&lt;T&gt;(val message: String, val code: Int? = null) : NetworkResult&lt;T&gt;()&#10;    data class Exception&lt;T&gt;(val e: Throwable) : NetworkResult&lt;T&gt;()&#10;    class Loading&lt;T&gt; : NetworkResult&lt;T&gt;()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/network/TokenManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/network/TokenManager.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.network&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class TokenManager @Inject constructor(&#10;    @ApplicationContext private val context: Context&#10;) {&#10;    private val prefs: SharedPreferences = context.getSharedPreferences(&#10;        &quot;auth_prefs&quot;, &#10;        Context.MODE_PRIVATE&#10;    )&#10;&#10;    companion object {&#10;        private const val KEY_TOKEN = &quot;auth_token&quot;&#10;        private const val KEY_REFRESH_TOKEN = &quot;refresh_token&quot;&#10;        private const val KEY_TOKEN_EXPIRY = &quot;token_expiry&quot;&#10;    }&#10;&#10;    fun saveToken(token: String, expiresIn: String = &quot;7d&quot;) {&#10;        prefs.edit()&#10;            .putString(KEY_TOKEN, token)&#10;            .putLong(KEY_TOKEN_EXPIRY, calculateExpiryTime(expiresIn))&#10;            .apply()&#10;    }&#10;&#10;    fun getToken(): String? {&#10;        val token = prefs.getString(KEY_TOKEN, null)&#10;        val expiry = prefs.getLong(KEY_TOKEN_EXPIRY, 0)&#10;        &#10;        return if (token != null &amp;&amp; System.currentTimeMillis() &lt; expiry) {&#10;            token&#10;        } else {&#10;            null&#10;        }&#10;    }&#10;&#10;    fun saveRefreshToken(refreshToken: String) {&#10;        prefs.edit()&#10;            .putString(KEY_REFRESH_TOKEN, refreshToken)&#10;            .apply()&#10;    }&#10;&#10;    fun getRefreshToken(): String? {&#10;        return prefs.getString(KEY_REFRESH_TOKEN, null)&#10;    }&#10;&#10;    fun clearTokens() {&#10;        prefs.edit()&#10;            .remove(KEY_TOKEN)&#10;            .remove(KEY_REFRESH_TOKEN)&#10;            .remove(KEY_TOKEN_EXPIRY)&#10;            .apply()&#10;    }&#10;&#10;    fun isTokenValid(): Boolean {&#10;        val expiry = prefs.getLong(KEY_TOKEN_EXPIRY, 0)&#10;        return System.currentTimeMillis() &lt; expiry&#10;    }&#10;&#10;    private fun calculateExpiryTime(expiresIn: String): Long {&#10;        val currentTime = System.currentTimeMillis()&#10;        return when {&#10;            expiresIn.endsWith(&quot;d&quot;) -&gt; {&#10;                val days = expiresIn.removeSuffix(&quot;d&quot;).toLongOrNull() ?: 7&#10;                currentTime + (days * 24 * 60 * 60 * 1000)&#10;            }&#10;            expiresIn.endsWith(&quot;h&quot;) -&gt; {&#10;                val hours = expiresIn.removeSuffix(&quot;h&quot;).toLongOrNull() ?: 24&#10;                currentTime + (hours * 60 * 60 * 1000)&#10;            }&#10;            expiresIn.endsWith(&quot;m&quot;) -&gt; {&#10;                val minutes = expiresIn.removeSuffix(&quot;m&quot;).toLongOrNull() ?: 60&#10;                currentTime + (minutes * 60 * 1000)&#10;            }&#10;            else -&gt; {&#10;                // Default: 7 Tage&#10;                currentTime + (7 * 24 * 60 * 60 * 1000)&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/repositories/BaseRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/repositories/BaseRepository.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.repositories&#10;&#10;abstract class BaseRepository {&#10;    &#10;    protected suspend fun &lt;T&gt; safeApiCall(&#10;        apiCall: suspend () -&gt; T&#10;    ): Result&lt;T&gt; {&#10;        return try {&#10;            Result.success(apiCall())&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;    &#10;    protected fun &lt;T&gt; handleApiResponse(&#10;        response: retrofit2.Response&lt;T&gt;&#10;    ): Result&lt;T&gt; {&#10;        return if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;            Result.success(response.body()!!)&#10;        } else {&#10;            Result.failure(Exception(&quot;API Error: ${response.code()} ${response.message()}&quot;))&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/repositories/GameRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/repositories/GameRepository.kt" />
              <option name="originalContent" value="package com.example.geogeusserclone.data.repositories&#10;&#10;import com.example.geogeusserclone.data.database.dao.GameDao&#10;import com.example.geogeusserclone.data.database.dao.GuessDao&#10;import com.example.geogeusserclone.data.database.entities.GameEntity&#10;import com.example.geogeusserclone.data.database.entities.GuessEntity&#10;import com.example.geogeusserclone.data.network.ApiService&#10;import com.example.geogeusserclone.data.network.CreateGameRequest&#10;import com.example.geogeusserclone.data.network.CreateSinglePlayerGameRequest&#10;import com.example.geogeusserclone.data.network.GuessRequest&#10;import com.example.geogeusserclone.data.network.GameResultRequest&#10;import com.example.geogeusserclone.data.network.GuessResultData&#10;import com.example.geogeusserclone.data.network.GameResultResponse&#10;import com.example.geogeusserclone.utils.DistanceCalculator&#10;import com.example.geogeusserclone.utils.ScoreCalculator&#10;import kotlinx.coroutines.flow.Flow&#10;import java.util.UUID&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class GameRepository @Inject constructor(&#10;    private val apiService: ApiService,&#10;    private val gameDao: GameDao,&#10;    private val guessDao: GuessDao,&#10;    private val userRepository: UserRepository&#10;) : BaseRepository() {&#10;&#10;    suspend fun createGame(&#10;        userId: String,&#10;        gameMode: String = &quot;single&quot;,&#10;        rounds: Int = 5&#10;    ): Result&lt;GameEntity&gt; {&#10;        return try {&#10;            // Verwende neuen Single Player Endpoint&#10;            val response = apiService.createSinglePlayerGame(&#10;                CreateSingleGameRequest(&#10;                    difficulty = 2,&#10;                    category = &quot;urban&quot;,&#10;                    rounds = rounds&#10;                )&#10;            )&#10;&#10;            if (response.isSuccessful) {&#10;                val gameResponse = response.body()!!&#10;                if (gameResponse.success) {&#10;                    val gameEntity = GameEntity(&#10;                        id = gameResponse.data.gameId,&#10;                        userId = userId,&#10;                        gameMode = gameMode,&#10;                        totalRounds = rounds,&#10;                        currentRound = 1,&#10;                        score = 0,&#10;                        isCompleted = false,&#10;                        createdAt = System.currentTimeMillis(),&#10;                        startedAt = System.currentTimeMillis()&#10;                    )&#10;                    gameDao.insertGame(gameEntity)&#10;&#10;                    // Speichere die Locations aus dem Backend&#10;                    val locationEntities = gameResponse.data.locations.map { backendLocation -&gt;&#10;                        LocationEntity(&#10;                            id = backendLocation.id,&#10;                            latitude = backendLocation.coordinates.latitude,&#10;                            longitude = backendLocation.coordinates.longitude,&#10;                            imageUrl = backendLocation.imageUrls.firstOrNull() ?: &quot;&quot;,&#10;                            country = backendLocation.country,&#10;                            city = backendLocation.city,&#10;                            difficulty = backendLocation.difficulty,&#10;                            isCached = true,&#10;                            isUsed = false&#10;                        )&#10;                    }&#10;                    locationDao.insertLocations(locationEntities)&#10;&#10;                    return Result.success(gameEntity)&#10;                }&#10;            }&#10;            // Fallback für Offline-Modus&#10;            createOfflineGame(userId, gameMode, rounds)&#10;        } catch (e: Exception) {&#10;            // Fallback für Offline-Modus&#10;            createOfflineGame(userId, gameMode, rounds)&#10;        }&#10;    }&#10;&#10;    private suspend fun createOfflineGame(&#10;        userId: String,&#10;        gameMode: String,&#10;        rounds: Int&#10;    ): Result&lt;GameEntity&gt; {&#10;        val gameEntity = GameEntity(&#10;            id = UUID.randomUUID().toString(),&#10;            userId = userId,&#10;            gameMode = gameMode,&#10;            totalRounds = rounds,&#10;            currentRound = 1,&#10;            score = 0,&#10;            isCompleted = false,&#10;            createdAt = System.currentTimeMillis(),&#10;            startedAt = System.currentTimeMillis()&#10;        )&#10;        gameDao.insertGame(gameEntity)&#10;        return Result.success(gameEntity)&#10;    }&#10;&#10;    suspend fun submitGuess(&#10;        gameId: String,&#10;        locationId: String,&#10;        guessLat: Double,&#10;        guessLng: Double,&#10;        actualLat: Double,&#10;        actualLng: Double,&#10;        timeSpent: Long&#10;    ): Result&lt;GuessEntity&gt; {&#10;        return try {&#10;            // Berechne Score und Distanz lokal&#10;            val distance = DistanceCalculator.calculateDistance(&#10;                guessLat, guessLng, actualLat, actualLng&#10;            )&#10;            val score = ScoreCalculator.calculateScore(distance, timeSpent)&#10;&#10;            val guessEntity = GuessEntity(&#10;                id = UUID.randomUUID().toString(),&#10;                gameId = gameId,&#10;                locationId = locationId,&#10;                guessLat = guessLat,&#10;                guessLng = guessLng,&#10;                actualLat = actualLat,&#10;                actualLng = actualLng,&#10;                distance = distance,&#10;                score = score,&#10;                timeSpent = timeSpent,&#10;                submittedAt = System.currentTimeMillis()&#10;            )&#10;&#10;            // Speichere Guess lokal&#10;            guessDao.insertGuess(guessEntity)&#10;&#10;            // Update Game Score&#10;            val currentGame = gameDao.getGameById(gameId)&#10;            if (currentGame != null) {&#10;                val updatedGame = currentGame.copy(&#10;                    score = currentGame.score + score,&#10;                    currentRound = currentGame.currentRound + 1&#10;                )&#10;                gameDao.updateGame(updatedGame)&#10;            }&#10;&#10;            // Versuche online zu synchronisieren - remove this part that causes error&#10;            // The backend doesn't have this endpoint, so we skip it&#10;&#10;            Result.success(guessEntity)&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    suspend fun completeGame(gameId: String): Result&lt;GameEntity&gt; {&#10;        return try {&#10;            val game = gameDao.getGameById(gameId)&#10;            if (game != null) {&#10;                val completedGame = game.copy(&#10;                    isCompleted = true,&#10;                    completedAt = System.currentTimeMillis(),&#10;                    duration = System.currentTimeMillis() - (game.startedAt ?: game.createdAt)&#10;                )&#10;                gameDao.updateGame(completedGame)&#10;&#10;                // Update User Stats&#10;                userRepository.updateUserStats(&#10;                    totalScore = completedGame.score,&#10;                    gamesPlayed = 1,&#10;                    bestScore = completedGame.score&#10;                )&#10;&#10;                Result.success(completedGame)&#10;            } else {&#10;                Result.failure(Exception(&quot;Spiel nicht gefunden&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    // Neue Methode für komplettes Spiel-Ergebnis&#10;    suspend fun submitCompleteGameResult(&#10;        game: GameEntity,&#10;        guesses: List&lt;GuessEntity&gt;&#10;    ): Result&lt;GameResultResponse&gt; {&#10;        return try {&#10;            val gameResultRequest = GameResultSubmissionRequest(&#10;                totalScore = game.score,&#10;                totalDistance = guesses.sumOf { it.distance },&#10;                accuracy = calculateAccuracy(guesses),&#10;                timeTaken = game.duration ?: 0L,&#10;                roundsData = guesses.map { guess -&gt;&#10;                    RoundData(&#10;                        locationId = guess.locationId,&#10;                        guessLatitude = guess.guessLat,&#10;                        guessLongitude = guess.guessLng,&#10;                        actualLatitude = guess.actualLat,&#10;                        actualLongitude = guess.actualLng,&#10;                        distance = guess.distance,&#10;                        score = guess.score,&#10;                        timeSpent = guess.timeSpent&#10;                    )&#10;                }&#10;            )&#10;&#10;            val response = apiService.submitGameResult(game.id, gameResultRequest)&#10;&#10;            if (response.isSuccessful) {&#10;                val result = response.body()!!&#10;                Result.success(result)&#10;            } else {&#10;                Result.failure(Exception(&quot;Fehler beim Übermitteln des Spielergebnisses&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            // Silent fail - Spiel ist lokal gespeichert&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    private fun calculateAccuracy(guesses: List&lt;GuessEntity&gt;): Double {&#10;        if (guesses.isEmpty()) return 0.0&#10;&#10;        val averageDistance = guesses.sumOf { it.distance } / guesses.size&#10;        return when {&#10;            averageDistance &lt;= 1.0 -&gt; 100.0&#10;            averageDistance &lt;= 10.0 -&gt; 90.0&#10;            averageDistance &lt;= 50.0 -&gt; 80.0&#10;            averageDistance &lt;= 200.0 -&gt; 70.0&#10;            averageDistance &lt;= 1000.0 -&gt; 50.0&#10;            else -&gt; 20.0&#10;        }&#10;    }&#10;&#10;    fun getGameHistory(userId: String): Flow&lt;List&lt;GameEntity&gt;&gt; {&#10;        return gameDao.getGamesByUser(userId)&#10;    }&#10;&#10;    fun getGuessesByGame(gameId: String): Flow&lt;List&lt;GuessEntity&gt;&gt; {&#10;        return guessDao.getGuessesByGame(gameId)&#10;    }&#10;&#10;    suspend fun getCurrentGame(userId: String): GameEntity? {&#10;        return gameDao.getCurrentGameForUser(userId)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.repositories&#10;&#10;import com.example.geogeusserclone.data.database.dao.GameDao&#10;import com.example.geogeusserclone.data.database.dao.GuessDao&#10;import com.example.geogeusserclone.data.database.dao.LocationDao&#10;import com.example.geogeusserclone.data.database.entities.GameEntity&#10;import com.example.geogeusserclone.data.database.entities.GuessEntity&#10;import com.example.geogeusserclone.data.database.entities.LocationEntity&#10;import com.example.geogeusserclone.data.network.*&#10;import com.example.geogeusserclone.utils.DistanceCalculator&#10;import com.example.geogeusserclone.utils.ScoreCalculator&#10;import kotlinx.coroutines.flow.Flow&#10;import java.util.UUID&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class GameRepository @Inject constructor(&#10;    private val apiService: ApiService,&#10;    private val gameDao: GameDao,&#10;    private val guessDao: GuessDao,&#10;    private val locationDao: LocationDao,&#10;    private val userRepository: UserRepository&#10;) : BaseRepository() {&#10;&#10;    suspend fun createGame(&#10;        userId: String,&#10;        gameMode: String = &quot;single&quot;,&#10;        rounds: Int = 5&#10;    ): Result&lt;GameEntity&gt; {&#10;        return try {&#10;            // Verwende Backend API&#10;            val response = apiService.createSinglePlayerGame(&#10;                GameCreateRequest(&#10;                    difficulty = 2,&#10;                    category = &quot;urban&quot;,&#10;                    rounds = rounds&#10;                )&#10;            )&#10;&#10;            if (response.isSuccessful) {&#10;                val gameResponse = response.body()!!&#10;                if (gameResponse.success) {&#10;                    val gameEntity = GameEntity(&#10;                        id = gameResponse.data.gameId.toString(), // Convert Int to String&#10;                        userId = userId,&#10;                        gameMode = gameMode,&#10;                        totalRounds = rounds,&#10;                        currentRound = 1,&#10;                        score = 0,&#10;                        isCompleted = false,&#10;                        createdAt = System.currentTimeMillis(),&#10;                        startedAt = System.currentTimeMillis()&#10;                    )&#10;                    gameDao.insertGame(gameEntity)&#10;&#10;                    // Speichere die Locations aus dem Backend&#10;                    val locationEntities = gameResponse.data.locations.map { backendLocation -&gt;&#10;                        LocationEntity(&#10;                            id = backendLocation.id.toString(), // Convert Int to String&#10;                            latitude = backendLocation.coordinates.latitude,&#10;                            longitude = backendLocation.coordinates.longitude,&#10;                            imageUrl = backendLocation.imageUrls.firstOrNull() ?: &quot;&quot;,&#10;                            country = backendLocation.country,&#10;                            city = backendLocation.city,&#10;                            difficulty = backendLocation.difficulty,&#10;                            isCached = true,&#10;                            isUsed = false&#10;                        )&#10;                    }&#10;                    locationDao.insertLocations(locationEntities)&#10;&#10;                    return Result.success(gameEntity)&#10;                }&#10;            }&#10;            // Fallback für Offline-Modus&#10;            createOfflineGame(userId, gameMode, rounds)&#10;        } catch (e: Exception) {&#10;            // Fallback für Offline-Modus&#10;            createOfflineGame(userId, gameMode, rounds)&#10;        }&#10;    }&#10;&#10;    private suspend fun createOfflineGame(&#10;        userId: String,&#10;        gameMode: String,&#10;        rounds: Int&#10;    ): Result&lt;GameEntity&gt; {&#10;        val gameEntity = GameEntity(&#10;            id = UUID.randomUUID().toString(),&#10;            userId = userId,&#10;            gameMode = gameMode,&#10;            totalRounds = rounds,&#10;            currentRound = 1,&#10;            score = 0,&#10;            isCompleted = false,&#10;            createdAt = System.currentTimeMillis(),&#10;            startedAt = System.currentTimeMillis()&#10;        )&#10;        gameDao.insertGame(gameEntity)&#10;        return Result.success(gameEntity)&#10;    }&#10;&#10;    suspend fun submitGuess(&#10;        gameId: String,&#10;        locationId: String,&#10;        guessLat: Double,&#10;        guessLng: Double,&#10;        actualLat: Double,&#10;        actualLng: Double,&#10;        timeSpent: Long&#10;    ): Result&lt;GuessEntity&gt; {&#10;        return try {&#10;            // Berechne Score und Distanz lokal&#10;            val distance = DistanceCalculator.calculateDistance(&#10;                guessLat, guessLng, actualLat, actualLng&#10;            )&#10;            val score = ScoreCalculator.calculateScore(distance, timeSpent)&#10;&#10;            val guessEntity = GuessEntity(&#10;                id = UUID.randomUUID().toString(),&#10;                gameId = gameId,&#10;                locationId = locationId,&#10;                guessLat = guessLat,&#10;                guessLng = guessLng,&#10;                actualLat = actualLat,&#10;                actualLng = actualLng,&#10;                distance = distance,&#10;                score = score,&#10;                timeSpent = timeSpent,&#10;                submittedAt = System.currentTimeMillis()&#10;            )&#10;&#10;            // Speichere Guess lokal&#10;            guessDao.insertGuess(guessEntity)&#10;&#10;            // Update Game Score&#10;            val currentGame = gameDao.getGameById(gameId)&#10;            if (currentGame != null) {&#10;                val updatedGame = currentGame.copy(&#10;                    score = currentGame.score + score,&#10;                    currentRound = currentGame.currentRound + 1&#10;                )&#10;                gameDao.updateGame(updatedGame)&#10;            }&#10;&#10;            // Versuche online zu synchronisieren - remove this part that causes error&#10;            // The backend doesn't have this endpoint, so we skip it&#10;&#10;            Result.success(guessEntity)&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    suspend fun completeGame(gameId: String): Result&lt;GameEntity&gt; {&#10;        return try {&#10;            val game = gameDao.getGameById(gameId)&#10;            if (game != null) {&#10;                val completedGame = game.copy(&#10;                    isCompleted = true,&#10;                    completedAt = System.currentTimeMillis(),&#10;                    duration = System.currentTimeMillis() - (game.startedAt ?: game.createdAt)&#10;                )&#10;                gameDao.updateGame(completedGame)&#10;&#10;                // Update User Stats&#10;                userRepository.updateUserStats(&#10;                    totalScore = completedGame.score,&#10;                    gamesPlayed = 1,&#10;                    bestScore = completedGame.score&#10;                )&#10;&#10;                Result.success(completedGame)&#10;            } else {&#10;                Result.failure(Exception(&quot;Spiel nicht gefunden&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    // Neue Methode für komplettes Spiel-Ergebnis&#10;    suspend fun submitCompleteGameResult(&#10;        game: GameEntity,&#10;        guesses: List&lt;GuessEntity&gt;&#10;    ): Result&lt;GameResultResponse&gt; {&#10;        return try {&#10;            val gameResultRequest = GameResultRequest(&#10;                totalScore = game.score,&#10;                totalDistance = guesses.sumOf { it.distance },&#10;                accuracy = calculateAccuracy(guesses),&#10;                timeTaken = game.duration ?: 0L,&#10;                roundsData = guesses.map { guess -&gt;&#10;                    RoundData(&#10;                        locationId = guess.locationId.toInt(), // Convert String to Int&#10;                        guessLatitude = guess.guessLat,&#10;                        guessLongitude = guess.guessLng,&#10;                        actualLatitude = guess.actualLat,&#10;                        actualLongitude = guess.actualLng,&#10;                        distance = guess.distance,&#10;                        score = guess.score,&#10;                        timeSpent = guess.timeSpent&#10;                    )&#10;                }&#10;            )&#10;&#10;            val response = apiService.submitGameResult(game.id.toInt(), gameResultRequest)&#10;&#10;            if (response.isSuccessful) {&#10;                val result = response.body()!!&#10;                Result.success(result)&#10;            } else {&#10;                Result.failure(Exception(&quot;Fehler beim Übermitteln des Spielergebnisses&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            // Silent fail - Spiel ist lokal gespeichert&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    private fun calculateAccuracy(guesses: List&lt;GuessEntity&gt;): Double {&#10;        if (guesses.isEmpty()) return 0.0&#10;&#10;        val averageDistance = guesses.sumOf { it.distance } / guesses.size&#10;        return when {&#10;            averageDistance &lt;= 1.0 -&gt; 100.0&#10;            averageDistance &lt;= 10.0 -&gt; 90.0&#10;            averageDistance &lt;= 50.0 -&gt; 80.0&#10;            averageDistance &lt;= 200.0 -&gt; 70.0&#10;            averageDistance &lt;= 1000.0 -&gt; 50.0&#10;            else -&gt; 20.0&#10;        }&#10;    }&#10;&#10;    fun getGameHistory(userId: String): Flow&lt;List&lt;GameEntity&gt;&gt; {&#10;        return gameDao.getGamesByUser(userId)&#10;    }&#10;&#10;    fun getGuessesByGame(gameId: String): Flow&lt;List&lt;GuessEntity&gt;&gt; {&#10;        return guessDao.getGuessesByGame(gameId)&#10;    }&#10;&#10;    suspend fun getCurrentGame(userId: String): GameEntity? {&#10;        return gameDao.getCurrentGameForUser(userId)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/repositories/LocationCacheRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/repositories/LocationCacheRepository.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.repositories&#13;&#10;&#13;&#10;import com.example.geogeusserclone.data.database.dao.LocationDao&#13;&#10;import com.example.geogeusserclone.data.database.entities.LocationEntity&#13;&#10;import com.example.geogeusserclone.data.network.ApiService&#13;&#10;import kotlinx.coroutines.Dispatchers&#13;&#10;import kotlinx.coroutines.flow.Flow&#13;&#10;import kotlinx.coroutines.withContext&#13;&#10;import javax.inject.Inject&#13;&#10;import javax.inject.Singleton&#13;&#10;&#13;&#10;@Singleton&#13;&#10;class LocationCacheRepository @Inject constructor(&#13;&#10;    private val apiService: ApiService,&#13;&#10;    private val locationDao: LocationDao&#13;&#10;) {&#13;&#10;&#13;&#10;    suspend fun preloadLocationsInBackground() = withContext(Dispatchers.IO) {&#13;&#10;        try {&#13;&#10;            // Lade nur wenn weniger als 10 Locations im Cache&#13;&#10;            val cachedCount = locationDao.getCachedLocationCount()&#13;&#10;            if (cachedCount &lt; 10) {&#13;&#10;                val response = apiService.getRandomLocations(50)&#13;&#10;                if (response.isSuccessful) {&#13;&#10;                    val locationsResponse = response.body()!!&#13;&#10;                    val locationEntities = locationsResponse.data.locations.map { backendLocation -&gt;&#13;&#10;                        LocationEntity(&#13;&#10;                            id = backendLocation.id.toString(),&#13;&#10;                            latitude = backendLocation.coordinates.latitude,&#13;&#10;                            longitude = backendLocation.coordinates.longitude,&#13;&#10;                            imageUrl = backendLocation.imageUrls.firstOrNull() ?: &quot;&quot;,&#13;&#10;                            country = backendLocation.country,&#13;&#10;                            city = backendLocation.city,&#13;&#10;                            difficulty = backendLocation.difficulty,&#13;&#10;                            isCached = true,&#13;&#10;                            isUsed = false&#13;&#10;                        )&#13;&#10;                    }&#13;&#10;&#13;&#10;                    // Batch insert für bessere Performance&#13;&#10;                    locationDao.insertLocations(locationEntities)&#13;&#10;&#13;&#10;                    // Preload images im Hintergrund&#13;&#10;                    preloadImages(locationEntities.take(5)) // Nur erste 5 Bilder&#13;&#10;                }&#13;&#10;            }&#13;&#10;        } catch (e: Exception) {&#13;&#10;            // Silent fail - App funktioniert weiter mit Fallback Locations&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private suspend fun preloadImages(locations: List&lt;LocationEntity&gt;) = withContext(Dispatchers.IO) {&#13;&#10;        // Implementierung für Image Preloading&#13;&#10;        // Dies würde die Bilder in den Cache laden ohne sie anzuzeigen&#13;&#10;    }&#13;&#10;&#13;&#10;    suspend fun getNextLocations(count: Int = 3): List&lt;LocationEntity&gt; = withContext(Dispatchers.IO) {&#13;&#10;        locationDao.getUnusedLocations(count)&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/repositories/LocationRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/repositories/LocationRepository.kt" />
              <option name="originalContent" value="package com.example.geogeusserclone.data.repositories&#10;&#10;import com.example.geogeusserclone.data.database.dao.LocationDao&#10;import com.example.geogeusserclone.data.database.entities.LocationEntity&#10;import com.example.geogeusserclone.data.network.ApiService&#10;import com.example.geogeusserclone.data.network.MapillaryApiService&#10;import com.example.geogeusserclone.utils.Constants&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.async&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.withContext&#10;import kotlinx.coroutines.withTimeoutOrNull&#10;import java.util.*&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class LocationRepository @Inject constructor(&#10;    private val apiService: ApiService,&#10;    private val mapillaryApiService: MapillaryApiService,&#10;    private val locationDao: LocationDao&#10;) : BaseRepository() {&#10;&#10;    fun getCachedLocations(): Flow&lt;List&lt;LocationEntity&gt;&gt; = locationDao.getCachedLocations()&#10;&#10;    suspend fun getRandomLocation(): Result&lt;LocationEntity&gt; {&#10;        return try {&#10;            // 1. Versuche zuerst lokale unbenutzte Location&#10;            val unusedLocation = locationDao.getRandomUnusedLocation()&#10;            if (unusedLocation != null) {&#10;                locationDao.markLocationAsUsed(unusedLocation.id)&#10;                return Result.success(unusedLocation)&#10;            }&#10;&#10;            // 2. Versuche dein Google Maps Backend&#10;            val backendResult = getLocationFromBackend()&#10;            if (backendResult.isSuccess) {&#10;                return backendResult&#10;            }&#10;&#10;            // 3. Fallback auf Mapillary (nur wenn Backend nicht verfügbar)&#10;            val mapillaryResult = getLocationFromMapillary()&#10;            if (mapillaryResult.isSuccess) {&#10;                return mapillaryResult&#10;            }&#10;&#10;            // 4. Ultimate Fallback: Erstelle Offline-Locations&#10;            val fallbackLocations = createFallbackLocations()&#10;            locationDao.insertLocations(fallbackLocations)&#10;            val randomLocation = fallbackLocations.random()&#10;            locationDao.markLocationAsUsed(randomLocation.id)&#10;&#10;            return Result.success(randomLocation)&#10;&#10;        } catch (e: Exception) {&#10;            // Emergency Fallback&#10;            val emergencyLocation = createEmergencyLocation()&#10;            try {&#10;                locationDao.insertLocation(emergencyLocation)&#10;                locationDao.markLocationAsUsed(emergencyLocation.id)&#10;                Result.success(emergencyLocation)&#10;            } catch (dbError: Exception) {&#10;                Result.failure(Exception(&quot;Kritischer Fehler: Kann keine Location laden&quot;))&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun getLocationFromBackend(): Result&lt;LocationEntity&gt; {&#10;        return try {&#10;            val response = withTimeoutOrNull(Constants.BACKEND_FALLBACK_DELAY_MS) {&#10;                apiService.getRandomLocations(count = 1, difficulty = 2, category = &quot;urban&quot;)&#10;            }&#10;&#10;            if (response?.isSuccessful == true) {&#10;                val locationsResponse = response.body()!!&#10;                if (locationsResponse.success &amp;&amp; locationsResponse.data.locations.isNotEmpty()) {&#10;                    val backendLocation = locationsResponse.data.locations.first()&#10;&#10;                    // Hole Street View URL für diese Location&#10;                    val streetViewResult = getStreetViewForLocation(backendLocation.id)&#10;                    val streetViewUrl = streetViewResult.getOrNull() ?: backendLocation.imageUrls.firstOrNull() ?: &quot;&quot;&#10;&#10;                    val locationEntity = LocationEntity(&#10;                        id = backendLocation.id.toString(), // Convert Int to String&#10;                        latitude = backendLocation.coordinates.latitude,&#10;                        longitude = backendLocation.coordinates.longitude,&#10;                        imageUrl = streetViewUrl,&#10;                        country = backendLocation.country,&#10;                        city = backendLocation.city,&#10;                        difficulty = backendLocation.difficulty,&#10;                        isCached = true,&#10;                        isUsed = false&#10;                    )&#10;&#10;                    locationDao.insertLocation(locationEntity)&#10;                    locationDao.markLocationAsUsed(locationEntity.id)&#10;                    return Result.success(locationEntity)&#10;                }&#10;            }&#10;            Result.failure(Exception(&quot;Backend nicht verfügbar&quot;))&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    private suspend fun getStreetViewForLocation(locationId: Int): Result&lt;String&gt; {&#10;        return try {&#10;            val response = apiService.getStreetView(&#10;                locationId = locationId,&#10;                responsive = true&#10;            )&#10;&#10;            if (response.isSuccessful) {&#10;                val streetViewResponse = response.body()!!&#10;                if (streetViewResponse.success) {&#10;                    // Korrekte Verarbeitung der verschachtelten URL-Struktur&#10;                    val urlsData = streetViewResponse.data.streetViewUrls&#10;                    if (urlsData is Map&lt;*, *&gt;) {&#10;                        val url = (urlsData[&quot;mobile&quot;] as? String)&#10;                            ?: (urlsData[&quot;tablet&quot;] as? String)&#10;                            ?: (urlsData[&quot;desktop&quot;] as? String)&#10;&#10;                        if (!url.isNullOrEmpty()) {&#10;                            return Result.success(url)&#10;                        }&#10;                    }&#10;                    // Fallback auf die einzelne URL, falls das Objekt-Parsing fehlschlägt&#10;                    val singleUrl = streetViewResponse.data.streetViewUrl&#10;                    if (!singleUrl.isNullOrEmpty()) {&#10;                        Result.success(singleUrl)&#10;                    } else {&#10;                        Result.failure(Exception(&quot;Keine Street View URL in der Antwort gefunden&quot;))&#10;                    }&#10;                } else {&#10;                    Result.failure(Exception(&quot;Street View Anfrage vom Backend als fehlgeschlagen markiert&quot;))&#10;                }&#10;            } else {&#10;                Result.failure(Exception(&quot;Street View API Fehler: ${response.code()}&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    private suspend fun getLocationFromMapillary(): Result&lt;LocationEntity&gt; {&#10;        return try {&#10;            println(&quot;LocationRepository: Versuche Mapillary-Fallback...&quot;)&#10;            &#10;            // Zufällige bekannte Städte für Mapillary-Suche&#10;            val searchCities = listOf(&#10;                Pair(48.8566, 2.3522),   // Paris&#10;                Pair(51.5074, -0.1278),  // London  &#10;                Pair(40.7128, -74.0060), // New York&#10;                Pair(52.5200, 13.4050),  // Berlin&#10;                Pair(41.9028, 12.4964),  // Rom&#10;                Pair(35.6762, 139.6503)  // Tokyo&#10;            )&#10;            &#10;            val randomCity = searchCities.random()&#10;            val (lat, lng) = randomCity&#10;            &#10;            // Erstelle BoundingBox um die Stadt (ca. 10km Radius)&#10;            val latOffset = 0.1 // ca. 11km&#10;            val lngOffset = 0.1&#10;            val bbox = &quot;${lng - lngOffset},${lat - latOffset},${lng + lngOffset},${lat + latOffset}&quot;&#10;            &#10;            // Versuche Mapillary API-Call&#10;            val response = withTimeoutOrNull(8000L) {&#10;                mapillaryApiService.getImagesNearby(&#10;                    bbox = bbox,&#10;                    isPano = true, // Nur 360° Panoramen&#10;                    limit = 5,&#10;                    accessToken = Constants.MAPILLARY_ACCESS_TOKEN&#10;                )&#10;            }&#10;            &#10;            if (response?.isSuccessful == true) {&#10;                val mapillaryResponse = response.body()!!&#10;                if (mapillaryResponse.data.isNotEmpty()) {&#10;                    val mapillaryImage = mapillaryResponse.data.random()&#10;                    val coords = mapillaryImage.geometry.coordinates&#10;                    &#10;                    // Hole detailed Image info für Download-URL&#10;                    val imageDetails = getMapillaryImageDetails(mapillaryImage.id)&#10;                    val imageUrl = imageDetails.getOrNull()?.thumb_1024_url &#10;                        ?: mapillaryImage.thumb_1024_url &#10;                        ?: mapillaryImage.thumb_256_url&#10;                        ?: &quot;&quot;&#10;                    &#10;                    if (imageUrl.isNotEmpty()) {&#10;                        val locationEntity = LocationEntity(&#10;                            id = &quot;mapillary_${mapillaryImage.id}&quot;,&#10;                            latitude = coords[1], // Mapillary: [lng, lat]&#10;                            longitude = coords[0],&#10;                            imageUrl = imageUrl,&#10;                            country = getCityName(coords[1], coords[0]).first,&#10;                            city = getCityName(coords[1], coords[0]).second,&#10;                            difficulty = 3, // Mapillary-Locations sind meist schwieriger&#10;                            isCached = true,&#10;                            isUsed = false&#10;                        )&#10;                        &#10;                        locationDao.insertLocation(locationEntity)&#10;                        locationDao.markLocationAsUsed(locationEntity.id)&#10;                        &#10;                        println(&quot;LocationRepository: Mapillary-Location erfolgreich geladen: ${locationEntity.city}&quot;)&#10;                        return Result.success(locationEntity)&#10;                    }&#10;                }&#10;            }&#10;            &#10;            println(&quot;LocationRepository: Mapillary-API nicht verfügbar, verwende statische Fallbacks&quot;)&#10;            // Fallback auf statische Locations&#10;            val fallbackLocations = createFallbackLocations()&#10;            if (fallbackLocations.isNotEmpty()) {&#10;                locationDao.insertLocations(fallbackLocations)&#10;                val randomLocation = fallbackLocations.random()&#10;                locationDao.markLocationAsUsed(randomLocation.id)&#10;                println(&quot;LocationRepository: Statischer Fallback verwendet: ${randomLocation.city}&quot;)&#10;                Result.success(randomLocation)&#10;            } else {&#10;                Result.failure(Exception(&quot;Keine Fallback-Locations verfügbar&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            println(&quot;LocationRepository: Mapillary-Fehler: ${e.message}&quot;)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;    &#10;    private suspend fun getMapillaryImageDetails(imageId: String): Result&lt;MapillaryImageDetails&gt; {&#10;        return try {&#10;            val response = mapillaryApiService.getImageDetails(&#10;                imageId = imageId,&#10;                accessToken = Constants.MAPILLARY_ACCESS_TOKEN&#10;            )&#10;            &#10;            if (response.isSuccessful) {&#10;                val details = response.body()!!&#10;                Result.success(details)&#10;            } else {&#10;                Result.failure(Exception(&quot;Mapillary Image Details API Fehler: ${response.code()}&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;    &#10;    private fun getCityName(lat: Double, lng: Double): Pair&lt;String, String&gt; {&#10;        // Einfache Zuordnung basierend auf Koordinaten&#10;        return when {&#10;            lat in 48.0..49.0 &amp;&amp; lng in 2.0..3.0 -&gt; Pair(&quot;France&quot;, &quot;Paris&quot;)&#10;            lat in 51.0..52.0 &amp;&amp; lng in -1.0..0.0 -&gt; Pair(&quot;United Kingdom&quot;, &quot;London&quot;)&#10;            lat in 40.0..41.0 &amp;&amp; lng in -75.0..-73.0 -&gt; Pair(&quot;United States&quot;, &quot;New York&quot;)&#10;            lat in 52.0..53.0 &amp;&amp; lng in 13.0..14.0 -&gt; Pair(&quot;Germany&quot;, &quot;Berlin&quot;)&#10;            lat in 41.0..42.0 &amp;&amp; lng in 12.0..13.0 -&gt; Pair(&quot;Italy&quot;, &quot;Rome&quot;)&#10;            lat in 35.0..36.0 &amp;&amp; lng in 139.0..140.0 -&gt; Pair(&quot;Japan&quot;, &quot;Tokyo&quot;)&#10;            else -&gt; Pair(&quot;Unknown&quot;, &quot;Unknown City&quot;)&#10;        }&#10;    }&#10;&#10;    suspend fun preloadLocations() {&#10;        withContext(Dispatchers.IO) { // Wechsle zum IO-Dispatcher für Netzwerkoperationen&#10;            try {&#10;                val response = withTimeoutOrNull(Constants.BACKEND_FALLBACK_DELAY_MS) {&#10;                    apiService.getRandomLocations(count = 10, difficulty = 2)&#10;                }&#10;&#10;                if (response?.isSuccessful == true) {&#10;                    val locationsResponse = response.body()!!&#10;                    if (locationsResponse.success) {&#10;                        // Parallele Ausführung der StreetView-Anfragen&#10;                        val locationEntities = locationsResponse.data.locations.map { backendLocation -&gt;&#10;                            async {&#10;                                val streetViewUrl = getStreetViewForLocation(backendLocation.id).getOrNull()&#10;                                    ?: backendLocation.imageUrls.firstOrNull()&#10;                                    ?: &quot;&quot;&#10;&#10;                                if (streetViewUrl.isNotBlank()) {&#10;                                    LocationEntity(&#10;                                        id = backendLocation.id.toString(),&#10;                                        latitude = backendLocation.coordinates.latitude,&#10;                                        longitude = backendLocation.coordinates.longitude,&#10;                                        imageUrl = streetViewUrl,&#10;                                        country = backendLocation.country,&#10;                                        city = backendLocation.city,&#10;                                        difficulty = backendLocation.difficulty,&#10;                                        isCached = true,&#10;                                        isUsed = false&#10;                                    )&#10;                                } else {&#10;                                    null // Null zurückgeben, wenn keine URL gefunden wurde&#10;                                }&#10;                            }&#10;                        }.mapNotNull { it.await() } // Auf alle warten und Null-Werte entfernen&#10;&#10;                        locationDao.insertLocations(locationEntities)&#10;                        return@withContext&#10;                    }&#10;                }&#10;&#10;                // Fallback: Lade Standard-Locations, wenn das Backend nicht verfügbar ist&#10;                val fallbackLocations = createFallbackLocations()&#10;                locationDao.insertLocations(fallbackLocations)&#10;&#10;            } catch (e: Exception) {&#10;                // Stiller Fallback bei Fehlern&#10;                val fallbackLocations = createFallbackLocations()&#10;                locationDao.insertLocations(fallbackLocations)&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun createFallbackLocationsWithMapillary(): List&lt;LocationEntity&gt; {&#10;        // Vereinfachte Mapillary-Integration als Fallback&#10;        return createFallbackLocations() // Momentan werden die statischen Fallbacks verwendet&#10;    }&#10;&#10;    private fun createFallbackLocations(): List&lt;LocationEntity&gt; {&#10;        return listOf(&#10;            LocationEntity(&#10;                id = &quot;fallback_paris&quot;,&#10;                latitude = 48.8566,&#10;                longitude = 2.3522,&#10;                imageUrl = &quot;https://images.unsplash.com/photo-1502602898536-47ad22581b52?w=800&quot;,&#10;                country = &quot;France&quot;,&#10;                city = &quot;Paris&quot;,&#10;                difficulty = 2,&#10;                isCached = true,&#10;                isUsed = false&#10;            ),&#10;            LocationEntity(&#10;                id = &quot;fallback_london&quot;,&#10;                latitude = 51.5074,&#10;                longitude = -0.1278,&#10;                imageUrl = &quot;https://images.unsplash.com/photo-1513635269975-59663e0ac1ad?w=800&quot;,&#10;                country = &quot;United Kingdom&quot;,&#10;                city = &quot;London&quot;,&#10;                difficulty = 2,&#10;                isCached = true,&#10;                isUsed = false&#10;            ),&#10;            LocationEntity(&#10;                id = &quot;fallback_newyork&quot;,&#10;                latitude = 40.7128,&#10;                longitude = -74.0060,&#10;                imageUrl = &quot;https://images.unsplash.com/photo-1496442226666-8d4d0e62e6e9?w=800&quot;,&#10;                country = &quot;United States&quot;,&#10;                city = &quot;New York&quot;,&#10;                difficulty = 3,&#10;                isCached = true,&#10;                isUsed = false&#10;            ),&#10;            LocationEntity(&#10;                id = &quot;fallback_tokyo&quot;,&#10;                latitude = 35.6762,&#10;                longitude = 139.6503,&#10;                imageUrl = &quot;https://images.unsplash.com/photo-1540959733332-eab4deabeeaf?w=800&quot;,&#10;                country = &quot;Japan&quot;,&#10;                city = &quot;Tokyo&quot;,&#10;                difficulty = 4,&#10;                isCached = true,&#10;                isUsed = false&#10;            ),&#10;            LocationEntity(&#10;                id = &quot;fallback_sydney&quot;,&#10;                latitude = -33.8688,&#10;                longitude = 151.2093,&#10;                imageUrl = &quot;https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800&quot;,&#10;                country = &quot;Australia&quot;,&#10;                city = &quot;Sydney&quot;,&#10;                difficulty = 3,&#10;                isCached = true,&#10;                isUsed = false&#10;            ),&#10;            LocationEntity(&#10;                id = &quot;fallback_berlin&quot;,&#10;                latitude = 52.5200,&#10;                longitude = 13.4050,&#10;                imageUrl = &quot;https://images.unsplash.com/photo-1587330979470-3016b6702d89?w=800&quot;,&#10;                country = &quot;Germany&quot;,&#10;                city = &quot;Berlin&quot;,&#10;                difficulty = 2,&#10;                isCached = true,&#10;                isUsed = false&#10;            ),&#10;            LocationEntity(&#10;                id = &quot;fallback_rome&quot;,&#10;                latitude = 41.9028,&#10;                longitude = 12.4964,&#10;                imageUrl = &quot;https://images.unsplash.com/photo-1552832230-c0197dd311b5?w=800&quot;,&#10;                country = &quot;Italy&quot;,&#10;                city = &quot;Rome&quot;,&#10;                difficulty = 3,&#10;                isCached = true,&#10;                isUsed = false&#10;            ),&#10;            LocationEntity(&#10;                id = &quot;fallback_barcelona&quot;,&#10;                latitude = 41.3851,&#10;                longitude = 2.1734,&#10;                imageUrl = &quot;https://images.unsplash.com/photo-1539037116277-4db20889f2d4?w=800&quot;,&#10;                country = &quot;Spain&quot;,&#10;                city = &quot;Barcelona&quot;,&#10;                difficulty = 3,&#10;                isCached = true,&#10;                isUsed = false&#10;            )&#10;        )&#10;    }&#10;&#10;    private fun createEmergencyLocation(): LocationEntity {&#10;        return LocationEntity(&#10;            id = &quot;emergency_paris&quot;,&#10;            latitude = 48.8566,&#10;            longitude = 2.3522,&#10;            imageUrl = &quot;https://images.unsplash.com/photo-1502602898536-47ad22581b52?w=800&quot;,&#10;            country = &quot;France&quot;,&#10;            city = &quot;Paris&quot;,&#10;            difficulty = 2,&#10;            isCached = true,&#10;            isUsed = false&#10;        )&#10;    }&#10;&#10;    suspend fun resetLocationUsage() {&#10;        locationDao.resetAllLocationsUsage()&#10;    }&#10;&#10;    suspend fun getCachedLocationCount(): Int = locationDao.getCachedLocationCount()&#10;&#10;    suspend fun testBackendConnection(): Result&lt;Boolean&gt; {&#10;        return try {&#10;            val response = apiService.getHealth()&#10;            if (response.isSuccessful) {&#10;                Result.success(true)&#10;            } else {&#10;                Result.failure(Exception(&quot;Backend nicht erreichbar: ${response.code()}&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(Exception(&quot;Netzwerkfehler: ${e.message}&quot;))&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.repositories&#10;&#10;import com.example.geogeusserclone.data.database.dao.LocationDao&#10;import com.example.geogeusserclone.data.database.entities.LocationEntity&#10;import com.example.geogeusserclone.data.network.ApiService&#10;import com.example.geogeusserclone.data.network.MapillaryApiService&#10;import com.example.geogeusserclone.data.network.MapillaryImageDetails&#10;import com.example.geogeusserclone.utils.Constants&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.async&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.withContext&#10;import kotlinx.coroutines.withTimeoutOrNull&#10;import java.util.*&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class LocationRepository @Inject constructor(&#10;    private val apiService: ApiService,&#10;    private val mapillaryApiService: MapillaryApiService,&#10;    private val locationDao: LocationDao&#10;) : BaseRepository() {&#10;&#10;    fun getCachedLocations(): Flow&lt;List&lt;LocationEntity&gt;&gt; = locationDao.getCachedLocations()&#10;&#10;    suspend fun getRandomLocation(): Result&lt;LocationEntity&gt; {&#10;        return try {&#10;            // 1. Versuche zuerst lokale unbenutzte Location&#10;            val unusedLocation = locationDao.getRandomUnusedLocation()&#10;            if (unusedLocation != null) {&#10;                locationDao.markLocationAsUsed(unusedLocation.id)&#10;                return Result.success(unusedLocation)&#10;            }&#10;&#10;            // 2. Versuche dein Google Maps Backend&#10;            val backendResult = getLocationFromBackend()&#10;            if (backendResult.isSuccess) {&#10;                return backendResult&#10;            }&#10;&#10;            // 3. Fallback auf Mapillary (nur wenn Backend nicht verfügbar)&#10;            val mapillaryResult = getLocationFromMapillary()&#10;            if (mapillaryResult.isSuccess) {&#10;                return mapillaryResult&#10;            }&#10;&#10;            // 4. Ultimate Fallback: Erstelle Offline-Locations&#10;            val fallbackLocations = createFallbackLocations()&#10;            locationDao.insertLocations(fallbackLocations)&#10;            val randomLocation = fallbackLocations.random()&#10;            locationDao.markLocationAsUsed(randomLocation.id)&#10;&#10;            return Result.success(randomLocation)&#10;&#10;        } catch (e: Exception) {&#10;            // Emergency Fallback&#10;            val emergencyLocation = createEmergencyLocation()&#10;            try {&#10;                locationDao.insertLocation(emergencyLocation)&#10;                locationDao.markLocationAsUsed(emergencyLocation.id)&#10;                Result.success(emergencyLocation)&#10;            } catch (dbError: Exception) {&#10;                Result.failure(Exception(&quot;Kritischer Fehler: Kann keine Location laden&quot;))&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun getLocationFromBackend(): Result&lt;LocationEntity&gt; {&#10;        return try {&#10;            val response = withTimeoutOrNull(Constants.BACKEND_FALLBACK_DELAY_MS) {&#10;                apiService.getRandomLocations(count = 1, difficulty = 2, category = &quot;urban&quot;)&#10;            }&#10;&#10;            if (response?.isSuccessful == true) {&#10;                val locationsResponse = response.body()!!&#10;                if (locationsResponse.success &amp;&amp; locationsResponse.data.locations.isNotEmpty()) {&#10;                    val backendLocation = locationsResponse.data.locations.first()&#10;&#10;                    // Hole Street View URL für diese Location&#10;                    val streetViewResult = getStreetViewForLocation(backendLocation.id)&#10;                    val streetViewUrl = streetViewResult.getOrNull() ?: backendLocation.imageUrls.firstOrNull() ?: &quot;&quot;&#10;&#10;                    val locationEntity = LocationEntity(&#10;                        id = backendLocation.id.toString(), // Convert Int to String&#10;                        latitude = backendLocation.coordinates.latitude,&#10;                        longitude = backendLocation.coordinates.longitude,&#10;                        imageUrl = streetViewUrl,&#10;                        country = backendLocation.country,&#10;                        city = backendLocation.city,&#10;                        difficulty = backendLocation.difficulty,&#10;                        isCached = true,&#10;                        isUsed = false&#10;                    )&#10;&#10;                    locationDao.insertLocation(locationEntity)&#10;                    locationDao.markLocationAsUsed(locationEntity.id)&#10;                    return Result.success(locationEntity)&#10;                }&#10;            }&#10;            Result.failure(Exception(&quot;Backend nicht verfügbar&quot;))&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    private suspend fun getStreetViewForLocation(locationId: Int): Result&lt;String&gt; {&#10;        return try {&#10;            val response = apiService.getStreetView(&#10;                locationId = locationId,&#10;                responsive = true&#10;            )&#10;&#10;            if (response.isSuccessful) {&#10;                val streetViewResponse = response.body()!!&#10;                if (streetViewResponse.success) {&#10;                    // Korrekte Verarbeitung der verschachtelten URL-Struktur&#10;                    val urlsData = streetViewResponse.data.streetViewUrls&#10;                    if (urlsData is Map&lt;*, *&gt;) {&#10;                        val url = (urlsData[&quot;mobile&quot;] as? String)&#10;                            ?: (urlsData[&quot;tablet&quot;] as? String)&#10;                            ?: (urlsData[&quot;desktop&quot;] as? String)&#10;&#10;                        if (!url.isNullOrEmpty()) {&#10;                            return Result.success(url)&#10;                        }&#10;                    }&#10;                    // Fallback auf die einzelne URL, falls das Objekt-Parsing fehlschlägt&#10;                    val singleUrl = streetViewResponse.data.streetViewUrl&#10;                    if (!singleUrl.isNullOrEmpty()) {&#10;                        Result.success(singleUrl)&#10;                    } else {&#10;                        Result.failure(Exception(&quot;Keine Street View URL in der Antwort gefunden&quot;))&#10;                    }&#10;                } else {&#10;                    Result.failure(Exception(&quot;Street View Anfrage vom Backend als fehlgeschlagen markiert&quot;))&#10;                }&#10;            } else {&#10;                Result.failure(Exception(&quot;Street View API Fehler: ${response.code()}&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    private suspend fun getLocationFromMapillary(): Result&lt;LocationEntity&gt; {&#10;        return try {&#10;            println(&quot;LocationRepository: Versuche Mapillary-Fallback...&quot;)&#10;            &#10;            // Zufällige bekannte Städte für Mapillary-Suche&#10;            val searchCities = listOf(&#10;                Pair(48.8566, 2.3522),   // Paris&#10;                Pair(51.5074, -0.1278),  // London  &#10;                Pair(40.7128, -74.0060), // New York&#10;                Pair(52.5200, 13.4050),  // Berlin&#10;                Pair(41.9028, 12.4964),  // Rom&#10;                Pair(35.6762, 139.6503)  // Tokyo&#10;            )&#10;            &#10;            val randomCity = searchCities.random()&#10;            val (lat, lng) = randomCity&#10;            &#10;            // Erstelle BoundingBox um die Stadt (ca. 10km Radius)&#10;            val latOffset = 0.1 // ca. 11km&#10;            val lngOffset = 0.1&#10;            val bbox = &quot;${lng - lngOffset},${lat - latOffset},${lng + lngOffset},${lat + latOffset}&quot;&#10;            &#10;            // Versuche Mapillary API-Call&#10;            val response = withTimeoutOrNull(8000L) {&#10;                mapillaryApiService.getImagesNearby(&#10;                    bbox = bbox,&#10;                    isPano = true, // Nur 360° Panoramen&#10;                    limit = 5,&#10;                    accessToken = Constants.MAPILLARY_ACCESS_TOKEN&#10;                )&#10;            }&#10;            &#10;            if (response?.isSuccessful == true) {&#10;                val mapillaryResponse = response.body()!!&#10;                if (mapillaryResponse.data.isNotEmpty()) {&#10;                    val mapillaryImage = mapillaryResponse.data.random()&#10;                    val coords = mapillaryImage.geometry.coordinates&#10;                    &#10;                    // Hole detailed Image info für Download-URL&#10;                    val imageDetails = getMapillaryImageDetails(mapillaryImage.id)&#10;                    val imageUrl = imageDetails.getOrNull()?.thumb_1024_url &#10;                        ?: mapillaryImage.thumb_1024_url &#10;                        ?: mapillaryImage.thumb_256_url&#10;                        ?: &quot;&quot;&#10;                    &#10;                    if (imageUrl.isNotEmpty()) {&#10;                        val locationEntity = LocationEntity(&#10;                            id = &quot;mapillary_${mapillaryImage.id}&quot;,&#10;                            latitude = coords[1], // Mapillary: [lng, lat]&#10;                            longitude = coords[0],&#10;                            imageUrl = imageUrl,&#10;                            country = getCityName(coords[1], coords[0]).first,&#10;                            city = getCityName(coords[1], coords[0]).second,&#10;                            difficulty = 3, // Mapillary-Locations sind meist schwieriger&#10;                            isCached = true,&#10;                            isUsed = false&#10;                        )&#10;                        &#10;                        locationDao.insertLocation(locationEntity)&#10;                        locationDao.markLocationAsUsed(locationEntity.id)&#10;                        &#10;                        println(&quot;LocationRepository: Mapillary-Location erfolgreich geladen: ${locationEntity.city}&quot;)&#10;                        return Result.success(locationEntity)&#10;                    }&#10;                }&#10;            }&#10;            &#10;            println(&quot;LocationRepository: Mapillary-API nicht verfügbar, verwende statische Fallbacks&quot;)&#10;            // Fallback auf statische Locations&#10;            val fallbackLocations = createFallbackLocations()&#10;            if (fallbackLocations.isNotEmpty()) {&#10;                locationDao.insertLocations(fallbackLocations)&#10;                val randomLocation = fallbackLocations.random()&#10;                locationDao.markLocationAsUsed(randomLocation.id)&#10;                println(&quot;LocationRepository: Statischer Fallback verwendet: ${randomLocation.city}&quot;)&#10;                Result.success(randomLocation)&#10;            } else {&#10;                Result.failure(Exception(&quot;Keine Fallback-Locations verfügbar&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            println(&quot;LocationRepository: Mapillary-Fehler: ${e.message}&quot;)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;    &#10;    private suspend fun getMapillaryImageDetails(imageId: String): Result&lt;MapillaryImageDetails&gt; {&#10;        return try {&#10;            val response = mapillaryApiService.getImageDetails(&#10;                imageId = imageId,&#10;                accessToken = Constants.MAPILLARY_ACCESS_TOKEN&#10;            )&#10;            &#10;            if (response.isSuccessful) {&#10;                val details = response.body()!!&#10;                Result.success(details)&#10;            } else {&#10;                Result.failure(Exception(&quot;Mapillary Image Details API Fehler: ${response.code()}&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;    &#10;    private fun getCityName(lat: Double, lng: Double): Pair&lt;String, String&gt; {&#10;        // Einfache Zuordnung basierend auf Koordinaten&#10;        return when {&#10;            lat in 48.0..49.0 &amp;&amp; lng in 2.0..3.0 -&gt; Pair(&quot;France&quot;, &quot;Paris&quot;)&#10;            lat in 51.0..52.0 &amp;&amp; lng in -1.0..0.0 -&gt; Pair(&quot;United Kingdom&quot;, &quot;London&quot;)&#10;            lat in 40.0..41.0 &amp;&amp; lng in -75.0..-73.0 -&gt; Pair(&quot;United States&quot;, &quot;New York&quot;)&#10;            lat in 52.0..53.0 &amp;&amp; lng in 13.0..14.0 -&gt; Pair(&quot;Germany&quot;, &quot;Berlin&quot;)&#10;            lat in 41.0..42.0 &amp;&amp; lng in 12.0..13.0 -&gt; Pair(&quot;Italy&quot;, &quot;Rome&quot;)&#10;            lat in 35.0..36.0 &amp;&amp; lng in 139.0..140.0 -&gt; Pair(&quot;Japan&quot;, &quot;Tokyo&quot;)&#10;            else -&gt; Pair(&quot;Unknown&quot;, &quot;Unknown City&quot;)&#10;        }&#10;    }&#10;&#10;    suspend fun preloadLocations() {&#10;        withContext(Dispatchers.IO) { // Wechsle zum IO-Dispatcher für Netzwerkoperationen&#10;            try {&#10;                val response = withTimeoutOrNull(Constants.BACKEND_FALLBACK_DELAY_MS) {&#10;                    apiService.getRandomLocations(count = 10, difficulty = 2)&#10;                }&#10;&#10;                if (response?.isSuccessful == true) {&#10;                    val locationsResponse = response.body()!!&#10;                    if (locationsResponse.success) {&#10;                        // Parallele Ausführung der StreetView-Anfragen&#10;                        val locationEntities = locationsResponse.data.locations.map { backendLocation -&gt;&#10;                            async {&#10;                                val streetViewUrl = getStreetViewForLocation(backendLocation.id).getOrNull()&#10;                                    ?: backendLocation.imageUrls.firstOrNull()&#10;                                    ?: &quot;&quot;&#10;&#10;                                if (streetViewUrl.isNotBlank()) {&#10;                                    LocationEntity(&#10;                                        id = backendLocation.id.toString(),&#10;                                        latitude = backendLocation.coordinates.latitude,&#10;                                        longitude = backendLocation.coordinates.longitude,&#10;                                        imageUrl = streetViewUrl,&#10;                                        country = backendLocation.country,&#10;                                        city = backendLocation.city,&#10;                                        difficulty = backendLocation.difficulty,&#10;                                        isCached = true,&#10;                                        isUsed = false&#10;                                    )&#10;                                } else {&#10;                                    null // Null zurückgeben, wenn keine URL gefunden wurde&#10;                                }&#10;                            }&#10;                        }.mapNotNull { it.await() } // Auf alle warten und Null-Werte entfernen&#10;&#10;                        locationDao.insertLocations(locationEntities)&#10;                        return@withContext&#10;                    }&#10;                }&#10;&#10;                // Fallback: Lade Standard-Locations, wenn das Backend nicht verfügbar ist&#10;                val fallbackLocations = createFallbackLocations()&#10;                locationDao.insertLocations(fallbackLocations)&#10;&#10;            } catch (e: Exception) {&#10;                // Stiller Fallback bei Fehlern&#10;                val fallbackLocations = createFallbackLocations()&#10;                locationDao.insertLocations(fallbackLocations)&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun createFallbackLocationsWithMapillary(): List&lt;LocationEntity&gt; {&#10;        // Vereinfachte Mapillary-Integration als Fallback&#10;        return createFallbackLocations() // Momentan werden die statischen Fallbacks verwendet&#10;    }&#10;&#10;    private fun createFallbackLocations(): List&lt;LocationEntity&gt; {&#10;        return listOf(&#10;            LocationEntity(&#10;                id = &quot;fallback_paris&quot;,&#10;                latitude = 48.8566,&#10;                longitude = 2.3522,&#10;                imageUrl = &quot;https://images.unsplash.com/photo-1502602898536-47ad22581b52?w=800&quot;,&#10;                country = &quot;France&quot;,&#10;                city = &quot;Paris&quot;,&#10;                difficulty = 2,&#10;                isCached = true,&#10;                isUsed = false&#10;            ),&#10;            LocationEntity(&#10;                id = &quot;fallback_london&quot;,&#10;                latitude = 51.5074,&#10;                longitude = -0.1278,&#10;                imageUrl = &quot;https://images.unsplash.com/photo-1513635269975-59663e0ac1ad?w=800&quot;,&#10;                country = &quot;United Kingdom&quot;,&#10;                city = &quot;London&quot;,&#10;                difficulty = 2,&#10;                isCached = true,&#10;                isUsed = false&#10;            ),&#10;            LocationEntity(&#10;                id = &quot;fallback_newyork&quot;,&#10;                latitude = 40.7128,&#10;                longitude = -74.0060,&#10;                imageUrl = &quot;https://images.unsplash.com/photo-1496442226666-8d4d0e62e6e9?w=800&quot;,&#10;                country = &quot;United States&quot;,&#10;                city = &quot;New York&quot;,&#10;                difficulty = 3,&#10;                isCached = true,&#10;                isUsed = false&#10;            ),&#10;            LocationEntity(&#10;                id = &quot;fallback_tokyo&quot;,&#10;                latitude = 35.6762,&#10;                longitude = 139.6503,&#10;                imageUrl = &quot;https://images.unsplash.com/photo-1540959733332-eab4deabeeaf?w=800&quot;,&#10;                country = &quot;Japan&quot;,&#10;                city = &quot;Tokyo&quot;,&#10;                difficulty = 4,&#10;                isCached = true,&#10;                isUsed = false&#10;            ),&#10;            LocationEntity(&#10;                id = &quot;fallback_sydney&quot;,&#10;                latitude = -33.8688,&#10;                longitude = 151.2093,&#10;                imageUrl = &quot;https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800&quot;,&#10;                country = &quot;Australia&quot;,&#10;                city = &quot;Sydney&quot;,&#10;                difficulty = 3,&#10;                isCached = true,&#10;                isUsed = false&#10;            ),&#10;            LocationEntity(&#10;                id = &quot;fallback_berlin&quot;,&#10;                latitude = 52.5200,&#10;                longitude = 13.4050,&#10;                imageUrl = &quot;https://images.unsplash.com/photo-1587330979470-3016b6702d89?w=800&quot;,&#10;                country = &quot;Germany&quot;,&#10;                city = &quot;Berlin&quot;,&#10;                difficulty = 2,&#10;                isCached = true,&#10;                isUsed = false&#10;            ),&#10;            LocationEntity(&#10;                id = &quot;fallback_rome&quot;,&#10;                latitude = 41.9028,&#10;                longitude = 12.4964,&#10;                imageUrl = &quot;https://images.unsplash.com/photo-1552832230-c0197dd311b5?w=800&quot;,&#10;                country = &quot;Italy&quot;,&#10;                city = &quot;Rome&quot;,&#10;                difficulty = 3,&#10;                isCached = true,&#10;                isUsed = false&#10;            ),&#10;            LocationEntity(&#10;                id = &quot;fallback_barcelona&quot;,&#10;                latitude = 41.3851,&#10;                longitude = 2.1734,&#10;                imageUrl = &quot;https://images.unsplash.com/photo-1539037116277-4db20889f2d4?w=800&quot;,&#10;                country = &quot;Spain&quot;,&#10;                city = &quot;Barcelona&quot;,&#10;                difficulty = 3,&#10;                isCached = true,&#10;                isUsed = false&#10;            )&#10;        )&#10;    }&#10;&#10;    private fun createEmergencyLocation(): LocationEntity {&#10;        return LocationEntity(&#10;            id = &quot;emergency_paris&quot;,&#10;            latitude = 48.8566,&#10;            longitude = 2.3522,&#10;            imageUrl = &quot;https://images.unsplash.com/photo-1502602898536-47ad22581b52?w=800&quot;,&#10;            country = &quot;France&quot;,&#10;            city = &quot;Paris&quot;,&#10;            difficulty = 2,&#10;            isCached = true,&#10;            isUsed = false&#10;        )&#10;    }&#10;&#10;    suspend fun resetLocationUsage() {&#10;        locationDao.resetAllLocationsUsage()&#10;    }&#10;&#10;    suspend fun getCachedLocationCount(): Int = locationDao.getCachedLocationCount()&#10;&#10;    suspend fun testBackendConnection(): Result&lt;Boolean&gt; {&#10;        return try {&#10;            val response = apiService.getHealth()&#10;            if (response.isSuccessful) {&#10;                Result.success(true)&#10;            } else {&#10;                Result.failure(Exception(&quot;Backend nicht erreichbar: ${response.code()}&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(Exception(&quot;Netzwerkfehler: ${e.message}&quot;))&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/repositories/StreetViewLocationRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/repositories/StreetViewLocationRepository.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.repositories&#10;&#10;import com.example.geogeusserclone.data.database.dao.LocationDao&#10;import com.example.geogeusserclone.data.database.entities.LocationEntity&#10;import com.example.geogeusserclone.data.network.ApiService&#10;import com.example.geogeusserclone.data.network.MapillaryApiService&#10;import com.example.geogeusserclone.utils.Constants&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.withTimeoutOrNull&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class StreetViewLocationRepository @Inject constructor(&#10;    private val apiService: ApiService,&#10;    private val mapillaryApiService: MapillaryApiService,&#10;    private val locationDao: LocationDao&#10;) : BaseRepository() {&#10;&#10;    suspend fun getRandomLocationWithStreetView(): Result&lt;LocationEntity&gt; {&#10;        return try {&#10;            // 1. Versuche zuerst lokale unbenutzte Location&#10;            val unusedLocation = locationDao.getRandomUnusedLocation()&#10;            if (unusedLocation != null) {&#10;                locationDao.markLocationAsUsed(unusedLocation.id)&#10;                return Result.success(unusedLocation)&#10;            }&#10;&#10;            // 2. Erstelle Fallback-Locations mit echten 360° StreetView-Bildern&#10;            val streetViewLocations = createStreetViewFallbackLocations()&#10;            locationDao.insertLocations(streetViewLocations)&#10;            &#10;            val randomLocation = streetViewLocations.random()&#10;            locationDao.markLocationAsUsed(randomLocation.id)&#10;            &#10;            return Result.success(randomLocation)&#10;&#10;        } catch (e: Exception) {&#10;            // Emergency Fallback&#10;            val emergencyLocation = createEmergencyLocation()&#10;            try {&#10;                locationDao.insertLocation(emergencyLocation)&#10;                locationDao.markLocationAsUsed(emergencyLocation.id)&#10;                Result.success(emergencyLocation)&#10;            } catch (dbError: Exception) {&#10;                Result.failure(Exception(&quot;Kritischer Fehler: Kann keine Location laden&quot;))&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun createStreetViewFallbackLocations(): List&lt;LocationEntity&gt; {&#10;        val fallbackLocations = mutableListOf&lt;LocationEntity&gt;()&#10;        &#10;        // Versuche echte Mapillary-Bilder für beliebte Städte zu holen&#10;        val popularCities = listOf(&#10;            Triple(48.8566, 2.3522, &quot;Paris&quot;),      // Paris&#10;            Triple(51.5074, -0.1278, &quot;London&quot;),   // London&#10;            Triple(40.7128, -74.0060, &quot;New York&quot;), // New York&#10;            Triple(35.6762, 139.6503, &quot;Tokyo&quot;),   // Tokyo&#10;            Triple(-33.8688, 151.2093, &quot;Sydney&quot;), // Sydney&#10;            Triple(52.5200, 13.4050, &quot;Berlin&quot;),   // Berlin&#10;            Triple(41.9028, 12.4964, &quot;Rome&quot;),     // Rome&#10;            Triple(41.3851, 2.1734, &quot;Barcelona&quot;)  // Barcelona&#10;        )&#10;&#10;        popularCities.forEachIndexed { index, (lat, lng, cityName) -&gt;&#10;            try {&#10;                val streetViewImage = fetchMapillaryImageForLocation(lat, lng)&#10;                if (streetViewImage != null) {&#10;                    fallbackLocations.add(&#10;                        LocationEntity(&#10;                            id = &quot;streetview_${cityName.lowercase()}_$index&quot;,&#10;                            latitude = streetViewImage.geometry.coordinates[1], // Mapillary coords&#10;                            longitude = streetViewImage.geometry.coordinates[0],&#10;                            imageUrl = streetViewImage.thumb_2048_url ?: streetViewImage.thumb_1024_url ?: &quot;&quot;,&#10;                            country = getCountryFromCity(cityName),&#10;                            city = cityName,&#10;                            difficulty = 2,&#10;                            isCached = true,&#10;                            isUsed = false&#10;                        )&#10;                    )&#10;                } else {&#10;                    // Fallback auf hochwertige Unsplash-Bilder&#10;                    fallbackLocations.add(createHighQualityFallbackLocation(lat, lng, cityName, index))&#10;                }&#10;            } catch (e: Exception) {&#10;                // Fallback auf statische Bilder&#10;                fallbackLocations.add(createHighQualityFallbackLocation(lat, lng, cityName, index))&#10;            }&#10;        }&#10;&#10;        return fallbackLocations&#10;    }&#10;&#10;    private suspend fun fetchMapillaryImageForLocation(lat: Double, lng: Double): com.example.geogeusserclone.data.network.MapillaryImage? {&#10;        return try {&#10;            // Erstelle Bounding Box (ca. 1km Radius)&#10;            val offset = 0.01 // Ungefähr 1km&#10;            val bbox = &quot;${lng - offset},${lat - offset},${lng + offset},${lat + offset}&quot;&#10;            &#10;            val response = withTimeoutOrNull(3000) {&#10;                mapillaryApiService.getImagesNearby(&#10;                    bbox = bbox,&#10;                    isPano = true,&#10;                    limit = 5,&#10;                    accessToken = Constants.MAPILLARY_ACCESS_TOKEN&#10;                )&#10;            }&#10;&#10;            if (response?.isSuccessful == true) {&#10;                response.body()?.data?.firstOrNull()&#10;            } else null&#10;        } catch (e: Exception) {&#10;            null&#10;        }&#10;    }&#10;&#10;    private fun createHighQualityFallbackLocation(lat: Double, lng: Double, cityName: String, index: Int): LocationEntity {&#10;        val imageUrls = mapOf(&#10;            &quot;Paris&quot; to &quot;https://images.unsplash.com/photo-1502602898536-47ad22581b52?w=1200&amp;h=800&amp;fit=crop&quot;,&#10;            &quot;London&quot; to &quot;https://images.unsplash.com/photo-1513635269975-59663e0ac1ad?w=1200&amp;h=800&amp;fit=crop&quot;,&#10;            &quot;New York&quot; to &quot;https://images.unsplash.com/photo-1496442226666-8d4d0e62e6e9?w=1200&amp;h=800&amp;fit=crop&quot;,&#10;            &quot;Tokyo&quot; to &quot;https://images.unsplash.com/photo-1540959733332-eab4deabeeaf?w=1200&amp;h=800&amp;fit=crop&quot;,&#10;            &quot;Sydney&quot; to &quot;https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=1200&amp;h=800&amp;fit=crop&quot;,&#10;            &quot;Berlin&quot; to &quot;https://images.unsplash.com/photo-1587330979470-3016b6702d89?w=1200&amp;h=800&amp;fit=crop&quot;,&#10;            &quot;Rome&quot; to &quot;https://images.unsplash.com/photo-1552832230-c0197dd311b5?w=1200&amp;h=800&amp;fit=crop&quot;,&#10;            &quot;Barcelona&quot; to &quot;https://images.unsplash.com/photo-1539037116277-4db20889f2d4?w=1200&amp;h=800&amp;fit=crop&quot;&#10;        )&#10;&#10;        return LocationEntity(&#10;            id = &quot;fallback_${cityName.lowercase()}_$index&quot;,&#10;            latitude = lat,&#10;            longitude = lng,&#10;            imageUrl = imageUrls[cityName] ?: &quot;https://images.unsplash.com/photo-1502602898536-47ad22581b52?w=1200&amp;h=800&amp;fit=crop&quot;,&#10;            country = getCountryFromCity(cityName),&#10;            city = cityName,&#10;            difficulty = 2,&#10;            isCached = true,&#10;            isUsed = false&#10;        )&#10;    }&#10;&#10;    private fun createEmergencyLocation(): LocationEntity {&#10;        return LocationEntity(&#10;            id = &quot;emergency_paris&quot;,&#10;            latitude = 48.8566,&#10;            longitude = 2.3522,&#10;            imageUrl = &quot;https://images.unsplash.com/photo-1502602898536-47ad22581b52?w=1200&amp;h=800&amp;fit=crop&quot;,&#10;            country = &quot;France&quot;,&#10;            city = &quot;Paris&quot;,&#10;            difficulty = 2,&#10;            isCached = true,&#10;            isUsed = false&#10;        )&#10;    }&#10;&#10;    private fun getCountryFromCity(cityName: String): String {&#10;        return when (cityName) {&#10;            &quot;Paris&quot; -&gt; &quot;France&quot;&#10;            &quot;London&quot; -&gt; &quot;United Kingdom&quot;&#10;            &quot;New York&quot; -&gt; &quot;United States&quot;&#10;            &quot;Tokyo&quot; -&gt; &quot;Japan&quot;&#10;            &quot;Sydney&quot; -&gt; &quot;Australia&quot;&#10;            &quot;Berlin&quot; -&gt; &quot;Germany&quot;&#10;            &quot;Rome&quot; -&gt; &quot;Italy&quot;&#10;            &quot;Barcelona&quot; -&gt; &quot;Spain&quot;&#10;            else -&gt; &quot;Unknown&quot;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Preloade Locations mit echten StreetView-Bildern&#10;     */&#10;    suspend fun preloadStreetViewLocations() {&#10;        try {&#10;            val streetViewLocations = createStreetViewFallbackLocations()&#10;            locationDao.insertLocations(streetViewLocations)&#10;        } catch (e: Exception) {&#10;            // Fallback auf normale Locations&#10;            val normalFallbacks = createStreetViewFallbackLocations()&#10;            locationDao.insertLocations(normalFallbacks)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/repositories/UserRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/repositories/UserRepository.kt" />
              <option name="originalContent" value="&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.repositories&#10;&#10;import com.example.geogeusserclone.data.database.dao.UserDao&#10;import com.example.geogeusserclone.data.database.entities.UserEntity&#10;import com.example.geogeusserclone.data.network.ApiService&#10;import com.example.geogeusserclone.data.network.AuthInterceptor&#10;import com.example.geogeusserclone.data.network.LoginRequest&#10;import com.example.geogeusserclone.data.network.RegisterRequest&#10;import kotlinx.coroutines.flow.Flow&#10;import java.util.UUID&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class UserRepository @Inject constructor(&#10;    private val apiService: ApiService,&#10;    private val userDao: UserDao,&#10;    private val authInterceptor: AuthInterceptor&#10;) : BaseRepository() {&#10;&#10;    suspend fun getCurrentUser(): UserEntity? {&#10;        return userDao.getCurrentUser()&#10;    }&#10;&#10;    suspend fun login(email: String, password: String): Result&lt;UserEntity&gt; {&#10;        return try {&#10;            val response = apiService.login(LoginRequest(email, password))&#10;            if (response.isSuccessful) {&#10;                val authResponse = response.body()!!&#10;&#10;                // Setze Auth Token&#10;                authInterceptor.setAuthToken(authResponse.data.token)&#10;&#10;                val userEntity = UserEntity(&#10;                    id = authResponse.data.user.id.toString(), // Convert Int to String&#10;                    username = authResponse.data.user.username,&#10;                    email = authResponse.data.user.email,&#10;                    authToken = authResponse.data.token,&#10;                    totalScore = authResponse.data.user.totalScore,&#10;                    gamesPlayed = authResponse.data.user.gamesPlayed,&#10;                    bestScore = authResponse.data.user.bestScore,&#10;                    lastLoginAt = System.currentTimeMillis(),&#10;                    createdAt = System.currentTimeMillis()&#10;                )&#10;&#10;                userDao.insertUser(userEntity)&#10;                Result.success(userEntity)&#10;            } else {&#10;                Result.failure(Exception(&quot;Login fehlgeschlagen: ${response.message()}&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            // Fallback für Offline-Modus&#10;            val offlineUser = createOfflineUser(email)&#10;            userDao.insertUser(offlineUser)&#10;            Result.success(offlineUser)&#10;        }&#10;    }&#10;&#10;    suspend fun register(username: String, email: String, password: String): Result&lt;UserEntity&gt; {&#10;        return try {&#10;            val response = apiService.register(RegisterRequest(username, email, password))&#10;            if (response.isSuccessful) {&#10;                val authResponse = response.body()!!&#10;&#10;                authInterceptor.setAuthToken(authResponse.data.token)&#10;&#10;                val userEntity = UserEntity(&#10;                    id = authResponse.data.user.id.toString(), // Convert Int to String&#10;                    username = authResponse.data.user.username,&#10;                    email = authResponse.data.user.email,&#10;                    authToken = authResponse.data.token,&#10;                    totalScore = 0,&#10;                    gamesPlayed = 0,&#10;                    bestScore = 0,&#10;                    lastLoginAt = System.currentTimeMillis(),&#10;                    createdAt = System.currentTimeMillis()&#10;                )&#10;&#10;                userDao.insertUser(userEntity)&#10;                Result.success(userEntity)&#10;            } else {&#10;                Result.failure(Exception(&quot;Registrierung fehlgeschlagen: ${response.message()}&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            // Fallback für Offline-Modus&#10;            val offlineUser = createOfflineUser(email, username)&#10;            userDao.insertUser(offlineUser)&#10;            Result.success(offlineUser)&#10;        }&#10;    }&#10;&#10;    suspend fun logout() {&#10;        authInterceptor.setAuthToken(null)&#10;        userDao.clearCurrentUser()&#10;    }&#10;&#10;    suspend fun updateUserStats(totalScore: Int, gamesPlayed: Int, bestScore: Int) {&#10;        val currentUser = userDao.getCurrentUser()&#10;        currentUser?.let { user -&gt;&#10;            val updatedUser = user.copy(&#10;                totalScore = user.totalScore + totalScore,&#10;                gamesPlayed = user.gamesPlayed + gamesPlayed,&#10;                bestScore = maxOf(user.bestScore, bestScore),&#10;                lastLoginAt = System.currentTimeMillis()&#10;            )&#10;            userDao.updateUser(updatedUser)&#10;        }&#10;    }&#10;&#10;    suspend fun insertEmergencyUser(user: UserEntity) {&#10;        userDao.insertUser(user)&#10;    }&#10;&#10;    private fun createOfflineUser(email: String, username: String = &quot;Offline User&quot;): UserEntity {&#10;        return UserEntity(&#10;            id = UUID.randomUUID().toString(),&#10;            username = username,&#10;            email = email,&#10;            authToken = null,&#10;            totalScore = 0,&#10;            gamesPlayed = 0,&#10;            bestScore = 0,&#10;            lastLoginAt = System.currentTimeMillis(),&#10;            createdAt = System.currentTimeMillis()&#10;        )&#10;    }&#10;&#10;    fun getAllUsers(): Flow&lt;List&lt;UserEntity&gt;&gt; {&#10;        return userDao.getAllUsers()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/di/NetworkModule.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/di/NetworkModule.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.di&#10;&#10;import com.example.geogeusserclone.data.network.ApiService&#10;import com.example.geogeusserclone.data.network.AuthInterceptor&#10;import com.example.geogeusserclone.utils.Constants&#10;import dagger.Module&#10;import dagger.Provides&#10;import dagger.hilt.InstallIn&#10;import dagger.hilt.components.SingletonComponent&#10;import okhttp3.OkHttpClient&#10;import okhttp3.logging.HttpLoggingInterceptor&#10;import retrofit2.Retrofit&#10;import retrofit2.converter.gson.GsonConverterFactory&#10;import java.util.concurrent.TimeUnit&#10;import javax.inject.Singleton&#10;&#10;@Module&#10;@InstallIn(SingletonComponent::class)&#10;object NetworkModule {&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideHttpLoggingInterceptor(): HttpLoggingInterceptor {&#10;        return HttpLoggingInterceptor().apply {&#10;            level = HttpLoggingInterceptor.Level.BODY&#10;        }&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideOkHttpClient(&#10;        authInterceptor: AuthInterceptor,&#10;        loggingInterceptor: HttpLoggingInterceptor&#10;    ): OkHttpClient {&#10;        return OkHttpClient.Builder()&#10;            .addInterceptor(authInterceptor)&#10;            .addInterceptor(loggingInterceptor)&#10;            .connectTimeout(Constants.CONNECT_TIMEOUT, TimeUnit.SECONDS)&#10;            .readTimeout(Constants.READ_TIMEOUT, TimeUnit.SECONDS)&#10;            .writeTimeout(Constants.WRITE_TIMEOUT, TimeUnit.SECONDS)&#10;            .build()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {&#10;        return Retrofit.Builder()&#10;            .baseUrl(Constants.BASE_URL)&#10;            .client(okHttpClient)&#10;            .addConverterFactory(GsonConverterFactory.create())&#10;            .build()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideApiService(retrofit: Retrofit): ApiService {&#10;        return retrofit.create(ApiService::class.java)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/di/RepositoryModule.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/di/RepositoryModule.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.di&#10;&#10;import com.example.geogeusserclone.data.database.dao.GameDao&#10;import com.example.geogeusserclone.data.database.dao.GuessDao&#10;import com.example.geogeusserclone.data.database.dao.LocationDao&#10;import com.example.geogeusserclone.data.database.dao.UserDao&#10;import com.example.geogeusserclone.data.network.ApiService&#10;import com.example.geogeusserclone.data.network.MapillaryApiService&#10;import com.example.geogeusserclone.data.repositories.*&#10;import dagger.Module&#10;import dagger.Provides&#10;import dagger.hilt.InstallIn&#10;import dagger.hilt.components.SingletonComponent&#10;import javax.inject.Singleton&#10;&#10;@Module&#10;@InstallIn(SingletonComponent::class)&#10;object RepositoryModule {&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideUserRepository(&#10;        apiService: ApiService,&#10;        userDao: UserDao,&#10;        authInterceptor: com.example.geogeusserclone.data.network.AuthInterceptor&#10;    ): UserRepository {&#10;        return UserRepository(apiService, userDao, authInterceptor)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideLocationRepository(&#10;        apiService: ApiService,&#10;        mapillaryApiService: MapillaryApiService,&#10;        locationDao: LocationDao&#10;    ): LocationRepository {&#10;        return LocationRepository(apiService, mapillaryApiService, locationDao)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideGameRepository(&#10;        apiService: ApiService,&#10;        gameDao: GameDao,&#10;        guessDao: GuessDao,&#10;        locationDao: LocationDao,&#10;        userRepository: UserRepository&#10;    ): GameRepository {&#10;        return GameRepository(apiService, gameDao, guessDao, locationDao, userRepository)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideLocationCacheRepository(&#10;        apiService: ApiService,&#10;        locationDao: LocationDao&#10;    ): LocationCacheRepository {&#10;        return LocationCacheRepository(apiService, locationDao)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/ui/activities/GameActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/ui/activities/GameActivity.kt" />
              <option name="originalContent" value="package com.example.geogeusserclone.ui.activities&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.viewModels&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import com.example.geogeusserclone.data.models.GameState&#10;import com.example.geogeusserclone.data.database.entities.GuessEntity&#10;import com.example.geogeusserclone.ui.components.GameCompletionScreen&#10;import com.example.geogeusserclone.ui.components.GuessMapView&#10;import com.example.geogeusserclone.ui.components.LocationImageScreen&#10;import com.example.geogeusserclone.ui.components.RoundResultView&#10;import com.example.geogeusserclone.ui.theme.GeoGeusserCloneTheme&#10;import com.example.geogeusserclone.utils.enableEdgeToEdge&#10;import com.example.geogeusserclone.viewmodels.GameViewModel&#10;import dagger.hilt.android.AndroidEntryPoint&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;@AndroidEntryPoint&#10;class GameActivity : ComponentActivity() {&#10;&#10;    private val gameViewModel: GameViewModel by viewModels()&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;&#10;        setContent {&#10;            GeoGeusserCloneTheme {&#10;                val gameState by gameViewModel.uiState.collectAsState()&#10;&#10;                LaunchedEffect(Unit) {&#10;                    gameViewModel.startNewGame()&#10;                }&#10;&#10;                GameScreen(&#10;                    gameState = gameState,&#10;                    onGuess = { lat, lng -&gt; gameViewModel.submitGuess(lat, lng) },&#10;                    onNextRound = { gameViewModel.proceedToNextRound() },&#10;                    onShowMap = { gameViewModel.showMap() },&#10;                    onHideMap = { gameViewModel.hideMap() },&#10;                    onPan = { /* Pan-Event wird bereits in LocationImageScreen behandelt */ },&#10;                    onBack = { finish() },&#10;                    getGuesses = { gameViewModel.getGameGuesses() }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun GameScreen(&#10;    gameState: GameState,&#10;    onGuess: (Double, Double) -&gt; Unit,&#10;    onNextRound: () -&gt; Unit,&#10;    onShowMap: () -&gt; Unit,&#10;    onHideMap: () -&gt; Unit,&#10;    onPan: (Float) -&gt; Unit,&#10;    onBack: () -&gt; Unit,&#10;    getGuesses: () -&gt; Flow&lt;List&lt;GuessEntity&gt;&gt;&#10;) {&#10;    val snackbarHostState = remember { SnackbarHostState() }&#10;&#10;    LaunchedEffect(gameState.error) {&#10;        gameState.error?.let {&#10;            snackbarHostState.showSnackbar(&#10;                message = it,&#10;                duration = SnackbarDuration.Short&#10;            )&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        snackbarHost = { SnackbarHost(snackbarHostState) }&#10;    ) { padding -&gt;&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(padding)&#10;        ) {&#10;            // Haupt-Spielinhalt&#10;            if (gameState.isLoading &amp;&amp; gameState.currentGame == null) {&#10;                Box(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    CircularProgressIndicator()&#10;                }&#10;            } else if (gameState.currentLocation != null &amp;&amp; !gameState.showGameCompletion) {&#10;                LocationImageScreen(&#10;                    location = gameState.currentLocation,&#10;                    timeRemaining = gameState.timeRemaining,&#10;                    onShowMap = onShowMap,&#10;                    onPan = onPan&#10;                )&#10;            }&#10;&#10;            // Map-Ansicht zum Raten&#10;            if (gameState.showMap) {&#10;                GuessMapView(&#10;                    location = gameState.currentLocation,&#10;                    onGuessSelected = { lat, lng -&gt;&#10;                        onGuess(lat, lng)&#10;                        onHideMap()&#10;                    },&#10;                    onMapClose = onHideMap&#10;                )&#10;            }&#10;&#10;            // Ergebnis der Runde&#10;            if (gameState.showRoundResult) {&#10;                RoundResultView(&#10;                    guess = gameState.revealGuessResult,&#10;                    onNextRound = onNextRound&#10;                )&#10;            }&#10;&#10;            // Spiel-Abschluss-Bildschirm&#10;            if (gameState.showGameCompletion) {&#10;                val guesses by getGuesses().collectAsState(initial = emptyList())&#10;                gameState.currentGame?.let { game -&gt;&#10;                    GameCompletionScreen(&#10;                        game = game,&#10;                        guesses = guesses,&#10;                        onPlayAgain = { /* TODO: Implement Play Again */ },&#10;                        onMainMenu = onBack&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.geogeusserclone.ui.activities&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.viewModels&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import com.example.geogeusserclone.data.models.GameState&#10;import com.example.geogeusserclone.data.database.entities.GuessEntity&#10;import com.example.geogeusserclone.ui.components.GameCompletionScreen&#10;import com.example.geogeusserclone.ui.components.GuessMapView&#10;import com.example.geogeusserclone.ui.components.LocationImageScreen&#10;import com.example.geogeusserclone.ui.components.RoundResultView&#10;import com.example.geogeusserclone.ui.theme.GeoGeusserCloneTheme&#10;import com.example.geogeusserclone.utils.enableEdgeToEdge&#10;import com.example.geogeusserclone.viewmodels.GameViewModel&#10;import dagger.hilt.android.AndroidEntryPoint&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;@AndroidEntryPoint&#10;class GameActivity : ComponentActivity() {&#10;&#10;    private val gameViewModel: GameViewModel by viewModels()&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;&#10;        setContent {&#10;            GeoGeusserCloneTheme {&#10;                val gameState by gameViewModel.uiState.collectAsState()&#10;&#10;                LaunchedEffect(Unit) {&#10;                    gameViewModel.startNewGame()&#10;                }&#10;&#10;                GameScreen(&#10;                    gameState = gameState,&#10;                    onGuess = { lat, lng -&gt; gameViewModel.submitGuess(lat, lng) },&#10;                    onNextRound = { gameViewModel.proceedToNextRound() },&#10;                    onShowMap = { gameViewModel.showMap() },&#10;                    onHideMap = { gameViewModel.hideMap() },&#10;                    onPan = { /* Pan-Event wird bereits in LocationImageScreen behandelt */ },&#10;                    onBack = { finish() },&#10;                    getGuesses = { gameViewModel.getGameGuesses() }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun GameScreen(&#10;    gameState: GameState,&#10;    onGuess: (Double, Double) -&gt; Unit,&#10;    onNextRound: () -&gt; Unit,&#10;    onShowMap: () -&gt; Unit,&#10;    onHideMap: () -&gt; Unit,&#10;    onPan: (Float) -&gt; Unit,&#10;    onBack: () -&gt; Unit,&#10;    getGuesses: () -&gt; Flow&lt;List&lt;GuessEntity&gt;&gt;&#10;) {&#10;    val snackbarHostState = remember { SnackbarHostState() }&#10;&#10;    LaunchedEffect(gameState.error) {&#10;        gameState.error?.let {&#10;            snackbarHostState.showSnackbar(&#10;                message = it,&#10;                duration = SnackbarDuration.Short&#10;            )&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        snackbarHost = { SnackbarHost(snackbarHostState) }&#10;    ) { padding -&gt;&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(padding)&#10;        ) {&#10;            // Haupt-Spielinhalt&#10;            if (gameState.isLoading &amp;&amp; gameState.currentGame == null) {&#10;                Box(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    CircularProgressIndicator()&#10;                }&#10;            } else if (gameState.currentLocation != null &amp;&amp; !gameState.showGameCompletion) {&#10;                LocationImageScreen(&#10;                    location = gameState.currentLocation,&#10;                    timeRemaining = gameState.timeRemaining,&#10;                    onShowMap = onShowMap,&#10;                    onPan = onPan&#10;                )&#10;            }&#10;&#10;            // Map-Ansicht zum Raten&#10;            if (gameState.showMap) {&#10;                GuessMapView(&#10;                    onGuessSelected = { lat, lng -&gt;&#10;                        onGuess(lat, lng)&#10;                        onHideMap()&#10;                    },&#10;                    onMapClose = onHideMap&#10;                )&#10;            }&#10;&#10;            // Ergebnis der Runde&#10;            if (gameState.showRoundResult) {&#10;                RoundResultView(&#10;                    guess = gameState.revealGuessResult,&#10;                    onNextRound = onNextRound&#10;                )&#10;            }&#10;&#10;            // Spiel-Abschluss-Bildschirm&#10;            if (gameState.showGameCompletion) {&#10;                val guesses by getGuesses().collectAsState(initial = emptyList())&#10;                gameState.currentGame?.let { game -&gt;&#10;                    GameCompletionScreen(&#10;                        game = game,&#10;                        guesses = guesses,&#10;                        onPlayAgain = { /* TODO: Implement Play Again */ },&#10;                        onMainMenu = onBack&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/ui/components/InteractiveStreetView.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/ui/components/InteractiveStreetView.kt" />
              <option name="originalContent" value="package com.example.geogeusserclone.ui.components&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.gestures.detectTapGestures&#10;import androidx.compose.foundation.gestures.detectTransformGestures&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.asImageBitmap&#10;import androidx.compose.ui.graphics.drawscope.scale&#10;import androidx.compose.ui.graphics.drawscope.translate&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.IntSize&#10;import coil.compose.AsyncImagePainter&#10;import coil.compose.rememberAsyncImagePainter&#10;import coil.request.ImageRequest&#10;import kotlinx.coroutines.launch&#10;import kotlin.math.cos&#10;import kotlin.math.sin&#10;&#10;@Composable&#10;fun InteractiveStreetView(&#10;    imageUrl: String,&#10;    modifier: Modifier = Modifier,&#10;    onPan: (Float) -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val scope = rememberCoroutineScope()&#10;&#10;    // Street View Navigation State&#10;    var currentHeading by remember { mutableIntStateOf(0) }&#10;    var currentPitch by remember { mutableIntStateOf(0) } // Für Hoch/Runter schauen&#10;    var currentZoom by remember { mutableFloatStateOf(90f) } // FOV (Field of View)&#10;    var currentLocation by remember { mutableStateOf(extractLocationFromUrl(imageUrl)) }&#10;&#10;    // Gesture State&#10;    var dragAccumulator by remember { mutableStateOf(Offset.Zero) }&#10;    var isLoading by remember { mutableStateOf(false) }&#10;    var transformationState by remember { mutableStateOf(TransformState()) }&#10;&#10;    // Berechne die Street View URL mit allen Parametern&#10;    val streetViewUrl = remember(imageUrl, currentHeading, currentPitch, currentZoom, currentLocation) {&#10;        buildStreetViewUrl(&#10;            baseUrl = imageUrl,&#10;            location = currentLocation,&#10;            heading = currentHeading,&#10;            pitch = currentPitch,&#10;            fov = currentZoom.toInt()&#10;        )&#10;    }&#10;&#10;    val painter = rememberAsyncImagePainter(&#10;        model = ImageRequest.Builder(context)&#10;            .data(streetViewUrl)&#10;            .crossfade(true)&#10;            .size(coil.size.Size.ORIGINAL)&#10;            .build()&#10;    )&#10;&#10;    Box(modifier = modifier.fillMaxSize()) {&#10;        when (painter.state) {&#10;            is AsyncImagePainter.State.Loading -&gt; {&#10;                CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))&#10;            }&#10;            is AsyncImagePainter.State.Success -&gt; {&#10;                val imageBitmap = (painter.state as AsyncImagePainter.State.Success).result.drawable.let {&#10;                    (it as android.graphics.drawable.BitmapDrawable).bitmap&#10;                }.asImageBitmap()&#10;&#10;                Canvas(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .pointerInput(Unit) {&#10;                            // Multi-Touch Gesture Detection&#10;                            detectTransformGestures(&#10;                                onGesture = { _, pan, zoom, _ -&gt;&#10;                                    // Zoom (Pinch) Gesture&#10;                                    if (zoom != 1f) {&#10;                                        currentZoom = (currentZoom / zoom).coerceIn(20f, 120f)&#10;                                    }&#10;&#10;                                    // Pan Gesture für Look-Around&#10;                                    if (pan != Offset.Zero) {&#10;                                        dragAccumulator += pan&#10;                                    }&#10;                                }&#10;                            )&#10;                        }&#10;                        .pointerInput(Unit) {&#10;                            // Tap Gesture für Movement&#10;                            detectTapGestures(&#10;                                onTap = { offset -&gt;&#10;                                    scope.launch {&#10;                                        moveForward(&#10;                                            currentLocation = currentLocation,&#10;                                            heading = currentHeading,&#10;                                            stepSize = 10.0 // Meter&#10;                                        ) { newLocation -&gt;&#10;                                            currentLocation = newLocation&#10;                                            isLoading = true&#10;                                            // Reset nach Bewegung&#10;                                            scope.launch {&#10;                                                kotlinx.coroutines.delay(1000)&#10;                                                isLoading = false&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                }&#10;                            )&#10;                        }&#10;                        .pointerInput(Unit) {&#10;                            // Separate Drag Detection für Präzise Kontrolle&#10;                            detectDragGestures(&#10;                                onDragEnd = {&#10;                                    handleDragEnd(&#10;                                        dragAccumulator = dragAccumulator,&#10;                                        onHeadingChange = { newHeading -&gt;&#10;                                            currentHeading = newHeading&#10;                                            onPan(newHeading.toFloat())&#10;                                        },&#10;                                        onPitchChange = { newPitch -&gt;&#10;                                            currentPitch = newPitch&#10;                                        }&#10;                                    )&#10;                                    dragAccumulator = Offset.Zero&#10;                                }&#10;                            ) { change, dragAmount -&gt;&#10;                                change.consume()&#10;                                dragAccumulator += dragAmount&#10;                            }&#10;                        }&#10;                ) {&#10;                    val canvasWidth = size.width&#10;                    val canvasHeight = size.height&#10;                    val imageWidth = imageBitmap.width&#10;                    val imageHeight = imageBitmap.height&#10;&#10;                    // Angepasste Skalierung für Zoom&#10;                    val baseScale = maxOf(&#10;                        canvasWidth / imageWidth.toFloat(),&#10;                        canvasHeight / imageHeight.toFloat()&#10;                    )&#10;&#10;                    // Zoom-Effekt durch FOV-Simulation&#10;                    val zoomFactor = 90f / currentZoom // Inverse FOV für Zoom&#10;                    val finalScale = baseScale * zoomFactor&#10;&#10;                    val scaledWidth = imageWidth * finalScale&#10;                    val scaledHeight = imageHeight * finalScale&#10;&#10;                    // Zentriere das Bild mit Zoom-Offset&#10;                    val offsetX = (canvasWidth - scaledWidth) / 2&#10;                    val offsetY = (canvasHeight - scaledHeight) / 2&#10;&#10;                    // Zeichne mit Transform&#10;                    scale(zoomFactor) {&#10;                        translate(offsetX / zoomFactor, offsetY / zoomFactor) {&#10;                            drawImage(&#10;                                image = imageBitmap,&#10;                                dstSize = IntSize(&#10;                                    (imageWidth * baseScale).toInt(),&#10;                                    (imageHeight * baseScale).toInt()&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Loading Overlay während Navigation&#10;                if (isLoading) {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxSize()&#10;                            .align(Alignment.Center),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        CircularProgressIndicator()&#10;                    }&#10;                }&#10;&#10;                // Navigation HUD&#10;                StreetViewNavigationHUD(&#10;                    currentHeading = currentHeading,&#10;                    currentPitch = currentPitch,&#10;                    currentZoom = currentZoom,&#10;                    modifier = Modifier.align(Alignment.TopStart)&#10;                )&#10;            }&#10;            is AsyncImagePainter.State.Error -&gt; {&#10;                // Fallback für normale Bilder ohne Street View&#10;                NormalImageView(&#10;                    imageUrl = imageUrl,&#10;                    onPan = onPan,&#10;                    modifier = Modifier.fillMaxSize()&#10;                )&#10;            }&#10;            else -&gt; {}&#10;        }&#10;    }&#10;}&#10;&#10;// Data Classes für Navigation&#10;data class StreetViewLocation(&#10;    val latitude: Double,&#10;    val longitude: Double&#10;)&#10;&#10;data class TransformState(&#10;    val scale: Float = 1f,&#10;    val offsetX: Float = 0f,&#10;    val offsetY: Float = 0f&#10;)&#10;&#10;// Street View URL Builder mit erweiterten Parametern&#10;private fun buildStreetViewUrl(&#10;    baseUrl: String,&#10;    location: StreetViewLocation,&#10;    heading: Int,&#10;    pitch: Int,&#10;    fov: Int&#10;): String {&#10;    return if (baseUrl.contains(&quot;maps.googleapis.com/maps/api/streetview&quot;)) {&#10;        // Extrahiere API Key&#10;        val apiKeyMatch = Regex(&quot;key=([^&amp;]+)&quot;).find(baseUrl)&#10;        val apiKey = apiKeyMatch?.groupValues?.get(1) ?: &quot;&quot;&#10;&#10;        &quot;https://maps.googleapis.com/maps/api/streetview?&quot; +&#10;                &quot;size=800x600&quot; +&#10;                &quot;&amp;location=${location.latitude},${location.longitude}&quot; +&#10;                &quot;&amp;heading=$heading&quot; +&#10;                &quot;&amp;pitch=$pitch&quot; +&#10;                &quot;&amp;fov=$fov&quot; +&#10;                &quot;&amp;key=$apiKey&quot;&#10;    } else {&#10;        baseUrl // Fallback für normale Bilder&#10;    }&#10;}&#10;&#10;// Extrahiert Location aus einer Street View URL&#10;private fun extractLocationFromUrl(url: String): StreetViewLocation {&#10;    val locationMatch = Regex(&quot;location=([^&amp;]+)&quot;).find(url)&#10;    return if (locationMatch != null) {&#10;        val coords = locationMatch.groupValues[1].split(&quot;,&quot;)&#10;        if (coords.size &gt;= 2) {&#10;            StreetViewLocation(&#10;                latitude = coords[0].toDoubleOrNull() ?: 48.8566,&#10;                longitude = coords[1].toDoubleOrNull() ?: 2.3522&#10;            )&#10;        } else {&#10;            StreetViewLocation(48.8566, 2.3522) // Paris fallback&#10;        }&#10;    } else {&#10;        StreetViewLocation(48.8566, 2.3522) // Paris fallback&#10;    }&#10;}&#10;&#10;// Bewegung in Street View simulieren&#10;private suspend fun moveForward(&#10;    currentLocation: StreetViewLocation,&#10;    heading: Int,&#10;    stepSize: Double, // in Metern&#10;    onLocationChanged: (StreetViewLocation) -&gt; Unit&#10;) {&#10;    // Konvertiere Heading zu Radiant&#10;    val headingRad = Math.toRadians(heading.toDouble())&#10;&#10;    // Berechne neue Position (vereinfachte Bewegung)&#10;    val earthRadius = 6371000.0 // Meter&#10;    val deltaLat = stepSize * cos(headingRad) / earthRadius * (180.0 / Math.PI)&#10;    val deltaLng = stepSize * sin(headingRad) / (earthRadius * cos(Math.toRadians(currentLocation.latitude))) * (180.0 / Math.PI)&#10;&#10;    val newLocation = StreetViewLocation(&#10;        latitude = currentLocation.latitude + deltaLat,&#10;        longitude = currentLocation.longitude + deltaLng&#10;    )&#10;&#10;    onLocationChanged(newLocation)&#10;}&#10;&#10;// Behandle Drag-Gesten für Look-Around&#10;private fun handleDragEnd(&#10;    dragAccumulator: Offset,&#10;    onHeadingChange: (Int) -&gt; Unit,&#10;    onPitchChange: (Int) -&gt; Unit&#10;) {&#10;    val sensitivity = 0.5f&#10;&#10;    // Horizontaler Drag = Heading ändern (links/rechts schauen)&#10;    val headingChange = (dragAccumulator.x * sensitivity).toInt()&#10;    if (kotlin.math.abs(headingChange) &gt;= 5) {&#10;        val newHeading = (360 - headingChange + 360) % 360&#10;        onHeadingChange(newHeading)&#10;    }&#10;&#10;    // Vertikaler Drag = Pitch ändern (hoch/runter schauen)&#10;    val pitchChange = (dragAccumulator.y * sensitivity * -1).toInt() // Invertiert&#10;    if (kotlin.math.abs(pitchChange) &gt;= 5) {&#10;        val newPitch = (pitchChange).coerceIn(-90, 90)&#10;        onPitchChange(newPitch)&#10;    }&#10;}&#10;&#10;// Navigation HUD Component&#10;@Composable&#10;private fun StreetViewNavigationHUD(&#10;    currentHeading: Int,&#10;    currentPitch: Int,&#10;    currentZoom: Float,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    // Debug/Info Overlay (kann später entfernt werden)&#10;    androidx.compose.material3.Card(&#10;        modifier = modifier.androidx.compose.foundation.layout.padding(8.dp),&#10;        colors = androidx.compose.material3.CardDefaults.cardColors(&#10;            containerColor = androidx.compose.material3.MaterialTheme.colorScheme.surface.copy(alpha = 0.8f)&#10;        )&#10;    ) {&#10;        androidx.compose.foundation.layout.Column(&#10;            modifier = androidx.compose.foundation.layout.Modifier.androidx.compose.foundation.layout.padding(8.dp)&#10;        ) {&#10;            androidx.compose.material3.Text(&#10;                text = &quot;Richtung: ${currentHeading}°&quot;,&#10;                style = androidx.compose.material3.MaterialTheme.typography.bodySmall&#10;            )&#10;            androidx.compose.material3.Text(&#10;                text = &quot;Neigung: ${currentPitch}°&quot;,&#10;                style = androidx.compose.material3.MaterialTheme.typography.bodySmall&#10;            )&#10;            androidx.compose.material3.Text(&#10;                text = &quot;Zoom: ${currentZoom.toInt()}°&quot;,&#10;                style = androidx.compose.material3.MaterialTheme.typography.bodySmall&#10;            )&#10;            androidx.compose.material3.Text(&#10;                text = &quot; Tippen = Vorwärts&quot;,&#10;                style = androidx.compose.material3.MaterialTheme.typography.bodySmall&#10;            )&#10;            androidx.compose.material3.Text(&#10;                text = &quot; Ziehen = Umschauen&quot;,&#10;                style = androidx.compose.material3.MaterialTheme.typography.bodySmall&#10;            )&#10;            androidx.compose.material3.Text(&#10;                text = &quot; Kneifen = Zoom&quot;,&#10;                style = androidx.compose.material3.MaterialTheme.typography.bodySmall&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun NormalImageView(&#10;    imageUrl: String,&#10;    onPan: (Float) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val painter = rememberAsyncImagePainter(&#10;        model = ImageRequest.Builder(LocalContext.current)&#10;            .data(imageUrl)&#10;            .crossfade(true)&#10;            .build()&#10;    )&#10;&#10;    var offsetX by remember { mutableFloatStateOf(0f) }&#10;&#10;    when (painter.state) {&#10;        is AsyncImagePainter.State.Success -&gt; {&#10;            val imageBitmap = (painter.state as AsyncImagePainter.State.Success).result.drawable.let {&#10;                (it as android.graphics.drawable.BitmapDrawable).bitmap&#10;            }.asImageBitmap()&#10;&#10;            Canvas(&#10;                modifier = modifier&#10;                    .pointerInput(Unit) {&#10;                        detectDragGestures { change, dragAmount -&gt;&#10;                            change.consume()&#10;                            offsetX += dragAmount.x&#10;                            onPan(dragAmount.x)&#10;                        }&#10;                    }&#10;            ) {&#10;                val canvasWidth = size.width&#10;                val canvasHeight = size.height&#10;                val imageWidth = imageBitmap.width&#10;                val imageHeight = imageBitmap.height&#10;&#10;                val scale = canvasHeight / imageHeight.toFloat()&#10;                val scaledWidth = imageWidth * scale&#10;                val wrappedOffsetX = offsetX.mod(scaledWidth)&#10;&#10;                drawImage(&#10;                    image = imageBitmap,&#10;                    dstOffset = IntOffset(wrappedOffsetX.toInt(), 0),&#10;                    dstSize = IntSize(scaledWidth.toInt(), canvasHeight.toInt())&#10;                )&#10;&#10;                if (wrappedOffsetX &gt; 0) {&#10;                    drawImage(&#10;                        image = imageBitmap,&#10;                        dstOffset = IntOffset((wrappedOffsetX - scaledWidth).toInt(), 0),&#10;                        dstSize = IntSize(scaledWidth.toInt(), canvasHeight.toInt())&#10;                    )&#10;                } else {&#10;                    drawImage(&#10;                        image = imageBitmap,&#10;                        dstOffset = IntOffset((wrappedOffsetX + scaledWidth).toInt(), 0),&#10;                        dstSize = IntSize(scaledWidth.toInt(), canvasHeight.toInt())&#10;                    )&#10;                }&#10;            }&#10;        }&#10;        is AsyncImagePainter.State.Loading -&gt; {&#10;            Box(&#10;                modifier = modifier,&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                CircularProgressIndicator()&#10;            }&#10;        }&#10;        else -&gt; {&#10;            // Error handling&#10;        }&#10;    }&#10;}&#10;&#10;// Helfer für Modulo-Operation bei Floats&#10;fun Float.mod(other: Float): Float {&#10;    return ((this % other) + other) % other&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.geogeusserclone.ui.components&#10;&#10;import androidx.compose.foundation.Canvas&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.gestures.detectTapGestures&#10;import androidx.compose.foundation.gestures.detectTransformGestures&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.ui.graphics.asImageBitmap&#10;import androidx.compose.ui.graphics.drawscope.scale&#10;import androidx.compose.ui.graphics.drawscope.translate&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.unit.IntSize&#10;import androidx.compose.ui.unit.dp&#10;import coil.compose.AsyncImagePainter&#10;import coil.compose.rememberAsyncImagePainter&#10;import coil.request.ImageRequest&#10;import kotlinx.coroutines.launch&#10;import kotlin.math.cos&#10;import kotlin.math.sin&#10;&#10;@Composable&#10;fun InteractiveStreetView(&#10;    imageUrl: String,&#10;    modifier: Modifier = Modifier,&#10;    onPan: (Float) -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val scope = rememberCoroutineScope()&#10;&#10;    // Street View Navigation State&#10;    var currentHeading by remember { mutableIntStateOf(0) }&#10;    var currentPitch by remember { mutableIntStateOf(0) } // Für Hoch/Runter schauen&#10;    var currentZoom by remember { mutableFloatStateOf(90f) } // FOV (Field of View)&#10;    var currentLocation by remember { mutableStateOf(extractLocationFromUrl(imageUrl)) }&#10;&#10;    // Gesture State&#10;    var dragAccumulator by remember { mutableStateOf(Offset.Zero) }&#10;    var isLoading by remember { mutableStateOf(false) }&#10;    var transformationState by remember { mutableStateOf(TransformState()) }&#10;&#10;    // Berechne die Street View URL mit allen Parametern&#10;    val streetViewUrl = remember(imageUrl, currentHeading, currentPitch, currentZoom, currentLocation) {&#10;        buildStreetViewUrl(&#10;            baseUrl = imageUrl,&#10;            location = currentLocation,&#10;            heading = currentHeading,&#10;            pitch = currentPitch,&#10;            fov = currentZoom.toInt()&#10;        )&#10;    }&#10;&#10;    val painter = rememberAsyncImagePainter(&#10;        model = ImageRequest.Builder(context)&#10;            .data(streetViewUrl)&#10;            .crossfade(true)&#10;            .size(coil.size.Size.ORIGINAL)&#10;            .build()&#10;    )&#10;&#10;    Box(modifier = modifier.fillMaxSize()) {&#10;        when (painter.state) {&#10;            is AsyncImagePainter.State.Loading -&gt; {&#10;                CircularProgressIndicator(modifier = Modifier.align(Alignment.Center))&#10;            }&#10;            is AsyncImagePainter.State.Success -&gt; {&#10;                val imageBitmap = (painter.state as AsyncImagePainter.State.Success).result.drawable.let {&#10;                    (it as android.graphics.drawable.BitmapDrawable).bitmap&#10;                }.asImageBitmap()&#10;&#10;                Canvas(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .pointerInput(Unit) {&#10;                            // Multi-Touch Gesture Detection&#10;                            detectTransformGestures(&#10;                                onGesture = { _, pan, zoom, _ -&gt;&#10;                                    // Zoom (Pinch) Gesture&#10;                                    if (zoom != 1f) {&#10;                                        currentZoom = (currentZoom / zoom).coerceIn(20f, 120f)&#10;                                    }&#10;&#10;                                    // Pan Gesture für Look-Around&#10;                                    if (pan != Offset.Zero) {&#10;                                        dragAccumulator += pan&#10;                                    }&#10;                                }&#10;                            )&#10;                        }&#10;                        .pointerInput(Unit) {&#10;                            // Tap Gesture für Movement&#10;                            detectTapGestures(&#10;                                onTap = { offset -&gt;&#10;                                    scope.launch {&#10;                                        moveForward(&#10;                                            currentLocation = currentLocation,&#10;                                            heading = currentHeading,&#10;                                            stepSize = 10.0 // Meter&#10;                                        ) { newLocation -&gt;&#10;                                            currentLocation = newLocation&#10;                                            isLoading = true&#10;                                            // Reset nach Bewegung&#10;                                            scope.launch {&#10;                                                kotlinx.coroutines.delay(1000)&#10;                                                isLoading = false&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                }&#10;                            )&#10;                        }&#10;                        .pointerInput(Unit) {&#10;                            // Separate Drag Detection für Präzise Kontrolle&#10;                            detectDragGestures(&#10;                                onDragEnd = {&#10;                                    handleDragEnd(&#10;                                        dragAccumulator = dragAccumulator,&#10;                                        onHeadingChange = { newHeading -&gt;&#10;                                            currentHeading = newHeading&#10;                                            onPan(newHeading.toFloat())&#10;                                        },&#10;                                        onPitchChange = { newPitch -&gt;&#10;                                            currentPitch = newPitch&#10;                                        }&#10;                                    )&#10;                                    dragAccumulator = Offset.Zero&#10;                                }&#10;                            ) { change, dragAmount -&gt;&#10;                                change.consume()&#10;                                dragAccumulator += dragAmount&#10;                            }&#10;                        }&#10;                ) {&#10;                    val canvasWidth = size.width&#10;                    val canvasHeight = size.height&#10;                    val imageWidth = imageBitmap.width&#10;                    val imageHeight = imageBitmap.height&#10;&#10;                    // Angepasste Skalierung für Zoom&#10;                    val baseScale = maxOf(&#10;                        canvasWidth / imageWidth.toFloat(),&#10;                        canvasHeight / imageHeight.toFloat()&#10;                    )&#10;&#10;                    // Zoom-Effekt durch FOV-Simulation&#10;                    val zoomFactor = 90f / currentZoom // Inverse FOV für Zoom&#10;                    val finalScale = baseScale * zoomFactor&#10;&#10;                    val scaledWidth = imageWidth * finalScale&#10;                    val scaledHeight = imageHeight * finalScale&#10;&#10;                    // Zentriere das Bild mit Zoom-Offset&#10;                    val offsetX = (canvasWidth - scaledWidth) / 2&#10;                    val offsetY = (canvasHeight - scaledHeight) / 2&#10;&#10;                    // Zeichne mit Transform&#10;                    scale(zoomFactor) {&#10;                        translate(offsetX / zoomFactor, offsetY / zoomFactor) {&#10;                            drawImage(&#10;                                image = imageBitmap,&#10;                                dstSize = IntSize(&#10;                                    (imageWidth * baseScale).toInt(),&#10;                                    (imageHeight * baseScale).toInt()&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Loading Overlay während Navigation&#10;                if (isLoading) {&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxSize()&#10;                            .align(Alignment.Center),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        CircularProgressIndicator()&#10;                    }&#10;                }&#10;&#10;                // Navigation HUD&#10;                StreetViewNavigationHUD(&#10;                    currentHeading = currentHeading,&#10;                    currentPitch = currentPitch,&#10;                    currentZoom = currentZoom,&#10;                    modifier = Modifier.align(Alignment.TopStart)&#10;                )&#10;            }&#10;            is AsyncImagePainter.State.Error -&gt; {&#10;                // Fallback für normale Bilder ohne Street View&#10;                NormalImageView(&#10;                    imageUrl = imageUrl,&#10;                    onPan = onPan,&#10;                    modifier = Modifier.fillMaxSize()&#10;                )&#10;            }&#10;            else -&gt; {}&#10;        }&#10;    }&#10;}&#10;&#10;// Data Classes für Navigation&#10;data class StreetViewLocation(&#10;    val latitude: Double,&#10;    val longitude: Double&#10;)&#10;&#10;data class TransformState(&#10;    val scale: Float = 1f,&#10;    val offsetX: Float = 0f,&#10;    val offsetY: Float = 0f&#10;)&#10;&#10;// Street View URL Builder mit erweiterten Parametern&#10;private fun buildStreetViewUrl(&#10;    baseUrl: String,&#10;    location: StreetViewLocation,&#10;    heading: Int,&#10;    pitch: Int,&#10;    fov: Int&#10;): String {&#10;    return if (baseUrl.contains(&quot;maps.googleapis.com/maps/api/streetview&quot;)) {&#10;        // Extrahiere API Key&#10;        val apiKeyMatch = Regex(&quot;key=([^&amp;]+)&quot;).find(baseUrl)&#10;        val apiKey = apiKeyMatch?.groupValues?.get(1) ?: &quot;&quot;&#10;&#10;        &quot;https://maps.googleapis.com/maps/api/streetview?&quot; +&#10;                &quot;size=800x600&quot; +&#10;                &quot;&amp;location=${location.latitude},${location.longitude}&quot; +&#10;                &quot;&amp;heading=$heading&quot; +&#10;                &quot;&amp;pitch=$pitch&quot; +&#10;                &quot;&amp;fov=$fov&quot; +&#10;                &quot;&amp;key=$apiKey&quot;&#10;    } else {&#10;        baseUrl // Fallback für normale Bilder&#10;    }&#10;}&#10;&#10;// Extrahiert Location aus einer Street View URL&#10;private fun extractLocationFromUrl(url: String): StreetViewLocation {&#10;    val locationMatch = Regex(&quot;location=([^&amp;]+)&quot;).find(url)&#10;    return if (locationMatch != null) {&#10;        val coords = locationMatch.groupValues[1].split(&quot;,&quot;)&#10;        if (coords.size &gt;= 2) {&#10;            StreetViewLocation(&#10;                latitude = coords[0].toDoubleOrNull() ?: 48.8566,&#10;                longitude = coords[1].toDoubleOrNull() ?: 2.3522&#10;            )&#10;        } else {&#10;            StreetViewLocation(48.8566, 2.3522) // Paris fallback&#10;        }&#10;    } else {&#10;        StreetViewLocation(48.8566, 2.3522) // Paris fallback&#10;    }&#10;}&#10;&#10;// Bewegung in Street View simulieren&#10;private suspend fun moveForward(&#10;    currentLocation: StreetViewLocation,&#10;    heading: Int,&#10;    stepSize: Double, // in Metern&#10;    onLocationChanged: (StreetViewLocation) -&gt; Unit&#10;) {&#10;    // Konvertiere Heading zu Radiant&#10;    val headingRad = Math.toRadians(heading.toDouble())&#10;&#10;    // Berechne neue Position (vereinfachte Bewegung)&#10;    val earthRadius = 6371000.0 // Meter&#10;    val deltaLat = stepSize * cos(headingRad) / earthRadius * (180.0 / Math.PI)&#10;    val deltaLng = stepSize * sin(headingRad) / (earthRadius * cos(Math.toRadians(currentLocation.latitude))) * (180.0 / Math.PI)&#10;&#10;    val newLocation = StreetViewLocation(&#10;        latitude = currentLocation.latitude + deltaLat,&#10;        longitude = currentLocation.longitude + deltaLng&#10;    )&#10;&#10;    onLocationChanged(newLocation)&#10;}&#10;&#10;// Behandle Drag-Gesten für Look-Around&#10;private fun handleDragEnd(&#10;    dragAccumulator: Offset,&#10;    onHeadingChange: (Int) -&gt; Unit,&#10;    onPitchChange: (Int) -&gt; Unit&#10;) {&#10;    val sensitivity = 0.5f&#10;&#10;    // Horizontaler Drag = Heading ändern (links/rechts schauen)&#10;    val headingChange = (dragAccumulator.x * sensitivity).toInt()&#10;    if (kotlin.math.abs(headingChange) &gt;= 5) {&#10;        val newHeading = (360 - headingChange + 360) % 360&#10;        onHeadingChange(newHeading)&#10;    }&#10;&#10;    // Vertikaler Drag = Pitch ändern (hoch/runter schauen)&#10;    val pitchChange = (dragAccumulator.y * sensitivity * -1).toInt() // Invertiert&#10;    if (kotlin.math.abs(pitchChange) &gt;= 5) {&#10;        val newPitch = (pitchChange).coerceIn(-90, 90)&#10;        onPitchChange(newPitch)&#10;    }&#10;}&#10;&#10;// Navigation HUD Component&#10;@Composable&#10;private fun StreetViewNavigationHUD(&#10;    currentHeading: Int,&#10;    currentPitch: Int,&#10;    currentZoom: Float,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    // Debug/Info Overlay (kann später entfernt werden)&#10;    Card(&#10;        modifier = modifier.padding(8.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.8f)&#10;        )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(8.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot;Richtung: ${currentHeading}°&quot;,&#10;                style = MaterialTheme.typography.bodySmall&#10;            )&#10;            Text(&#10;                text = &quot;Neigung: ${currentPitch}°&quot;,&#10;                style = MaterialTheme.typography.bodySmall&#10;            )&#10;            Text(&#10;                text = &quot;Zoom: ${currentZoom.toInt()}°&quot;,&#10;                style = MaterialTheme.typography.bodySmall&#10;            )&#10;            Text(&#10;                text = &quot; Tippen = Vorwärts&quot;,&#10;                style = MaterialTheme.typography.bodySmall&#10;            )&#10;            Text(&#10;                text = &quot; Ziehen = Umschauen&quot;,&#10;                style = MaterialTheme.typography.bodySmall&#10;            )&#10;            Text(&#10;                text = &quot; Kneifen = Zoom&quot;,&#10;                style = MaterialTheme.typography.bodySmall&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun NormalImageView(&#10;    imageUrl: String,&#10;    onPan: (Float) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val painter = rememberAsyncImagePainter(&#10;        model = ImageRequest.Builder(LocalContext.current)&#10;            .data(imageUrl)&#10;            .crossfade(true)&#10;            .build()&#10;    )&#10;&#10;    var offsetX by remember { mutableFloatStateOf(0f) }&#10;&#10;    when (painter.state) {&#10;        is AsyncImagePainter.State.Success -&gt; {&#10;            val imageBitmap = (painter.state as AsyncImagePainter.State.Success).result.drawable.let {&#10;                (it as android.graphics.drawable.BitmapDrawable).bitmap&#10;            }.asImageBitmap()&#10;&#10;            Canvas(&#10;                modifier = modifier&#10;                    .pointerInput(Unit) {&#10;                        detectDragGestures { change, dragAmount -&gt;&#10;                            change.consume()&#10;                            offsetX += dragAmount.x&#10;                            onPan(dragAmount.x)&#10;                        }&#10;                    }&#10;            ) {&#10;                val canvasWidth = size.width&#10;                val canvasHeight = size.height&#10;                val imageWidth = imageBitmap.width&#10;                val imageHeight = imageBitmap.height&#10;&#10;                val scale = canvasHeight / imageHeight.toFloat()&#10;                val scaledWidth = imageWidth * scale&#10;                val wrappedOffsetX = offsetX.mod(scaledWidth)&#10;&#10;                drawImage(&#10;                    image = imageBitmap,&#10;                    dstOffset = IntOffset(wrappedOffsetX.toInt(), 0),&#10;                    dstSize = IntSize(scaledWidth.toInt(), canvasHeight.toInt())&#10;                )&#10;&#10;                if (wrappedOffsetX &gt; 0) {&#10;                    drawImage(&#10;                        image = imageBitmap,&#10;                        dstOffset = IntOffset((wrappedOffsetX - scaledWidth).toInt(), 0),&#10;                        dstSize = IntSize(scaledWidth.toInt(), canvasHeight.toInt())&#10;                    )&#10;                } else {&#10;                    drawImage(&#10;                        image = imageBitmap,&#10;                        dstOffset = IntOffset((wrappedOffsetX + scaledWidth).toInt(), 0),&#10;                        dstSize = IntSize(scaledWidth.toInt(), canvasHeight.toInt())&#10;                    )&#10;                }&#10;            }&#10;        }&#10;        is AsyncImagePainter.State.Loading -&gt; {&#10;            Box(&#10;                modifier = modifier,&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                CircularProgressIndicator()&#10;            }&#10;        }&#10;        else -&gt; {&#10;            // Error handling&#10;        }&#10;    }&#10;}&#10;&#10;// Helfer für Modulo-Operation bei Floats&#10;fun Float.mod(other: Float): Float {&#10;    return ((this % other) + other) % other&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/ui/components/LocationImageScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/ui/components/LocationImageScreen.kt" />
              <option name="originalContent" value="package com.example.geogeusserclone.ui.components&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Place&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import coil.compose.AsyncImage&#10;import coil.request.ImageRequest&#10;import com.example.geogeusserclone.data.database.entities.LocationEntity&#10;import com.example.geogeusserclone.utils.MemoryManager&#10;&#10;@Composable&#10;fun LocationImageScreen(&#10;    location: LocationEntity,&#10;    timeRemaining: Long,&#10;    onShowMap: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;&#10;    // Automatisches Memory Management&#10;    MemoryManager.AutoMemoryManagement(context)&#10;&#10;    Box(&#10;        modifier = Modifier.fillMaxSize()&#10;    ) {&#10;        // Street View Image / Fallback Image&#10;        AsyncImage(&#10;            model = ImageRequest.Builder(context)&#10;                .data(location.imageUrl)&#10;                .crossfade(true)&#10;                .build(),&#10;            contentDescription = &quot;Location Image - ${location.city}, ${location.country}&quot;,&#10;            modifier = Modifier.fillMaxSize(),&#10;            contentScale = ContentScale.Crop,&#10;            error = androidx.compose.ui.res.painterResource(&#10;                android.R.drawable.ic_menu_gallery&#10;            )&#10;        )&#10;&#10;        // Gradient Overlay für bessere Lesbarkeit&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(&#10;                    Brush.verticalGradient(&#10;                        colors = listOf(&#10;                            Color.Transparent,&#10;                            Color.Black.copy(alpha = 0.3f)&#10;                        ),&#10;                        startY = 0f,&#10;                        endY = Float.POSITIVE_INFINITY&#10;                    )&#10;                )&#10;        )&#10;&#10;        // Time Remaining Indicator&#10;        Card(&#10;            modifier = Modifier&#10;                .align(Alignment.TopEnd)&#10;                .padding(16.dp),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.primaryContainer.copy(alpha = 0.9f)&#10;            )&#10;        ) {&#10;            Text(&#10;                text = formatTime(timeRemaining),&#10;                modifier = Modifier.padding(12.dp),&#10;                style = MaterialTheme.typography.titleMedium,&#10;                fontWeight = FontWeight.Bold,&#10;                color = if (timeRemaining &lt; 30000) Color.Red else MaterialTheme.colorScheme.onPrimaryContainer&#10;            )&#10;        }&#10;&#10;        // Location Info (nur wenn verfügbar)&#10;        if (!location.city.isNullOrBlank() || !location.country.isNullOrBlank()) {&#10;            Card(&#10;                modifier = Modifier&#10;                    .align(Alignment.TopStart)&#10;                    .padding(16.dp),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.surfaceContainer.copy(alpha = 0.9f)&#10;                )&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(12.dp)&#10;                ) {&#10;                    location.city?.let { city -&gt;&#10;                        Text(&#10;                            text = &quot;Hinweis: $city&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            fontWeight = FontWeight.Medium&#10;                        )&#10;                    }&#10;                    location.country?.let { country -&gt;&#10;                        Text(&#10;                            text = country,&#10;                            style = MaterialTheme.typography.bodySmall,&#10;                            color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Difficulty Indicator&#10;        Card(&#10;            modifier = Modifier&#10;                .align(Alignment.TopCenter)&#10;                .padding(16.dp),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = getDifficultyColor(location.difficulty).copy(alpha = 0.9f)&#10;            )&#10;        ) {&#10;            Text(&#10;                text = &quot;Schwierigkeit: ${getDifficultyText(location.difficulty)}&quot;,&#10;                modifier = Modifier.padding(8.dp, 4.dp),&#10;                style = MaterialTheme.typography.bodySmall,&#10;                fontWeight = FontWeight.Bold,&#10;                color = Color.White&#10;            )&#10;        }&#10;&#10;        // Bottom Action Button&#10;        FloatingActionButton(&#10;            onClick = onShowMap,&#10;            modifier = Modifier&#10;                .align(Alignment.BottomEnd)&#10;                .padding(24.dp),&#10;            containerColor = MaterialTheme.colorScheme.primary&#10;        ) {&#10;            Icon(&#10;                Icons.Default.Place,&#10;                contentDescription = &quot;Karte öffnen&quot;,&#10;                tint = Color.White&#10;            )&#10;        }&#10;&#10;        // Instruction Text für neue Spieler&#10;        Card(&#10;            modifier = Modifier&#10;                .align(Alignment.BottomStart)&#10;                .padding(24.dp),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.9f)&#10;            )&#10;        ) {&#10;            Text(&#10;                text = &quot;️ Tippe auf die Karte, um deinen Tipp abzugeben&quot;,&#10;                modifier = Modifier.padding(12.dp),&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                fontWeight = FontWeight.Medium&#10;            )&#10;        }&#10;&#10;        // Loading Indicator für langsame Bilder&#10;        if (location.imageUrl.isBlank()) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .background(MaterialTheme.colorScheme.surfaceVariant),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Column(&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    CircularProgressIndicator()&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                    Text(&#10;                        text = &quot;Lade Location...&quot;,&#10;                        style = MaterialTheme.typography.bodyLarge&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;private fun formatTime(timeMs: Long): String {&#10;    val totalSeconds = timeMs / 1000&#10;    val minutes = totalSeconds / 60&#10;    val seconds = totalSeconds % 60&#10;    return String.format(&quot;%d:%02d&quot;, minutes, seconds)&#10;}&#10;&#10;private fun getDifficultyColor(difficulty: Int): Color {&#10;    return when (difficulty) {&#10;        1 -&gt; Color(0xFF4CAF50) // Grün - Einfach&#10;        2 -&gt; Color(0xFFFFC107) // Gelb - Mittel&#10;        3 -&gt; Color(0xFFFF9800) // Orange - Schwer&#10;        4 -&gt; Color(0xFFFF5722) // Rot-Orange - Sehr schwer&#10;        5 -&gt; Color(0xFFF44336) // Rot - Extrem&#10;        else -&gt; Color(0xFF9E9E9E) // Grau - Unbekannt&#10;    }&#10;}&#10;&#10;private fun getDifficultyText(difficulty: Int): String {&#10;    return when (difficulty) {&#10;        1 -&gt; &quot;Einfach&quot;&#10;        2 -&gt; &quot;Mittel&quot;&#10;        3 -&gt; &quot;Schwer&quot;&#10;        4 -&gt; &quot;Sehr schwer&quot;&#10;        5 -&gt; &quot;Extrem&quot;&#10;        else -&gt; &quot;Unbekannt&quot;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.geogeusserclone.ui.components&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Place&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import coil.compose.AsyncImage&#10;import coil.request.ImageRequest&#10;import com.example.geogeusserclone.data.database.entities.LocationEntity&#10;import com.example.geogeusserclone.utils.MemoryManager&#10;&#10;@Composable&#10;fun LocationImageScreen(&#10;    location: LocationEntity,&#10;    timeRemaining: Long,&#10;    onShowMap: () -&gt; Unit,&#10;    onPan: (Float) -&gt; Unit // Hinzugefügt für die Interaktion&#10;) {&#10;    val context = LocalContext.current&#10;    var rotation by remember { mutableFloatStateOf(0f) }&#10;&#10;    // Automatisches Memory Management&#10;    MemoryManager.AutoMemoryManagement(context)&#10;&#10;    Box(&#10;        modifier = Modifier.fillMaxSize()&#10;    ) {&#10;        // Ersetze statisches Bild durch interaktive Street-View-Komponente&#10;        if (location.imageUrl.isNotBlank()) {&#10;            InteractiveStreetView(&#10;                imageUrl = location.imageUrl,&#10;                modifier = Modifier.fillMaxSize(),&#10;                onPan = { delta -&gt;&#10;                    rotation += delta&#10;                    onPan(delta)&#10;                }&#10;            )&#10;        } else {&#10;            // Behalte den Lade-Indikator für leere URLs&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .background(MaterialTheme.colorScheme.surfaceVariant),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Column(&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    CircularProgressIndicator()&#10;                    Spacer(modifier = Modifier.height(16.dp))&#10;                    Text(&#10;                        text = &quot;Lade Location...&quot;,&#10;                        style = MaterialTheme.typography.bodyLarge&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Gradient Overlay für bessere Lesbarkeit&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(&#10;                    Brush.verticalGradient(&#10;                        colors = listOf(&#10;                            Color.Transparent,&#10;                            Color.Black.copy(alpha = 0.3f)&#10;                        ),&#10;                        startY = 0f,&#10;                        endY = Float.POSITIVE_INFINITY&#10;                    )&#10;                )&#10;        )&#10;&#10;        // Time Remaining Indicator&#10;        Card(&#10;            modifier = Modifier&#10;                .align(Alignment.TopEnd)&#10;                .padding(16.dp),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.primaryContainer.copy(alpha = 0.9f)&#10;            )&#10;        ) {&#10;            Text(&#10;                text = formatTime(timeRemaining),&#10;                modifier = Modifier.padding(12.dp),&#10;                style = MaterialTheme.typography.titleMedium,&#10;                fontWeight = FontWeight.Bold,&#10;                color = if (timeRemaining &lt; 30000) Color.Red else MaterialTheme.colorScheme.onPrimaryContainer&#10;            )&#10;        }&#10;&#10;        // Location Info (nur wenn verfügbar)&#10;        if (!location.city.isNullOrBlank() || !location.country.isNullOrBlank()) {&#10;            Card(&#10;                modifier = Modifier&#10;                    .align(Alignment.TopStart)&#10;                    .padding(16.dp),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.surfaceContainer.copy(alpha = 0.9f)&#10;                )&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(12.dp)&#10;                ) {&#10;                    location.city?.let { city -&gt;&#10;                        Text(&#10;                            text = &quot;Hinweis: $city&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            fontWeight = FontWeight.Medium&#10;                        )&#10;                    }&#10;                    location.country?.let { country -&gt;&#10;                        Text(&#10;                            text = country,&#10;                            style = MaterialTheme.typography.bodySmall,&#10;                            color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Difficulty Indicator&#10;        Card(&#10;            modifier = Modifier&#10;                .align(Alignment.TopCenter)&#10;                .padding(16.dp),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = getDifficultyColor(location.difficulty).copy(alpha = 0.9f)&#10;            )&#10;        ) {&#10;            Text(&#10;                text = &quot;Schwierigkeit: ${getDifficultyText(location.difficulty)}&quot;,&#10;                modifier = Modifier.padding(8.dp, 4.dp),&#10;                style = MaterialTheme.typography.bodySmall,&#10;                fontWeight = FontWeight.Bold,&#10;                color = Color.White&#10;            )&#10;        }&#10;&#10;        // Bottom Action Button&#10;        FloatingActionButton(&#10;            onClick = onShowMap,&#10;            modifier = Modifier&#10;                .align(Alignment.BottomEnd)&#10;                .padding(24.dp),&#10;            containerColor = MaterialTheme.colorScheme.primary&#10;        ) {&#10;            Icon(&#10;                Icons.Default.Place,&#10;                contentDescription = &quot;Karte öffnen&quot;,&#10;                tint = Color.White&#10;            )&#10;        }&#10;&#10;        // Instruction Text für neue Spieler&#10;        Card(&#10;            modifier = Modifier&#10;                .align(Alignment.BottomStart)&#10;                .padding(24.dp),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.9f)&#10;            )&#10;        ) {&#10;            Text(&#10;                text = &quot;️ Tippe auf die Karte, um deinen Tipp abzugeben&quot;,&#10;                modifier = Modifier.padding(12.dp),&#10;                style = MaterialTheme.typography.bodyMedium,&#10;                fontWeight = FontWeight.Medium&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;private fun formatTime(timeMs: Long): String {&#10;    val totalSeconds = timeMs / 1000&#10;    val minutes = totalSeconds / 60&#10;    val seconds = totalSeconds % 60&#10;    return String.format(&quot;%d:%02d&quot;, minutes, seconds)&#10;}&#10;&#10;private fun getDifficultyColor(difficulty: Int): Color {&#10;    return when (difficulty) {&#10;        1 -&gt; Color(0xFF4CAF50) // Grün - Einfach&#10;        2 -&gt; Color(0xFFFFC107) // Gelb - Mittel&#10;        3 -&gt; Color(0xFFFF9800) // Orange - Schwer&#10;        4 -&gt; Color(0xFFFF5722) // Rot-Orange - Sehr schwer&#10;        5 -&gt; Color(0xFFF44336) // Rot - Extrem&#10;        else -&gt; Color(0xFF9E9E9E) // Grau - Unbekannt&#10;    }&#10;}&#10;&#10;private fun getDifficultyText(difficulty: Int): String {&#10;    return when (difficulty) {&#10;        1 -&gt; &quot;Einfach&quot;&#10;        2 -&gt; &quot;Mittel&quot;&#10;        3 -&gt; &quot;Schwer&quot;&#10;        4 -&gt; &quot;Sehr schwer&quot;&#10;        5 -&gt; &quot;Extrem&quot;&#10;        else -&gt; &quot;Unbekannt&quot;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/ui/components/MapViewScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/ui/components/MapViewScreen.kt" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/ui/components/RoundResultView.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/ui/components/RoundResultView.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.ui.components&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import com.example.geogeusserclone.data.database.entities.GuessEntity&#10;&#10;@Composable&#10;fun RoundResultView(&#10;    guess: GuessEntity?,&#10;    onNextRound: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    guess?.let { guessEntity -&gt;&#10;        Card(&#10;            modifier = modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(24.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.Center&#10;            ) {&#10;                Text(&#10;                    text = &quot;Rundenergebnis&quot;,&#10;                    style = MaterialTheme.typography.headlineMedium,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(24.dp))&#10;&#10;                Text(&#10;                    text = &quot;${guessEntity.score} Punkte&quot;,&#10;                    style = MaterialTheme.typography.displayMedium,&#10;                    color = MaterialTheme.colorScheme.primary,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                Text(&#10;                    text = &quot;Entfernung: ${&quot;%.1f&quot;.format(guessEntity.distance)} km&quot;,&#10;                    style = MaterialTheme.typography.titleMedium&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(32.dp))&#10;&#10;                Button(&#10;                    onClick = onNextRound,&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    Text(&quot;Weiter&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/ui/theme/Theme.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/ui/theme/Theme.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.ui.theme&#10;&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.lightColorScheme&#10;import androidx.compose.material3.darkColorScheme&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.foundation.isSystemInDarkTheme&#10;import androidx.compose.ui.graphics.Color&#10;&#10;private val LightColorScheme = lightColorScheme(&#10;    primary = Color(0xFF1976D2),&#10;    secondary = Color(0xFF03DAC6),&#10;    tertiary = Color(0xFF3700B3),&#10;    background = Color(0xFFFFFBFE),&#10;    surface = Color(0xFFFFFBFE),&#10;    onPrimary = Color.White,&#10;    onSecondary = Color.Black,&#10;    onTertiary = Color.White,&#10;    onBackground = Color(0xFF1C1B1F),&#10;    onSurface = Color(0xFF1C1B1F),&#10;)&#10;&#10;private val DarkColorScheme = darkColorScheme(&#10;    primary = Color(0xFF90CAF9),&#10;    secondary = Color(0xFF03DAC6),&#10;    tertiary = Color(0xFFBB86FC),&#10;    background = Color(0xFF121212),&#10;    surface = Color(0xFF121212),&#10;    onPrimary = Color.Black,&#10;    onSecondary = Color.Black,&#10;    onTertiary = Color.Black,&#10;    onBackground = Color(0xFFE1E2E1),&#10;    onSurface = Color(0xFFE1E2E1),&#10;)&#10;&#10;@Composable&#10;fun GeoGeusserCloneTheme(&#10;    darkTheme: Boolean = isSystemInDarkTheme(),&#10;    content: @Composable () -&gt; Unit&#10;) {&#10;    val colorScheme = if (darkTheme) {&#10;        DarkColorScheme&#10;    } else {&#10;        LightColorScheme&#10;    }&#10;&#10;    MaterialTheme(&#10;        colorScheme = colorScheme,&#10;        typography = androidx.compose.material3.Typography(),&#10;        content = content&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/utils/Constants.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/utils/Constants.kt" />
              <option name="originalContent" value="package com.example.geogeusserclone.utils&#10;&#10;object Constants {&#10;    // Backend Configuration - Dein Google Maps Backend&#10;    const val BASE_URL = &quot;http://10.0.2.2:3000/api/&quot; // Android Emulator&#10;    // Alternative für echtes Gerät: const val BASE_URL = &quot;http://YOUR_LOCAL_IP:3000/api/&quot;&#10;    // Production: const val BASE_URL = &quot;https://your-backend.com/api/&quot;&#10;&#10;    // Mapillary als Fallback (nur wenn Backend nicht verfügbar)&#10;    const val MAPILLARY_BASE_URL = &quot;https://graph.mapillary.com/&quot;&#10;    const val MAPILLARY_ACCESS_TOKEN = &quot;MLY|4142433049200173|72206abe5035850d6743b23a49c41333&quot;&#10;&#10;    const val CONNECT_TIMEOUT = 5L&#10;    const val READ_TIMEOUT = 10L&#10;    const val WRITE_TIMEOUT = 10L&#10;&#10;    // Backend-First Mode (Mapillary nur als Fallback)&#10;    const val ENABLE_OFFLINE_MODE = false // Backend verfügbar&#10;    const val BACKEND_FALLBACK_DELAY_MS = 3000L&#10;&#10;    // Game Configuration&#10;    const val MAX_ROUND_TIME_MS = 120000L // 2 Minuten&#10;    const val TIME_BONUS_MAX = 500&#10;&#10;    // Score Thresholds&#10;    const val PERFECT_DISTANCE_KM = 1.0&#10;    const val EXCELLENT_DISTANCE_KM = 10.0&#10;    const val GOOD_DISTANCE_KM = 50.0&#10;    const val FAIR_DISTANCE_KM = 200.0&#10;    const val POOR_DISTANCE_KM = 1000.0&#10;&#10;    // Cache Configuration&#10;    const val IMAGE_CACHE_SIZE_MB = 50L&#10;    const val MAP_TILE_CACHE_SIZE_MB = 100L&#10;    const val LOCATION_PRELOAD_COUNT = 10&#10;&#10;    // Performance Settings&#10;    const val ANIMATION_DURATION_MS = 300L&#10;    const val DEBOUNCE_DELAY_MS = 100L&#10;    const val MAP_ZOOM_MIN = 1.0&#10;    const val MAP_ZOOM_MAX = 19.0&#10;&#10;    // Background Work&#10;    const val LOCATION_PRELOAD_INTERVAL_HOURS = 2L&#10;    const val CACHE_CLEANUP_INTERVAL_HOURS = 24L&#10;&#10;    // UI Performance&#10;    const val LAZY_COLUMN_PREFETCH_COUNT = 3&#10;    const val IMAGE_CROSSFADE_DURATION = 200&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.geogeusserclone.utils&#10;&#10;object Constants {&#10;    // Backend Configuration - Dein Google Maps Backend&#10;    const val BASE_URL = &quot;http://10.0.2.2:3000/api/&quot; // Android Emulator&#10;    // Alternative für echtes Gerät: const val BASE_URL = &quot;http://YOUR_LOCAL_IP:3000/api/&quot;&#10;    // Production: const val BASE_URL = &quot;https://your-backend.com/api/&quot;&#10;&#10;    // Mapillary als Fallback (nur wenn Backend nicht verfügbar)&#10;    const val MAPILLARY_BASE_URL = &quot;https://graph.mapillary.com/&quot;&#10;    const val MAPILLARY_ACCESS_TOKEN = &quot;MLY|4142433049200173|72206abe5035850d6743b23a49c41333&quot;&#10;&#10;    // Network Timeouts angepasst an deine Spezifikation&#10;    const val CONNECT_TIMEOUT = 30L&#10;    const val READ_TIMEOUT = 30L&#10;    const val WRITE_TIMEOUT = 30L&#10;&#10;    // Backend-First Mode (Mapillary nur als Fallback)&#10;    const val ENABLE_OFFLINE_MODE = false // Backend verfügbar&#10;    const val BACKEND_FALLBACK_DELAY_MS = 5000L // Längerer Timeout für Backend&#10;&#10;    // Game Configuration&#10;    const val MAX_ROUND_TIME_MS = 120000L // 2 Minuten&#10;    const val TIME_BONUS_MAX = 500&#10;&#10;    // Score Thresholds&#10;    const val PERFECT_DISTANCE_KM = 1.0&#10;    const val EXCELLENT_DISTANCE_KM = 10.0&#10;    const val GOOD_DISTANCE_KM = 50.0&#10;    const val FAIR_DISTANCE_KM = 200.0&#10;    const val POOR_DISTANCE_KM = 1000.0&#10;&#10;    // Cache Configuration&#10;    const val IMAGE_CACHE_SIZE_MB = 50L&#10;    const val MAP_TILE_CACHE_SIZE_MB = 100L&#10;    const val LOCATION_PRELOAD_COUNT = 10&#10;&#10;    // Performance Settings&#10;    const val ANIMATION_DURATION_MS = 300L&#10;    const val DEBOUNCE_DELAY_MS = 100L&#10;    const val MAP_ZOOM_MIN = 1.0&#10;    const val MAP_ZOOM_MAX = 19.0&#10;&#10;    // Background Work&#10;    const val LOCATION_PRELOAD_INTERVAL_HOURS = 2L&#10;    const val CACHE_CLEANUP_INTERVAL_HOURS = 24L&#10;&#10;    // UI Performance&#10;    const val LAZY_COLUMN_PREFETCH_COUNT = 3&#10;    const val IMAGE_CROSSFADE_DURATION = 200&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/utils/EdgeToEdge.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/utils/EdgeToEdge.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.utils&#10;&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.enableEdgeToEdge as androidEnableEdgeToEdge&#10;&#10;fun ComponentActivity.enableEdgeToEdge() {&#10;    androidEnableEdgeToEdge()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/utils/MapCacheManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/utils/MapCacheManager.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.utils&#10;&#10;import android.content.Context&#10;import androidx.work.*&#10;import com.example.geogeusserclone.data.repositories.LocationCacheRepository&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#10;import java.util.concurrent.TimeUnit&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;/**&#10; * Background-Service für Map Tile Preloading&#10; */&#10;@Singleton&#10;class MapCacheManager @Inject constructor(&#10;    @ApplicationContext private val context: Context,&#10;    private val locationCacheRepository: LocationCacheRepository&#10;) {&#10;&#10;    /**&#10;     * Startet Background-Preloading von Map Tiles&#10;     */&#10;    fun startMapTilePreloading() {&#10;        val constraints = Constraints.Builder()&#10;            .setRequiredNetworkType(NetworkType.UNMETERED) // Nur WLAN&#10;            .setRequiresBatteryNotLow(true)&#10;            .setRequiresCharging(false)&#10;            .build()&#10;&#10;        val preloadWork = OneTimeWorkRequestBuilder&lt;MapTilePreloadWorker&gt;()&#10;            .setConstraints(constraints)&#10;            .setBackoffCriteria(&#10;                BackoffPolicy.EXPONENTIAL,&#10;                WorkRequest.MIN_BACKOFF_MILLIS,&#10;                TimeUnit.MILLISECONDS&#10;            )&#10;            .build()&#10;&#10;        WorkManager.getInstance(context)&#10;            .enqueueUniqueWork(&#10;                &quot;map_tile_preload&quot;,&#10;                ExistingWorkPolicy.KEEP,&#10;                preloadWork&#10;            )&#10;    }&#10;&#10;    /**&#10;     * Bereinigt alte Map Tiles bei Low Memory&#10;     */&#10;    fun cleanupOldTiles() {&#10;        val cleanupWork = OneTimeWorkRequestBuilder&lt;MapTileCleanupWorker&gt;()&#10;            .build()&#10;&#10;        WorkManager.getInstance(context)&#10;            .enqueue(cleanupWork)&#10;    }&#10;&#10;    /**&#10;     * Überwacht Map Performance Metriken&#10;     */&#10;    fun trackMapPerformance(&#10;        loadTime: Long,&#10;        tileCount: Int,&#10;        memoryUsage: Long&#10;    ) {&#10;        // Performance Tracking für Optimierungen&#10;        if (loadTime &gt; 3000) { // Über 3 Sekunden&#10;            // Trigger für Cache-Optimierung&#10;            cleanupOldTiles()&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Worker für Map Tile Preloading&#10; */&#10;class MapTilePreloadWorker(&#10;    context: Context,&#10;    params: WorkerParameters&#10;) : CoroutineWorker(context, params) {&#10;&#10;    override suspend fun doWork(): Result {&#10;        return try {&#10;            // Preload häufig verwendete Gebiete&#10;            preloadPopularRegions()&#10;            Result.success()&#10;        } catch (e: Exception) {&#10;            Result.retry()&#10;        }&#10;    }&#10;&#10;    private suspend fun preloadPopularRegions() {&#10;        val popularRegions = listOf(&#10;            Pair(54.5260, 15.2551), // Europa&#10;            Pair(39.8283, -98.5795), // USA&#10;            Pair(35.6762, 139.6503), // Tokyo&#10;            Pair(-33.8688, 151.2093) // Sydney&#10;        )&#10;&#10;        // Implementierung des Tile-Preloadings&#10;        // Dies würde die Tiles für diese Regionen im Cache speichern&#10;    }&#10;}&#10;&#10;/**&#10; * Worker für Map Cache Cleanup&#10; */&#10;class MapTileCleanupWorker(&#10;    context: Context,&#10;    params: WorkerParameters&#10;) : CoroutineWorker(context, params) {&#10;&#10;    override suspend fun doWork(): Result {&#10;        return try {&#10;            val cacheDir = applicationContext.cacheDir&#10;            val mapCacheDir = java.io.File(cacheDir, &quot;osmdroid&quot;)&#10;            &#10;            if (mapCacheDir.exists()) {&#10;                // Lösche Tiles älter als 7 Tage&#10;                val weekAgo = System.currentTimeMillis() - (7 * 24 * 60 * 60 * 1000)&#10;                &#10;                mapCacheDir.listFiles()?.forEach { file -&gt;&#10;                    if (file.lastModified() &lt; weekAgo) {&#10;                        file.delete()&#10;                    }&#10;                }&#10;            }&#10;            &#10;            Result.success()&#10;        } catch (e: Exception) {&#10;            Result.failure()&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/utils/MapPerformanceUtils.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/utils/MapPerformanceUtils.kt" />
              <option name="originalContent" value="package com.example.geogeusserclone.utils&#10;&#10;import android.content.Context&#10;import android.graphics.Bitmap&#10;import android.graphics.drawable.BitmapDrawable&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.core.content.ContextCompat&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import org.osmdroid.config.Configuration&#10;import org.osmdroid.tileprovider.MapTileProviderBasic&#10;import org.osmdroid.tileprovider.tilesource.ITileSource&#10;import org.osmdroid.tileprovider.tilesource.OnlineTileSourceBase&#10;import org.osmdroid.views.MapView&#10;import java.util.concurrent.Executors&#10;&#10;/**&#10; * Performance-optimierte Map Utilities&#10; */&#10;object MapPerformanceUtils {&#10;&#10;    /**&#10;     * Konfiguriert OSMDroid für optimale Performance&#10;     */&#10;    fun configureMapPerformance(context: Context) {&#10;        Configuration.getInstance().apply {&#10;            // Thread Pool Optimierung&#10;            val coreCount = Runtime.getRuntime().availableProcessors()&#10;            setTileFileSystemThreads(minOf(coreCount, 4).toShort())&#10;            setTileDownloadThreads(minOf(coreCount * 2, 8).toShort())&#10;&#10;            // Cache Optimierung basierend auf verfügbarem Speicher&#10;            val runtime = Runtime.getRuntime()&#10;            val maxMemory = runtime.maxMemory()&#10;            val cacheSize = (maxMemory / 8).coerceAtMost(100 * 1024 * 1024L) // Max 100MB&#10;&#10;            setTileFileSystemCacheMaxBytes(cacheSize)&#10;            setTileFileSystemCacheTrimBytes((cacheSize * 0.8).toLong())&#10;&#10;            // Performance Settings&#10;            setMapViewHardwareAccelerated(true)&#10;            setTileFileSystemMaxQueueSize(40)&#10;            setTileDownloadMaxQueueSize(20)&#10;&#10;            userAgentValue = &quot;GeoGuesserClone/1.0&quot;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Erstellt eine performance-optimierte Tile Source mit Load Balancing&#10;     */&#10;    fun createOptimizedTileSource(): OnlineTileSourceBase {&#10;        val urls = arrayOf(&#10;            &quot;https://a.tile.openstreetmap.org/&quot;,&#10;            &quot;https://b.tile.openstreetmap.org/&quot;,&#10;            &quot;https://c.tile.openstreetmap.org/&quot;&#10;        )&#10;&#10;        return object : OnlineTileSourceBase(&#10;            &quot;PerformanceMapnik&quot;,&#10;            1, 19, 256, &quot;.png&quot;,&#10;            urls&#10;        ) {&#10;            override fun getTileURLString(pMapTileIndex: Long): String {&#10;                val zoom = org.osmdroid.util.MapTileIndex.getZoom(pMapTileIndex)&#10;                val x = org.osmdroid.util.MapTileIndex.getX(pMapTileIndex)&#10;                val y = org.osmdroid.util.MapTileIndex.getY(pMapTileIndex)&#10;&#10;                // Load Balancing über mehrere Server&#10;                val serverIndex = ((x + y) % urls.size)&#10;                val baseUrl = urls[serverIndex]&#10;&#10;                return &quot;$baseUrl$zoom/$x/$y.png&quot;&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Memory-efficient Marker Icon Creation&#10;     */&#10;    suspend fun createOptimizedMarkerIcon(&#10;        context: Context,&#10;        resourceId: Int,&#10;        size: Int = 64&#10;    ): BitmapDrawable? = withContext(Dispatchers.IO) {&#10;        try {&#10;            val drawable = ContextCompat.getDrawable(context, resourceId)&#10;            if (drawable != null) {&#10;                val bitmap = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888)&#10;                val canvas = android.graphics.Canvas(bitmap)&#10;                drawable.setBounds(0, 0, size, size)&#10;                drawable.draw(canvas)&#10;                BitmapDrawable(context.resources, bitmap)&#10;            } else null&#10;        } catch (e: Exception) {&#10;            null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Optimiert MapView Settings für bessere Performance&#10;     */&#10;    fun optimizeMapView(mapView: MapView) {&#10;        mapView.apply {&#10;            // Hardware Acceleration&#10;            setLayerType(android.view.View.LAYER_TYPE_HARDWARE, null)&#10;&#10;            // Disable unnecessary features&#10;            isHorizontalMapRepetitionEnabled = false&#10;            isVerticalMapRepetitionEnabled = false&#10;&#10;            // Optimize tile scaling&#10;            isTilesScaledToDpi = true&#10;&#10;            // Set reasonable zoom limits&#10;            minZoomLevel = 1.0&#10;            maxZoomLevel = 19.0&#10;&#10;            // Optimize overlay rendering&#10;            overlayManager.tilesOverlay.setLoadingBackgroundColor(&#10;                android.graphics.Color.TRANSPARENT&#10;            )&#10;&#10;            // Animation settings werden übersprungen da nicht alle OSMDroid Versionen diese unterstützen&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Cleanup Map Resources&#10;     */&#10;    fun cleanupMapResources(mapView: MapView?) {&#10;        mapView?.let { map -&gt;&#10;            try {&#10;                map.onDetach()&#10;                map.overlays.clear()&#10;                map.tileProvider?.clearTileCache()&#10;            } catch (e: Exception) {&#10;                // Silent cleanup&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Pre-cache tiles für bessere Performance&#10;     */&#10;    suspend fun precacheTiles(&#10;        mapView: MapView,&#10;        centerLat: Double,&#10;        centerLng: Double,&#10;        radiusKm: Double = 100.0&#10;    ) = withContext(Dispatchers.IO) {&#10;        try {&#10;            val boundingBox = calculateBoundingBox(centerLat, centerLng, radiusKm)&#10;            // Pre-cache logic würde hier implementiert werden&#10;            // Dies ist eine vereinfachte Version&#10;        } catch (e: Exception) {&#10;            // Silent fail - App funktioniert weiter ohne Precaching&#10;        }&#10;    }&#10;&#10;    private fun calculateBoundingBox(&#10;        centerLat: Double,&#10;        centerLng: Double,&#10;        radiusKm: Double&#10;    ): org.osmdroid.util.BoundingBox {&#10;        val latOffset = radiusKm / 111.0 // Ungefähr 111km pro Grad&#10;        val lngOffset = radiusKm / (111.0 * kotlin.math.cos(Math.toRadians(centerLat)))&#10;&#10;        return org.osmdroid.util.BoundingBox(&#10;            centerLat + latOffset,&#10;            centerLng + lngOffset,&#10;            centerLat - latOffset,&#10;            centerLng - lngOffset&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * Composable für performance-bewusstes Map Setup&#10; */&#10;@Composable&#10;fun rememberOptimizedMapConfiguration(): Configuration {&#10;    val context = LocalContext.current&#10;&#10;    return remember {&#10;        Configuration.getInstance().also {&#10;            MapPerformanceUtils.configureMapPerformance(context)&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Performance-optimierte Map State Management&#10; */&#10;@Composable&#10;fun rememberMapState(&#10;    initialZoom: Double = 3.0,&#10;    initialCenter: org.osmdroid.util.GeoPoint = org.osmdroid.util.GeoPoint(20.0, 0.0)&#10;): MapState {&#10;    var zoom by remember { mutableDoubleStateOf(initialZoom) }&#10;    var center by remember { mutableStateOf(initialCenter) }&#10;    var isLoading by remember { mutableStateOf(false) }&#10;&#10;    return remember {&#10;        MapState(&#10;            zoom = zoom,&#10;            center = center,&#10;            isLoading = isLoading,&#10;            setZoom = { zoom = it },&#10;            setCenter = { center = it },&#10;            setLoading = { isLoading = it }&#10;        )&#10;    }&#10;}&#10;&#10;data class MapState(&#10;    val zoom: Double,&#10;    val center: org.osmdroid.util.GeoPoint,&#10;    val isLoading: Boolean,&#10;    val setZoom: (Double) -&gt; Unit,&#10;    val setCenter: (org.osmdroid.util.GeoPoint) -&gt; Unit,&#10;    val setLoading: (Boolean) -&gt; Unit&#10;)&#10;" />
              <option name="updatedContent" value="package com.example.geogeusserclone.utils&#10;&#10;import android.content.Context&#10;import android.graphics.Bitmap&#10;import android.graphics.drawable.BitmapDrawable&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.core.content.ContextCompat&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import org.osmdroid.config.Configuration&#10;import org.osmdroid.tileprovider.MapTileProviderBasic&#10;import org.osmdroid.tileprovider.tilesource.ITileSource&#10;import org.osmdroid.tileprovider.tilesource.OnlineTileSourceBase&#10;import org.osmdroid.views.MapView&#10;import java.util.concurrent.Executors&#10;&#10;/**&#10; * Performance-optimierte Map Utilities&#10; */&#10;object MapPerformanceUtils {&#10;&#10;    /**&#10;     * Konfiguriert OSMDroid für optimale Performance&#10;     */&#10;    fun configureMapPerformance(context: Context) {&#10;        Configuration.getInstance().apply {&#10;            // Thread Pool Optimierung&#10;            val coreCount = Runtime.getRuntime().availableProcessors()&#10;            setTileFileSystemThreads(minOf(coreCount, 4).toShort())&#10;            setTileDownloadThreads(minOf(coreCount * 2, 8).toShort())&#10;&#10;            // Cache Optimierung basierend auf verfügbarem Speicher&#10;            val runtime = Runtime.getRuntime()&#10;            val maxMemory = runtime.maxMemory()&#10;            val cacheSize = (maxMemory / 8).coerceAtMost(100 * 1024 * 1024L) // Max 100MB&#10;&#10;            setTileFileSystemCacheMaxBytes(cacheSize)&#10;            setTileFileSystemCacheTrimBytes((cacheSize * 0.8).toLong())&#10;&#10;            // Performance Settings&#10;            setMapViewHardwareAccelerated(true)&#10;            setTileFileSystemMaxQueueSize(40)&#10;            setTileDownloadMaxQueueSize(20)&#10;&#10;            userAgentValue = &quot;GeoGuesserClone/1.0&quot;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Erstellt eine performance-optimierte Tile Source mit Load Balancing&#10;     */&#10;    fun createOptimizedTileSource(): OnlineTileSourceBase {&#10;        val urls = arrayOf(&#10;            &quot;https://a.tile.openstreetmap.org/&quot;,&#10;            &quot;https://b.tile.openstreetmap.org/&quot;,&#10;            &quot;https://c.tile.openstreetmap.org/&quot;&#10;        )&#10;&#10;        return object : OnlineTileSourceBase(&#10;            &quot;PerformanceMapnik&quot;,&#10;            1, 19, 256, &quot;.png&quot;,&#10;            urls&#10;        ) {&#10;            override fun getTileURLString(pMapTileIndex: Long): String {&#10;                val zoom = org.osmdroid.util.MapTileIndex.getZoom(pMapTileIndex)&#10;                val x = org.osmdroid.util.MapTileIndex.getX(pMapTileIndex)&#10;                val y = org.osmdroid.util.MapTileIndex.getY(pMapTileIndex)&#10;&#10;                // Load Balancing über mehrere Server&#10;                val serverIndex = ((x + y) % urls.size)&#10;                val baseUrl = urls[serverIndex]&#10;&#10;                return &quot;$baseUrl$zoom/$x/$y.png&quot;&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Memory-efficient Marker Icon Creation&#10;     */&#10;    suspend fun createOptimizedMarkerIcon(&#10;        context: Context,&#10;        resourceId: Int,&#10;        size: Int = 64&#10;    ): BitmapDrawable? = withContext(Dispatchers.IO) {&#10;        try {&#10;            val drawable = ContextCompat.getDrawable(context, resourceId)&#10;            if (drawable != null) {&#10;                val bitmap = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888)&#10;                val canvas = android.graphics.Canvas(bitmap)&#10;                drawable.setBounds(0, 0, size, size)&#10;                drawable.draw(canvas)&#10;                BitmapDrawable(context.resources, bitmap)&#10;            } else null&#10;        } catch (e: Exception) {&#10;            null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Optimiert MapView Settings für bessere Performance&#10;     */&#10;    fun optimizeMapView(mapView: MapView) {&#10;        mapView.apply {&#10;            // Hardware Acceleration&#10;            setLayerType(android.view.View.LAYER_TYPE_HARDWARE, null)&#10;&#10;            // Disable unnecessary features&#10;            isHorizontalMapRepetitionEnabled = false&#10;            isVerticalMapRepetitionEnabled = false&#10;&#10;            // Optimize tile scaling&#10;            isTilesScaledToDpi = true&#10;&#10;            // Set reasonable zoom limits&#10;            minZoomLevel = 1.0&#10;            maxZoomLevel = 19.0&#10;&#10;            // Optimize overlay rendering&#10;            overlayManager.tilesOverlay.setLoadingBackgroundColor(&#10;                android.graphics.Color.TRANSPARENT&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Cleanup Map Resources - Verbessert für Memory-sicherheit&#10;     */&#10;    fun cleanupMapResources(mapView: MapView?) {&#10;        mapView?.let { map -&gt;&#10;            try {&#10;                // Stoppe alle Background-Threads vor Cleanup&#10;                map.onPause()&#10;                &#10;                // Cleanup Overlays&#10;                map.overlays.clear()&#10;                &#10;                // Cleanup Tile Provider&#10;                map.tileProvider?.let { provider -&gt;&#10;                    try {&#10;                        provider.clearTileCache()&#10;                        provider.detach()&#10;                    } catch (e: Exception) {&#10;                        // Silent fail&#10;                    }&#10;                }&#10;                &#10;                // Final detach&#10;                map.onDetach()&#10;                &#10;            } catch (e: Exception) {&#10;                // Silent cleanup - verhindert Crashes&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Pre-cache tiles für bessere Performance&#10;     */&#10;    suspend fun precacheTiles(&#10;        mapView: MapView,&#10;        centerLat: Double,&#10;        centerLng: Double,&#10;        radiusKm: Double = 100.0&#10;    ) = withContext(Dispatchers.IO) {&#10;        try {&#10;            val boundingBox = calculateBoundingBox(centerLat, centerLng, radiusKm)&#10;            // Pre-cache logic würde hier implementiert werden&#10;            // Dies ist eine vereinfachte Version&#10;        } catch (e: Exception) {&#10;            // Silent fail - App funktioniert weiter ohne Precaching&#10;        }&#10;    }&#10;&#10;    private fun calculateBoundingBox(&#10;        centerLat: Double,&#10;        centerLng: Double,&#10;        radiusKm: Double&#10;    ): org.osmdroid.util.BoundingBox {&#10;        val latOffset = radiusKm / 111.0 // Ungefähr 111km pro Grad&#10;        val lngOffset = radiusKm / (111.0 * kotlin.math.cos(Math.toRadians(centerLat)))&#10;&#10;        return org.osmdroid.util.BoundingBox(&#10;            centerLat + latOffset,&#10;            centerLng + lngOffset,&#10;            centerLat - latOffset,&#10;            centerLng - lngOffset&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * Composable für performance-bewusstes Map Setup&#10; */&#10;@Composable&#10;fun rememberOptimizedMapConfiguration(): org.osmdroid.config.IConfigurationProvider {&#10;    val context = LocalContext.current&#10;&#10;    return remember {&#10;        Configuration.getInstance().also {&#10;            MapPerformanceUtils.configureMapPerformance(context)&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Performance-optimierte Map State Management&#10; */&#10;@Composable&#10;fun rememberMapState(&#10;    initialZoom: Double = 3.0,&#10;    initialCenter: org.osmdroid.util.GeoPoint = org.osmdroid.util.GeoPoint(20.0, 0.0)&#10;): MapState {&#10;    var zoom by remember { mutableDoubleStateOf(initialZoom) }&#10;    var center by remember { mutableStateOf(initialCenter) }&#10;    var isLoading by remember { mutableStateOf(false) }&#10;&#10;    return remember {&#10;        MapState(&#10;            zoom = zoom,&#10;            center = center,&#10;            isLoading = isLoading,&#10;            setZoom = { zoom = it },&#10;            setCenter = { center = it },&#10;            setLoading = { isLoading = it }&#10;        )&#10;    }&#10;}&#10;&#10;data class MapState(&#10;    val zoom: Double,&#10;    val center: org.osmdroid.util.GeoPoint,&#10;    val isLoading: Boolean,&#10;    val setZoom: (Double) -&gt; Unit,&#10;    val setCenter: (org.osmdroid.util.GeoPoint) -&gt; Unit,&#10;    val setLoading: (Boolean) -&gt; Unit&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/utils/MemoryManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/utils/MemoryManager.kt" />
              <option name="originalContent" value="package com.example.geogeusserclone.utils&#10;&#10;import android.content.ComponentCallbacks2&#10;import android.content.Context&#10;import androidx.compose.runtime.*&#10;import androidx.lifecycle.Lifecycle&#10;import androidx.lifecycle.LifecycleEventObserver&#10;import androidx.lifecycle.compose.LocalLifecycleOwner&#10;import coil.ImageLoader&#10;import coil.annotation.ExperimentalCoilApi&#10;&#10;/**&#10; * Memory Management Utilities für bessere Performance&#10; */&#10;object MemoryManager {&#10;&#10;    /**&#10;     * Räumt Image Cache bei Memory Pressure auf&#10;     */&#10;    @Suppress(&quot;DEPRECATION&quot;)&#10;    fun handleMemoryPressure(context: Context, level: Int) {&#10;        when (level) {&#10;            ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN,&#10;            ComponentCallbacks2.TRIM_MEMORY_BACKGROUND -&gt; {&#10;                // Leichte Bereinigung - nur einen Teil des Cache leeren&#10;                clearImageCache(context, moderate = true)&#10;            }&#10;            // Verwende moderne Konstanten oder suppresse deprecated warnings&#10;            ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE -&gt; {&#10;                // Moderate Bereinigung&#10;                clearImageCache(context, moderate = true)&#10;            }&#10;            ComponentCallbacks2.TRIM_MEMORY_COMPLETE -&gt; {&#10;                // Aggressive Bereinigung - kompletten Cache leeren&#10;                clearImageCache(context, moderate = false)&#10;            }&#10;        }&#10;    }&#10;&#10;    @OptIn(ExperimentalCoilApi::class)&#10;    private fun clearImageCache(context: Context, moderate: Boolean) {&#10;        try {&#10;            val imageLoader = ImageLoader(context)&#10;            if (moderate) {&#10;                // Bei moderater Bereinigung nur Memory Cache leeren&#10;                imageLoader.memoryCache?.clear()&#10;            } else {&#10;                // Bei kritischer Memory-Situation alles leeren&#10;                imageLoader.memoryCache?.clear()&#10;                imageLoader.diskCache?.clear()&#10;            }&#10;        } catch (e: Exception) {&#10;            // Silent fail - Cache clearing sollte App nicht zum Absturz bringen&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Composable für automatisches Memory Management basierend auf Lifecycle&#10;     */&#10;    @Composable&#10;    fun AutoMemoryManagement(context: Context) {&#10;        val lifecycleOwner = LocalLifecycleOwner.current&#10;&#10;        DisposableEffect(lifecycleOwner) {&#10;            val observer = LifecycleEventObserver { _, event -&gt;&#10;                when (event) {&#10;                    Lifecycle.Event.ON_PAUSE -&gt; {&#10;                        // App ist in Background - moderate Bereinigung&#10;                        handleMemoryPressure(context, ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN)&#10;                    }&#10;                    Lifecycle.Event.ON_STOP -&gt; {&#10;                        // App ist nicht mehr sichtbar - moderate Bereinigung&#10;                        handleMemoryPressure(context, ComponentCallbacks2.mirTRIM_MEMORY_RUNNING_MODERATE)&#10;                    }&#10;                    Lifecycle.Event.ON_DESTROY -&gt; {&#10;                        // App wird zerstört - komplette Bereinigung&#10;                        handleMemoryPressure(context, ComponentCallbacks2.TRIM_MEMORY_COMPLETE)&#10;                    }&#10;                    else -&gt; Unit&#10;                }&#10;            }&#10;&#10;            lifecycleOwner.lifecycle.addObserver(observer)&#10;&#10;            onDispose {&#10;                lifecycleOwner.lifecycle.removeObserver(observer)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Optimiert Coil ImageLoader für bessere Memory Performance&#10;     */&#10;    fun createOptimizedImageLoader(context: Context): ImageLoader {&#10;        return ImageLoader.Builder(context)&#10;            .memoryCache {&#10;                coil.memory.MemoryCache.Builder(context)&#10;                    .maxSizePercent(0.25) // Verwende maximal 25% des verfügbaren Speichers&#10;                    .build()&#10;            }&#10;            .diskCache {&#10;                coil.disk.DiskCache.Builder()&#10;                    .directory(context.cacheDir.resolve(&quot;image_cache&quot;))&#10;                    .maxSizeBytes(50 * 1024 * 1024) // 50MB Disk Cache&#10;                    .build()&#10;            }&#10;            .crossfade(true)&#10;            .respectCacheHeaders(false)&#10;            .build()&#10;    }&#10;&#10;    /**&#10;     * Berechnet verfügbaren Speicher&#10;     */&#10;    fun getAvailableMemoryMB(context: Context): Long {&#10;        val activityManager = context.getSystemService(Context.ACTIVITY_SERVICE) as android.app.ActivityManager&#10;        val memoryInfo = android.app.ActivityManager.MemoryInfo()&#10;        activityManager.getMemoryInfo(memoryInfo)&#10;        return memoryInfo.availMem / (1024 * 1024) // In MB&#10;    }&#10;&#10;    /**&#10;     * Prüft ob Low Memory Situation vorliegt&#10;     */&#10;    fun isLowMemory(context: Context): Boolean {&#10;        val activityManager = context.getSystemService(Context.ACTIVITY_SERVICE) as android.app.ActivityManager&#10;        val memoryInfo = android.app.ActivityManager.MemoryInfo()&#10;        activityManager.getMemoryInfo(memoryInfo)&#10;        return memoryInfo.lowMemory&#10;    }&#10;&#10;    /**&#10;     * Implementiert moderne Memory Management Strategie&#10;     */&#10;    @Suppress(&quot;DEPRECATION&quot;)&#10;    fun handleModernMemoryPressure(context: Context, level: Int) {&#10;        when (level) {&#10;            // Verwende neue nicht-deprecated Konstanten wo verfügbar&#10;            ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN,&#10;            ComponentCallbacks2.TRIM_MEMORY_BACKGROUND,&#10;            ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE -&gt; {&#10;                // Moderate Bereinigung&#10;                clearImageCache(context, moderate = true)&#10;                System.gc() // Suggestion für Garbage Collection&#10;            }&#10;            ComponentCallbacks2.TRIM_MEMORY_COMPLETE -&gt; {&#10;                // Aggressive Bereinigung&#10;                clearImageCache(context, moderate = false)&#10;                System.gc() // Force Garbage Collection&#10;            }&#10;            else -&gt; {&#10;                // Fallback für unbekannte Level&#10;                clearImageCache(context, moderate = true)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Optimierte Composable für schwere UI-Operationen&#10; */&#10;@Composable&#10;fun &lt;T&gt; LazyComposable(&#10;    key: Any,&#10;    computation: () -&gt; T&#10;): T {&#10;    return remember(key) {&#10;        computation()&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.geogeusserclone.utils&#10;&#10;import android.content.ComponentCallbacks2&#10;import android.content.Context&#10;import androidx.compose.runtime.*&#10;import androidx.lifecycle.Lifecycle&#10;import androidx.lifecycle.LifecycleEventObserver&#10;import androidx.lifecycle.compose.LocalLifecycleOwner&#10;import coil.ImageLoader&#10;import coil.annotation.ExperimentalCoilApi&#10;&#10;/**&#10; * Memory Management Utilities für bessere Performance&#10; */&#10;object MemoryManager {&#10;&#10;    /**&#10;     * Räumt Image Cache bei Memory Pressure auf&#10;     */&#10;    @Suppress(&quot;DEPRECATION&quot;)&#10;    fun handleMemoryPressure(context: Context, level: Int) {&#10;        when (level) {&#10;            ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN,&#10;            ComponentCallbacks2.TRIM_MEMORY_BACKGROUND -&gt; {&#10;                // Leichte Bereinigung - nur einen Teil des Cache leeren&#10;                clearImageCache(context, moderate = true)&#10;            }&#10;            // Verwende moderne Konstanten oder suppresse deprecated warnings&#10;            ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE -&gt; {&#10;                // Moderate Bereinigung&#10;                clearImageCache(context, moderate = true)&#10;            }&#10;            ComponentCallbacks2.TRIM_MEMORY_COMPLETE -&gt; {&#10;                // Aggressive Bereinigung - kompletten Cache leeren&#10;                clearImageCache(context, moderate = false)&#10;            }&#10;        }&#10;    }&#10;&#10;    @OptIn(ExperimentalCoilApi::class)&#10;    private fun clearImageCache(context: Context, moderate: Boolean) {&#10;        try {&#10;            val imageLoader = ImageLoader(context)&#10;            if (moderate) {&#10;                // Bei moderater Bereinigung nur Memory Cache leeren&#10;                imageLoader.memoryCache?.clear()&#10;            } else {&#10;                // Bei kritischer Memory-Situation alles leeren&#10;                imageLoader.memoryCache?.clear()&#10;                imageLoader.diskCache?.clear()&#10;            }&#10;        } catch (e: Exception) {&#10;            // Silent fail - Cache clearing sollte App nicht zum Absturz bringen&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Composable für automatisches Memory Management basierend auf Lifecycle&#10;     */&#10;    @Composable&#10;    fun AutoMemoryManagement(context: Context) {&#10;        val lifecycleOwner = LocalLifecycleOwner.current&#10;&#10;        DisposableEffect(lifecycleOwner) {&#10;            val observer = LifecycleEventObserver { _, event -&gt;&#10;                when (event) {&#10;                    Lifecycle.Event.ON_PAUSE -&gt; {&#10;                        // App ist in Background - moderate Bereinigung&#10;                        handleMemoryPressure(context, ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN)&#10;                    }&#10;                    Lifecycle.Event.ON_STOP -&gt; {&#10;                        // App ist nicht mehr sichtbar - moderate Bereinigung&#10;                        handleMemoryPressure(context, ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE)&#10;                    }&#10;                    Lifecycle.Event.ON_DESTROY -&gt; {&#10;                        // App wird zerstört - komplette Bereinigung&#10;                        handleMemoryPressure(context, ComponentCallbacks2.TRIM_MEMORY_COMPLETE)&#10;                    }&#10;                    else -&gt; Unit&#10;                }&#10;            }&#10;&#10;            lifecycleOwner.lifecycle.addObserver(observer)&#10;&#10;            onDispose {&#10;                lifecycleOwner.lifecycle.removeObserver(observer)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Optimiert Coil ImageLoader für bessere Memory Performance&#10;     */&#10;    fun createOptimizedImageLoader(context: Context): ImageLoader {&#10;        return ImageLoader.Builder(context)&#10;            .memoryCache {&#10;                coil.memory.MemoryCache.Builder(context)&#10;                    .maxSizePercent(0.25) // Verwende maximal 25% des verfügbaren Speichers&#10;                    .build()&#10;            }&#10;            .diskCache {&#10;                coil.disk.DiskCache.Builder()&#10;                    .directory(context.cacheDir.resolve(&quot;image_cache&quot;))&#10;                    .maxSizeBytes(50 * 1024 * 1024) // 50MB Disk Cache&#10;                    .build()&#10;            }&#10;            .crossfade(true)&#10;            .respectCacheHeaders(false)&#10;            .build()&#10;    }&#10;&#10;    /**&#10;     * Berechnet verfügbaren Speicher&#10;     */&#10;    fun getAvailableMemoryMB(context: Context): Long {&#10;        val activityManager = context.getSystemService(Context.ACTIVITY_SERVICE) as android.app.ActivityManager&#10;        val memoryInfo = android.app.ActivityManager.MemoryInfo()&#10;        activityManager.getMemoryInfo(memoryInfo)&#10;        return memoryInfo.availMem / (1024 * 1024) // In MB&#10;    }&#10;&#10;    /**&#10;     * Prüft ob Low Memory Situation vorliegt&#10;     */&#10;    fun isLowMemory(context: Context): Boolean {&#10;        val activityManager = context.getSystemService(Context.ACTIVITY_SERVICE) as android.app.ActivityManager&#10;        val memoryInfo = android.app.ActivityManager.MemoryInfo()&#10;        activityManager.getMemoryInfo(memoryInfo)&#10;        return memoryInfo.lowMemory&#10;    }&#10;&#10;    /**&#10;     * Implementiert moderne Memory Management Strategie&#10;     */&#10;    @Suppress(&quot;DEPRECATION&quot;)&#10;    fun handleModernMemoryPressure(context: Context, level: Int) {&#10;        when (level) {&#10;            // Verwende neue nicht-deprecated Konstanten wo verfügbar&#10;            ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN,&#10;            ComponentCallbacks2.TRIM_MEMORY_BACKGROUND,&#10;            ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE -&gt; {&#10;                // Moderate Bereinigung&#10;                clearImageCache(context, moderate = true)&#10;                System.gc() // Suggestion für Garbage Collection&#10;            }&#10;            ComponentCallbacks2.TRIM_MEMORY_COMPLETE -&gt; {&#10;                // Aggressive Bereinigung&#10;                clearImageCache(context, moderate = false)&#10;                System.gc() // Force Garbage Collection&#10;            }&#10;            else -&gt; {&#10;                // Fallback für unbekannte Level&#10;                clearImageCache(context, moderate = true)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Optimierte Composable für schwere UI-Operationen&#10; */&#10;@Composable&#10;fun &lt;T&gt; LazyComposable(&#10;    key: Any,&#10;    computation: () -&gt; T&#10;): T {&#10;    return remember(key) {&#10;        computation()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/utils/ScoreCalculator.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/utils/ScoreCalculator.kt" />
              <option name="originalContent" value="package com.example.geogeusserclone.utils&#10;&#10;import androidx.compose.ui.graphics.Color&#10;import com.example.geogeusserclone.utils.Constants&#10;&#10;enum class ScoreRating {&#10;    PERFECT, EXCELLENT, GOOD, FAIR, POOR, TERRIBLE&#10;}&#10;&#10;object ScoreCalculator {&#10;&#10;    /**&#10;     * Berechnet den Score basierend auf Entfernung und Zeit&#10;     */&#10;    fun calculateScore(&#10;        distanceKm: Double,&#10;        timeSpentMs: Long = 0L,&#10;        maxTimeMs: Long = Constants.MAX_ROUND_TIME_MS&#10;    ): Int {&#10;        // Basis-Score basierend auf Entfernung (0-5000 Punkte)&#10;        val distanceScore = when {&#10;            distanceKm &lt;= Constants.PERFECT_DISTANCE_KM -&gt; 5000&#10;            distanceKm &lt;= Constants.EXCELLENT_DISTANCE_KM -&gt; 4500 - ((distanceKm - 1) * 50).toInt()&#10;            distanceKm &lt;= Constants.GOOD_DISTANCE_KM -&gt; 4000 - ((distanceKm - 10) * 75).toInt()&#10;            distanceKm &lt;= Constants.FAIR_DISTANCE_KM -&gt; 2000 - ((distanceKm - 50) * 10).toInt()&#10;            distanceKm &lt;= Constants.POOR_DISTANCE_KM -&gt; 500 - ((distanceKm - 200) * 0.5).toInt()&#10;            else -&gt; 0&#10;        }.coerceIn(0, 5000)&#10;&#10;        // Zeit-Bonus (0-500 Punkte)&#10;        val timeBonus = if (timeSpentMs &gt; 0 &amp;&amp; maxTimeMs &gt; 0) {&#10;            val timeRatio = (maxTimeMs - timeSpentMs).toDouble() / maxTimeMs&#10;            (timeRatio * Constants.TIME_BONUS_MAX).toInt().coerceIn(0, Constants.TIME_BONUS_MAX)&#10;        } else 0&#10;&#10;        return (distanceScore + timeBonus).coerceIn(0, 5500)&#10;    }&#10;&#10;    /**&#10;     * Bestimmt die Score-Bewertung&#10;     */&#10;    fun getScoreRating(score: Int): ScoreRating {&#10;        return when {&#10;            score &gt;= 4500 -&gt; ScoreRating.PERFECT&#10;            score &gt;= 3500 -&gt; ScoreRating.EXCELLENT&#10;            score &gt;= 2500 -&gt; ScoreRating.GOOD&#10;            score &gt;= 1000 -&gt; ScoreRating.FAIR&#10;            score &gt;= 200 -&gt; ScoreRating.POOR&#10;            else -&gt; ScoreRating.TERRIBLE&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Gibt die passende Farbe für den Score zurück&#10;     */&#10;    fun getScoreColor(rating: ScoreRating): Color {&#10;        return when (rating) {&#10;            ScoreRating.PERFECT -&gt; Color(0xFF4CAF50)      // Grün&#10;            ScoreRating.EXCELLENT -&gt; Color(0xFF8BC34A)    // Hell-Grün&#10;            ScoreRating.GOOD -&gt; Color(0xFFFFC107)         // Gelb&#10;            ScoreRating.FAIR -&gt; Color(0xFFFF9800)         // Orange&#10;            ScoreRating.POOR -&gt; Color(0xFFFF5722)         // Rot-Orange&#10;            ScoreRating.TERRIBLE -&gt; Color(0xFFF44336)     // Rot&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.geogeusserclone.utils&#10;&#10;import androidx.compose.ui.graphics.Color&#10;import com.example.geogeusserclone.utils.Constants&#10;&#10;object ScoreCalculator {&#10;&#10;    enum class ScoreRating {&#10;        PERFECT, EXCELLENT, GOOD, FAIR, POOR, TERRIBLE&#10;    }&#10;&#10;    /**&#10;     * Berechnet den Score basierend auf Entfernung und Zeit&#10;     */&#10;    fun calculateScore(&#10;        distanceKm: Double,&#10;        timeSpentMs: Long = 0L,&#10;        maxTimeMs: Long = Constants.MAX_ROUND_TIME_MS&#10;    ): Int {&#10;        // Basis-Score basierend auf Entfernung (0-5000 Punkte)&#10;        val distanceScore = when {&#10;            distanceKm &lt;= Constants.PERFECT_DISTANCE_KM -&gt; 5000&#10;            distanceKm &lt;= Constants.EXCELLENT_DISTANCE_KM -&gt; 4500 - ((distanceKm - 1) * 50).toInt()&#10;            distanceKm &lt;= Constants.GOOD_DISTANCE_KM -&gt; 4000 - ((distanceKm - 10) * 75).toInt()&#10;            distanceKm &lt;= Constants.FAIR_DISTANCE_KM -&gt; 2000 - ((distanceKm - 50) * 10).toInt()&#10;            distanceKm &lt;= Constants.POOR_DISTANCE_KM -&gt; 500 - ((distanceKm - 200) * 0.5).toInt()&#10;            else -&gt; 0&#10;        }.coerceIn(0, 5000)&#10;&#10;        // Zeit-Bonus (0-500 Punkte)&#10;        val timeBonus = if (timeSpentMs &gt; 0 &amp;&amp; maxTimeMs &gt; 0) {&#10;            val timeRatio = (maxTimeMs - timeSpentMs).toDouble() / maxTimeMs&#10;            (timeRatio * Constants.TIME_BONUS_MAX).toInt().coerceIn(0, Constants.TIME_BONUS_MAX)&#10;        } else 0&#10;&#10;        return (distanceScore + timeBonus).coerceIn(0, 5500)&#10;    }&#10;&#10;    /**&#10;     * Bestimmt die Score-Bewertung&#10;     */&#10;    fun getScoreRating(score: Int): ScoreRating {&#10;        return when {&#10;            score &gt;= 4500 -&gt; ScoreRating.PERFECT&#10;            score &gt;= 3500 -&gt; ScoreRating.EXCELLENT&#10;            score &gt;= 2500 -&gt; ScoreRating.GOOD&#10;            score &gt;= 1000 -&gt; ScoreRating.FAIR&#10;            score &gt;= 200 -&gt; ScoreRating.POOR&#10;            else -&gt; ScoreRating.TERRIBLE&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Gibt die passende Farbe für den Score zurück&#10;     */&#10;    fun getScoreColor(rating: ScoreRating): Color {&#10;        return when (rating) {&#10;            ScoreRating.PERFECT -&gt; Color(0xFF4CAF50)      // Grün&#10;            ScoreRating.EXCELLENT -&gt; Color(0xFF8BC34A)    // Hell-Grün&#10;            ScoreRating.GOOD -&gt; Color(0xFFFFC107)         // Gelb&#10;            ScoreRating.FAIR -&gt; Color(0xFFFF9800)         // Orange&#10;            ScoreRating.POOR -&gt; Color(0xFFFF5722)         // Rot-Orange&#10;            ScoreRating.TERRIBLE -&gt; Color(0xFFF44336)     // Rot&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/viewmodels/AuthViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/viewmodels/AuthViewModel.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.viewmodels&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.geogeusserclone.data.repositories.UserRepository&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;data class AuthState(&#10;    val isLoggedIn: Boolean = false,&#10;    val isLoading: Boolean = false,&#10;    val error: String? = null,&#10;    val currentUser: com.example.geogeusserclone.data.database.entities.UserEntity? = null&#10;)&#10;&#10;@HiltViewModel&#10;class AuthViewModel @Inject constructor(&#10;    private val userRepository: UserRepository&#10;) : ViewModel() {&#10;&#10;    private val _state = MutableStateFlow(AuthState())&#10;    val state: StateFlow&lt;AuthState&gt; = _state.asStateFlow()&#10;&#10;    init {&#10;        checkCurrentUser()&#10;    }&#10;&#10;    private fun checkCurrentUser() {&#10;        viewModelScope.launch {&#10;            _state.value = _state.value.copy(isLoading = true)&#10;            &#10;            try {&#10;                val currentUser = userRepository.getCurrentUser()&#10;                _state.value = _state.value.copy(&#10;                    isLoggedIn = currentUser != null,&#10;                    currentUser = currentUser,&#10;                    isLoading = false&#10;                )&#10;            } catch (e: Exception) {&#10;                _state.value = _state.value.copy(&#10;                    isLoading = false,&#10;                    error = &quot;Fehler beim Laden des Benutzers: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun login(email: String, password: String) {&#10;        viewModelScope.launch {&#10;            _state.value = _state.value.copy(isLoading = true, error = null)&#10;&#10;            try {&#10;                val result = userRepository.login(email, password)&#10;                &#10;                if (result.isSuccess) {&#10;                    val user = result.getOrNull()!!&#10;                    _state.value = _state.value.copy(&#10;                        isLoggedIn = true,&#10;                        currentUser = user,&#10;                        isLoading = false,&#10;                        error = null&#10;                    )&#10;                } else {&#10;                    _state.value = _state.value.copy(&#10;                        isLoading = false,&#10;                        error = result.exceptionOrNull()?.message ?: &quot;Login fehlgeschlagen&quot;&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                _state.value = _state.value.copy(&#10;                    isLoading = false,&#10;                    error = &quot;Netzwerkfehler: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun register(username: String, email: String, password: String) {&#10;        viewModelScope.launch {&#10;            _state.value = _state.value.copy(isLoading = true, error = null)&#10;&#10;            try {&#10;                val result = userRepository.register(username, email, password)&#10;                &#10;                if (result.isSuccess) {&#10;                    val user = result.getOrNull()!!&#10;                    _state.value = _state.value.copy(&#10;                        isLoggedIn = true,&#10;                        currentUser = user,&#10;                        isLoading = false,&#10;                        error = null&#10;                    )&#10;                } else {&#10;                    _state.value = _state.value.copy(&#10;                        isLoading = false,&#10;                        error = result.exceptionOrNull()?.message ?: &quot;Registrierung fehlgeschlagen&quot;&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                _state.value = _state.value.copy(&#10;                    isLoading = false,&#10;                    error = &quot;Netzwerkfehler: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun logout() {&#10;        viewModelScope.launch {&#10;            try {&#10;                userRepository.logout()&#10;                _state.value = AuthState() // Reset to initial state&#10;            } catch (e: Exception) {&#10;                _state.value = _state.value.copy(&#10;                    error = &quot;Fehler beim Abmelden: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun clearError() {&#10;        _state.value = _state.value.copy(error = null)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>