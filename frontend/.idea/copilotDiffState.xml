<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/network/AuthInterceptor.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/network/AuthInterceptor.kt" />
              <option name="originalContent" value="package com.example.geogeusserclone.data.network&#10;&#10;import kotlinx.coroutines.runBlocking&#10;import okhttp3.Interceptor&#10;import okhttp3.Response&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class AuthInterceptor @Inject constructor() : Interceptor {&#10;&#10;    private var authToken: String? = null&#10;    private var refreshToken: String? = null&#10;    private var tokenRefreshCallback: (suspend () -&gt; String?)? = null&#10;&#10;    override fun intercept(chain: Interceptor.Chain): Response {&#10;        val originalRequest = chain.request()&#10;&#10;        // Add auth token if available&#10;        val requestBuilder = originalRequest.newBuilder()&#10;        authToken?.let { token -&gt;&#10;            requestBuilder.addHeader(&quot;Authorization&quot;, &quot;Bearer $token&quot;)&#10;        }&#10;&#10;        val response = chain.proceed(requestBuilder.build())&#10;&#10;        // Handle 401 Unauthorized - try to refresh token&#10;        if (response.code == 401 &amp;&amp; refreshToken != null) {&#10;            response.close()&#10;&#10;            val newToken = runBlocking {&#10;                tokenRefreshCallback?.invoke()&#10;            }&#10;&#10;            if (newToken != null) {&#10;                authToken = newToken&#10;&#10;                // Retry the original request with new token&#10;                val newRequest = originalRequest.newBuilder()&#10;                    .addHeader(&quot;Authorization&quot;, &quot;Bearer $newToken&quot;)&#10;                    .build()&#10;&#10;                return chain.proceed(newRequest)&#10;            }&#10;        }&#10;&#10;        return response&#10;    }&#10;&#10;    fun setToken(token: String?) {&#10;        this.authToken = token&#10;    }&#10;&#10;    //Retry Logic:&#10;    fun setRefreshToken(token: String?) {&#10;        this.refreshToken = token&#10;    }&#10;&#10;    fun setTokenRefreshCallback(callback: suspend () -&gt; String?) {&#10;        this.tokenRefreshCallback = callback&#10;    }&#10;&#10;    fun clearTokens() {&#10;        authToken = null&#10;        refreshToken = null&#10;        tokenRefreshCallback = null&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.network&#10;&#10;import kotlinx.coroutines.runBlocking&#10;import okhttp3.Interceptor&#10;import okhttp3.Response&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class AuthInterceptor @Inject constructor() : Interceptor {&#10;&#10;    private var authToken: String? = null&#10;    private var refreshToken: String? = null&#10;    private var tokenRefreshCallback: (suspend () -&gt; String?)? = null&#10;&#10;    override fun intercept(chain: Interceptor.Chain): Response {&#10;        val originalRequest = chain.request()&#10;&#10;        // Add auth token if available&#10;        val requestBuilder = originalRequest.newBuilder()&#10;        authToken?.let { token -&gt;&#10;            requestBuilder.addHeader(&quot;Authorization&quot;, &quot;Bearer $token&quot;)&#10;        }&#10;&#10;        val response = chain.proceed(requestBuilder.build())&#10;&#10;        // Handle 401 Unauthorized - try to refresh token&#10;        if (response.code == 401 &amp;&amp; refreshToken != null) {&#10;            response.close()&#10;&#10;            val newToken = runBlocking {&#10;                tokenRefreshCallback?.invoke()&#10;            }&#10;&#10;            if (newToken != null) {&#10;                authToken = newToken&#10;&#10;                // Retry the original request with new token&#10;                val newRequest = originalRequest.newBuilder()&#10;                    .addHeader(&quot;Authorization&quot;, &quot;Bearer $newToken&quot;)&#10;                    .build()&#10;&#10;                return chain.proceed(newRequest)&#10;            }&#10;        }&#10;&#10;        return response&#10;    }&#10;&#10;    fun setAuthToken(token: String?) {&#10;        this.authToken = token&#10;    }&#10;&#10;    fun setToken(token: String?) {&#10;        this.authToken = token&#10;    }&#10;&#10;    //Retry Logic:&#10;    fun setRefreshToken(token: String?) {&#10;        this.refreshToken = token&#10;    }&#10;&#10;    fun setTokenRefreshCallback(callback: suspend () -&gt; String?) {&#10;        this.tokenRefreshCallback = callback&#10;    }&#10;&#10;    fun clearTokens() {&#10;        authToken = null&#10;        refreshToken = null&#10;        tokenRefreshCallback = null&#10;    }&#10;&#10;    fun clearAuthToken() {&#10;        authToken = null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/repositories/UserRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/repositories/UserRepository.kt" />
              <option name="originalContent" value="package com.example.geogeusserclone.data.repositories&#10;&#10;import com.example.geogeusserclone.data.database.dao.UserDao&#10;import com.example.geogeusserclone.data.database.entities.UserEntity&#10;import com.example.geogeusserclone.data.network.ApiService&#10;import com.example.geogeusserclone.data.network.AuthInterceptor&#10;import com.example.geogeusserclone.data.network.LoginRequest&#10;import com.example.geogeusserclone.data.network.RegisterRequest&#10;import com.example.geogeusserclone.data.network.RefreshTokenRequest&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.Flow&#10;import java.util.UUID&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class UserRepository @Inject constructor(&#10;    private val apiService: ApiService,&#10;    private val userDao: UserDao,&#10;    private val authInterceptor: AuthInterceptor&#10;) : BaseRepository() {&#10;&#10;    fun getCurrentUserFlow(): Flow&lt;UserEntity?&gt; = userDao.getCurrentUserFlow()&#10;&#10;    suspend fun getCurrentUser(): UserEntity? = userDao.getCurrentUserSync()&#10;&#10;    suspend fun login(email: String, password: String): Result&lt;UserEntity&gt; {&#10;        return try {&#10;            val response = apiService.login(LoginRequest(email, password))&#10;&#10;            if (response.isSuccessful) {&#10;                val loginResponse = response.body()!!&#10;                val user = UserEntity(&#10;                    id = loginResponse.user.id,&#10;                    username = loginResponse.user.username,&#10;                    email = loginResponse.user.email,&#10;                    authToken = loginResponse.token,&#10;                    refreshToken = loginResponse.refreshToken,&#10;                    totalScore = loginResponse.user.totalScore,&#10;                    gamesPlayed = loginResponse.user.gamesPlayed,&#10;                    bestScore = loginResponse.user.bestScore,&#10;                    lastLoginAt = System.currentTimeMillis()&#10;                )&#10;&#10;                userDao.clearCurrentUser()&#10;                userDao.insertUser(user)&#10;                authInterceptor.setAuthToken(loginResponse.token)&#10;&#10;                Result.success(user)&#10;            } else {&#10;                Result.failure(Exception(&quot;Login fehlgeschlagen&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    suspend fun register(username: String, email: String, password: String): Result&lt;UserEntity&gt; {&#10;        return try {&#10;            val response = apiService.register(RegisterRequest(username, email, password))&#10;&#10;            if (response.isSuccessful) {&#10;                val registerResponse = response.body()!!&#10;                val user = UserEntity(&#10;                    id = registerResponse.user.id,&#10;                    username = registerResponse.user.username,&#10;                    email = registerResponse.user.email,&#10;                    authToken = registerResponse.token,&#10;                    refreshToken = registerResponse.refreshToken,&#10;                    createdAt = System.currentTimeMillis(),&#10;                    lastLoginAt = System.currentTimeMillis()&#10;                )&#10;&#10;                userDao.clearCurrentUser()&#10;                userDao.insertUser(user)&#10;                authInterceptor.setAuthToken(registerResponse.token)&#10;&#10;                Result.success(user)&#10;            } else {&#10;                Result.failure(Exception(&quot;Registrierung fehlgeschlagen&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            // Offline Fallback fÃ¼r Registrierung&#10;            val offlineUser = UserEntity(&#10;                id = UUID.randomUUID().toString(),&#10;                username = username,&#10;                email = email,&#10;                authToken = &quot;offline_token&quot;,&#10;                createdAt = System.currentTimeMillis(),&#10;                lastLoginAt = System.currentTimeMillis()&#10;            )&#10;&#10;            userDao.clearCurrentUser()&#10;            userDao.insertUser(offlineUser)&#10;            authInterceptor.setAuthToken(&quot;offline_token&quot;)&#10;&#10;            Result.success(offlineUser)&#10;        }&#10;    }&#10;&#10;    suspend fun logout() {&#10;        try {&#10;            apiService.logout()&#10;        } catch (e: Exception) {&#10;            // Ignoriere Netzwerkfehler beim Logout&#10;        } finally {&#10;            userDao.clearCurrentUser()&#10;            authInterceptor.clearAuthToken()&#10;        }&#10;    }&#10;&#10;    suspend fun updateUserStats(userId: String, totalScore: Int, gamesPlayed: Int, bestScore: Int) {&#10;        userDao.updateUserStats(userId, totalScore, gamesPlayed, bestScore)&#10;&#10;        try {&#10;            // Versuche auch online zu synchronisieren&#10;            apiService.updateUserStats(userId, totalScore, gamesPlayed, bestScore)&#10;        } catch (e: Exception) {&#10;            // Ignoriere Netzwerkfehler&#10;        }&#10;    }&#10;&#10;    suspend fun refreshToken(): Result&lt;String&gt; {&#10;        return try {&#10;            val currentUser = getCurrentUser()&#10;            if (currentUser?.refreshToken != null) {&#10;                val response = apiService.refreshToken(RefreshTokenRequest(currentUser.refreshToken))&#10;                if (response.isSuccessful) {&#10;                    val tokenResponse = response.body()!!&#10;                    userDao.updateAuthToken(currentUser.id, tokenResponse.token, System.currentTimeMillis())&#10;                    authInterceptor.setAuthToken(tokenResponse.token)&#10;                    Result.success(tokenResponse.token)&#10;                } else {&#10;                    Result.failure(Exception(&quot;Token refresh failed&quot;))&#10;                }&#10;            } else {&#10;                Result.failure(Exception(&quot;No refresh token available&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.repositories&#10;&#10;import com.example.geogeusserclone.data.database.dao.UserDao&#10;import com.example.geogeusserclone.data.database.entities.UserEntity&#10;import com.example.geogeusserclone.data.network.ApiService&#10;import com.example.geogeusserclone.data.network.AuthInterceptor&#10;import com.example.geogeusserclone.data.network.LoginRequest&#10;import com.example.geogeusserclone.data.network.RegisterRequest&#10;import com.example.geogeusserclone.data.network.RefreshTokenRequest&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.Flow&#10;import java.util.UUID&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class UserRepository @Inject constructor(&#10;    private val apiService: ApiService,&#10;    private val userDao: UserDao,&#10;    private val authInterceptor: AuthInterceptor&#10;) : BaseRepository() {&#10;&#10;    fun getCurrentUserFlow(): Flow&lt;UserEntity?&gt; = userDao.getCurrentUserFlow()&#10;&#10;    suspend fun getCurrentUser(): UserEntity? = userDao.getCurrentUserSync()&#10;&#10;    suspend fun login(email: String, password: String): Result&lt;UserEntity&gt; {&#10;        return try {&#10;            val response = apiService.login(LoginRequest(email, password))&#10;&#10;            if (response.isSuccessful) {&#10;                val loginResponse = response.body()!!&#10;                val user = UserEntity(&#10;                    id = loginResponse.user.id,&#10;                    username = loginResponse.user.username,&#10;                    email = loginResponse.user.email,&#10;                    authToken = loginResponse.token,&#10;                    refreshToken = loginResponse.refreshToken,&#10;                    totalScore = loginResponse.user.totalScore ?: 0,&#10;                    gamesPlayed = loginResponse.user.gamesPlayed ?: 0,&#10;                    bestScore = 0, // Verwende Standardwert da bestScore mÃ¶glicherweise nicht verfÃ¼gbar ist&#10;                    lastLoginAt = System.currentTimeMillis()&#10;                )&#10;&#10;                userDao.clearCurrentUser()&#10;                userDao.insertUser(user)&#10;                authInterceptor.setAuthToken(loginResponse.token)&#10;&#10;                Result.success(user)&#10;            } else {&#10;                Result.failure(Exception(&quot;Login fehlgeschlagen&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    suspend fun register(username: String, email: String, password: String): Result&lt;UserEntity&gt; {&#10;        return try {&#10;            val response = apiService.register(RegisterRequest(username, email, password))&#10;&#10;            if (response.isSuccessful) {&#10;                val registerResponse = response.body()!!&#10;                val user = UserEntity(&#10;                    id = registerResponse.user.id,&#10;                    username = registerResponse.user.username,&#10;                    email = registerResponse.user.email,&#10;                    authToken = registerResponse.token,&#10;                    refreshToken = registerResponse.refreshToken,&#10;                    createdAt = System.currentTimeMillis(),&#10;                    lastLoginAt = System.currentTimeMillis()&#10;                )&#10;&#10;                userDao.clearCurrentUser()&#10;                userDao.insertUser(user)&#10;                authInterceptor.setAuthToken(registerResponse.token)&#10;&#10;                Result.success(user)&#10;            } else {&#10;                Result.failure(Exception(&quot;Registrierung fehlgeschlagen&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            // Offline Fallback fÃ¼r Registrierung&#10;            val offlineUser = UserEntity(&#10;                id = UUID.randomUUID().toString(),&#10;                username = username,&#10;                email = email,&#10;                authToken = &quot;offline_token&quot;,&#10;                createdAt = System.currentTimeMillis(),&#10;                lastLoginAt = System.currentTimeMillis()&#10;            )&#10;&#10;            userDao.clearCurrentUser()&#10;            userDao.insertUser(offlineUser)&#10;            authInterceptor.setAuthToken(&quot;offline_token&quot;)&#10;&#10;            Result.success(offlineUser)&#10;        }&#10;    }&#10;&#10;    suspend fun logout() {&#10;        try {&#10;            apiService.logout()&#10;        } catch (e: Exception) {&#10;            // Ignoriere Netzwerkfehler beim Logout&#10;        } finally {&#10;            userDao.clearCurrentUser()&#10;            authInterceptor.clearAuthToken()&#10;        }&#10;    }&#10;&#10;    suspend fun updateUserStats(userId: String, totalScore: Int, gamesPlayed: Int, bestScore: Int) {&#10;        userDao.updateUserStats(userId, totalScore, gamesPlayed, bestScore)&#10;&#10;        try {&#10;            // Versuche auch online zu synchronisieren&#10;            apiService.updateUserStats(userId, totalScore, gamesPlayed, bestScore)&#10;        } catch (e: Exception) {&#10;            // Ignoriere Netzwerkfehler&#10;        }&#10;    }&#10;&#10;    suspend fun refreshToken(): Result&lt;String&gt; {&#10;        return try {&#10;            val currentUser = getCurrentUser()&#10;            if (currentUser?.refreshToken != null) {&#10;                val response = apiService.refreshToken(RefreshTokenRequest(currentUser.refreshToken))&#10;                if (response.isSuccessful) {&#10;                    val tokenResponse = response.body()!!&#10;                    userDao.updateAuthToken(currentUser.id, tokenResponse.token, System.currentTimeMillis())&#10;                    authInterceptor.setAuthToken(tokenResponse.token)&#10;                    Result.success(tokenResponse.token)&#10;                } else {&#10;                    Result.failure(Exception(&quot;Token refresh failed&quot;))&#10;                }&#10;            } else {&#10;                Result.failure(Exception(&quot;No refresh token available&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/viewmodels/BaseViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/viewmodels/BaseViewModel.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.viewmodels&#10;&#10;import androidx.lifecycle.ViewModel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;&#10;abstract class BaseViewModel&lt;T&gt;(initialState: T) : ViewModel() {&#10;    &#10;    private val _state = MutableStateFlow(initialState)&#10;    val state: StateFlow&lt;T&gt; = _state.asStateFlow()&#10;&#10;    protected fun setState(newState: T) {&#10;        _state.value = newState&#10;    }&#10;&#10;    protected fun updateState(transform: (T) -&gt; T) {&#10;        _state.value = transform(_state.value)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>