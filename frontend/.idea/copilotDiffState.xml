<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    alias(libs.plugins.hilt.android)&#10;    alias(libs.plugins.ksp)&#10;    alias(libs.plugins.kotlin.serialization)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.example.geoguessrclone&quot;&#10;    compileSdk = 35&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.geoguessrclone&quot;&#10;        minSdk = 26&#10;        targetSdk = 35&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;        vectorDrawables {&#10;            useSupportLibrary = true&#10;        }&#10;&#10;        // Performance Optimierungen&#10;        multiDexEnabled = true&#10;&#10;        // ProGuard optimierte Konfiguration&#10;        ndk {&#10;            debugSymbolLevel = &quot;SYMBOL_TABLE&quot;&#10;        }&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = true // Aktiviert für bessere Performance&#10;            isShrinkResources = true // Entfernt unbenutzte Ressourcen&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;            buildConfigField(&quot;String&quot;, &quot;BASE_URL&quot;, &quot;\&quot;https://your-app.vercel.app\&quot;&quot;)&#10;            buildConfigField(&quot;String&quot;, &quot;SOCKET_URL&quot;, &quot;\&quot;wss://your-app.vercel.app\&quot;&quot;)&#10;&#10;            // Performance Optimierungen für Release&#10;            isDebuggable = false&#10;            renderscriptOptimLevel = 3&#10;        }&#10;        debug {&#10;            buildConfigField(&quot;String&quot;, &quot;BASE_URL&quot;, &quot;\&quot;https://your-app.vercel.app\&quot;&quot;)&#10;            buildConfigField(&quot;String&quot;, &quot;SOCKET_URL&quot;, &quot;\&quot;wss://your-app.vercel.app\&quot;&quot;)&#10;&#10;            // Debug Performance Optimierungen&#10;            isMinifyEnabled = false&#10;            applicationIdSuffix = &quot;.debug&quot;&#10;        }&#10;    }&#10;&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_17 // Upgrade für bessere Performance&#10;        targetCompatibility = JavaVersion.VERSION_17&#10;        isCoreLibraryDesugaringEnabled = true&#10;    }&#10;&#10;    kotlinOptions {&#10;        jvmTarget = &quot;17&quot;&#10;&#10;        // Kotlin Compiler Optimierungen&#10;        freeCompilerArgs += listOf(&#10;            &quot;-opt-in=androidx.compose.material3.ExperimentalMaterial3Api&quot;,&#10;            &quot;-opt-in=androidx.compose.foundation.ExperimentalFoundationApi&quot;,&#10;            &quot;-opt-in=kotlinx.coroutines.ExperimentalCoroutinesApi&quot;,&#10;            &quot;-Xjvm-default=all&quot;, // Bessere Java Interop Performance&#10;            &quot;-Xbackend-threads=4&quot; // Parallele Compilation&#10;        )&#10;    }&#10;&#10;    buildFeatures {&#10;        compose = true&#10;        buildConfig = true&#10;&#10;        // Deaktiviere unbenutzte Features für bessere Build Performance&#10;        viewBinding = false&#10;        dataBinding = false&#10;        aidl = false&#10;        renderScript = false&#10;        shaders = false&#10;    }&#10;&#10;    composeOptions {&#10;        kotlinCompilerExtensionVersion = &quot;1.5.15&quot;&#10;    }&#10;&#10;    packaging {&#10;        resources {&#10;            excludes += &quot;/META-INF/{AL2.0,LGPL2.1}&quot;&#10;            excludes += &quot;/META-INF/DEPENDENCIES&quot;&#10;            excludes += &quot;/META-INF/LICENSE&quot;&#10;            excludes += &quot;/META-INF/LICENSE.txt&quot;&#10;            excludes += &quot;/META-INF/NOTICE&quot;&#10;            excludes += &quot;/META-INF/NOTICE.txt&quot;&#10;        }&#10;    }&#10;&#10;    // Build Performance Optimierungen&#10;    androidResources {&#10;        generateLocaleConfig = true&#10;    }&#10;&#10;    // Kompilierungs-Cache Optimierungen&#10;    compileSdk = 35&#10;&#10;    bundle {&#10;        language {&#10;            enableSplit = true&#10;        }&#10;        density {&#10;            enableSplit = true&#10;        }&#10;        abi {&#10;            enableSplit = true&#10;        }&#10;    }&#10;}&#10;&#10;dependencies {&#10;    // Core Library Desugaring - MUSS ZUERST STEHEN&#10;    coreLibraryDesugaring(&quot;com.android.tools:desugar_jdk_libs:2.0.4&quot;)&#10;&#10;    // Core Android &amp; Compose&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;&#10;    // Hilt&#10;    implementation(libs.hilt.android)&#10;    ksp(libs.hilt.compiler)&#10;    implementation(libs.hilt.navigation.compose)&#10;&#10;    // Networking&#10;    implementation(libs.retrofit)&#10;    implementation(libs.retrofit.gson)&#10;    implementation(libs.okhttp)&#10;    implementation(libs.okhttp.logging)&#10;&#10;    // Room&#10;    implementation(libs.room.runtime)&#10;    implementation(libs.room.ktx)&#10;    ksp(libs.room.compiler)&#10;&#10;    // Navigation&#10;    implementation(libs.navigation.compose)&#10;&#10;    // Image Loading&#10;    implementation(libs.coil.compose)&#10;&#10;    // OSM Maps&#10;    implementation(libs.osmdroid.android)&#10;&#10;    // WorkManager für Background Tasks&#10;    implementation(&quot;androidx.work:work-runtime-ktx:2.9.0&quot;)&#10;    implementation(&quot;androidx.hilt:hilt-work:1.1.0&quot;)&#10;&#10;    // Testing&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;}&#10;" />
              <option name="updatedContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    alias(libs.plugins.hilt.android)&#10;    alias(libs.plugins.ksp)&#10;    alias(libs.plugins.kotlin.serialization)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.example.geoguessrclone&quot;&#10;    compileSdk = 35&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.geoguessrclone&quot;&#10;        minSdk = 26&#10;        targetSdk = 35&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;        vectorDrawables {&#10;            useSupportLibrary = true&#10;        }&#10;&#10;        // Performance Optimierungen&#10;        multiDexEnabled = true&#10;&#10;        // ProGuard optimierte Konfiguration&#10;        ndk {&#10;            debugSymbolLevel = &quot;SYMBOL_TABLE&quot;&#10;        }&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = true // Aktiviert für bessere Performance&#10;            isShrinkResources = true // Entfernt unbenutzte Ressourcen&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;            buildConfigField(&quot;String&quot;, &quot;BASE_URL&quot;, &quot;\&quot;https://your-app.vercel.app\&quot;&quot;)&#10;            buildConfigField(&quot;String&quot;, &quot;SOCKET_URL&quot;, &quot;\&quot;wss://your-app.vercel.app\&quot;&quot;)&#10;&#10;            // Performance Optimierungen für Release&#10;            isDebuggable = false&#10;            renderscriptOptimLevel = 3&#10;        }&#10;        debug {&#10;            buildConfigField(&quot;String&quot;, &quot;BASE_URL&quot;, &quot;\&quot;https://your-app.vercel.app\&quot;&quot;)&#10;            buildConfigField(&quot;String&quot;, &quot;SOCKET_URL&quot;, &quot;\&quot;wss://your-app.vercel.app\&quot;&quot;)&#10;&#10;            // Debug Performance Optimierungen&#10;            isMinifyEnabled = false&#10;            applicationIdSuffix = &quot;.debug&quot;&#10;        }&#10;    }&#10;&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_17 // Upgrade für bessere Performance&#10;        targetCompatibility = JavaVersion.VERSION_17&#10;        isCoreLibraryDesugaringEnabled = true&#10;    }&#10;&#10;    kotlinOptions {&#10;        jvmTarget = &quot;17&quot;&#10;&#10;        // Kotlin Compiler Optimierungen&#10;        freeCompilerArgs += listOf(&#10;            &quot;-opt-in=androidx.compose.material3.ExperimentalMaterial3Api&quot;,&#10;            &quot;-opt-in=androidx.compose.foundation.ExperimentalFoundationApi&quot;,&#10;            &quot;-opt-in=kotlinx.coroutines.ExperimentalCoroutinesApi&quot;,&#10;            &quot;-Xjvm-default=all&quot;, // Bessere Java Interop Performance&#10;            &quot;-Xbackend-threads=4&quot; // Parallele Compilation&#10;        )&#10;    }&#10;&#10;    buildFeatures {&#10;        compose = true&#10;        buildConfig = true&#10;&#10;        // Deaktiviere unbenutzte Features für bessere Build Performance&#10;        viewBinding = false&#10;        dataBinding = false&#10;        aidl = false&#10;        renderScript = false&#10;        shaders = false&#10;    }&#10;&#10;    composeOptions {&#10;        kotlinCompilerExtensionVersion = &quot;1.5.15&quot;&#10;    }&#10;&#10;    packaging {&#10;        resources {&#10;            excludes += &quot;/META-INF/{AL2.0,LGPL2.1}&quot;&#10;            excludes += &quot;/META-INF/DEPENDENCIES&quot;&#10;            excludes += &quot;/META-INF/LICENSE&quot;&#10;            excludes += &quot;/META-INF/LICENSE.txt&quot;&#10;            excludes += &quot;/META-INF/NOTICE&quot;&#10;            excludes += &quot;/META-INF/NOTICE.txt&quot;&#10;        }&#10;    }&#10;&#10;    // Build Performance Optimierungen&#10;    androidResources {&#10;        // generateLocaleConfig = true - Entfernt da resources.properties fehlt&#10;    }&#10;&#10;    // Kompilierungs-Cache Optimierungen&#10;    compileSdk = 35&#10;&#10;    bundle {&#10;        language {&#10;            enableSplit = true&#10;        }&#10;        density {&#10;            enableSplit = true&#10;        }&#10;        abi {&#10;            enableSplit = true&#10;        }&#10;    }&#10;}&#10;&#10;dependencies {&#10;    // Core Library Desugaring - MUSS ZUERST STEHEN&#10;    coreLibraryDesugaring(&quot;com.android.tools:desugar_jdk_libs:2.0.4&quot;)&#10;&#10;    // Core Android &amp; Compose&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;&#10;    // Hilt&#10;    implementation(libs.hilt.android)&#10;    ksp(libs.hilt.compiler)&#10;    implementation(libs.hilt.navigation.compose)&#10;&#10;    // Networking&#10;    implementation(libs.retrofit)&#10;    implementation(libs.retrofit.gson)&#10;    implementation(libs.okhttp)&#10;    implementation(libs.okhttp.logging)&#10;&#10;    // Room&#10;    implementation(libs.room.runtime)&#10;    implementation(libs.room.ktx)&#10;    ksp(libs.room.compiler)&#10;&#10;    // Navigation&#10;    implementation(libs.navigation.compose)&#10;&#10;    // Image Loading&#10;    implementation(libs.coil.compose)&#10;&#10;    // OSM Maps&#10;    implementation(libs.osmdroid.android)&#10;&#10;    // WorkManager für Background Tasks&#10;    implementation(&quot;androidx.work:work-runtime-ktx:2.9.0&quot;)&#10;    implementation(&quot;androidx.hilt:hilt-work:1.1.0&quot;)&#10;&#10;    // Testing&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/proguard-rules.pro">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/proguard-rules.pro" />
              <option name="originalContent" value="# Add project specific ProGuard rules here.&#10;# You can control the set of applied configuration files using the&#10;# proguardFiles setting in build.gradle.&#10;#&#10;# For more details, see&#10;#   http://developer.android.com/guide/developing/tools/proguard.html&#10;&#10;# If your project uses WebView with JS, uncomment the following&#10;# and specify the fully qualified class name to the JavaScript interface&#10;# class:&#10;#-keepclassmembers class fqcn.of.javascript.interface.for.webview {&#10;#   public *;&#10;#}&#10;&#10;# Uncomment this to preserve the line number information for&#10;# debugging stack traces.&#10;#-keepattributes SourceFile,LineNumberTable&#10;&#10;# If you keep the line number information, uncomment this to&#10;# hide the original source file name.&#10;#-renamesourcefileattribute SourceFile" />
              <option name="updatedContent" value="# Add project specific ProGuard rules here.&#10;# You can control the set of applied configuration files using the&#10;# proguardFiles setting in build.gradle.&#10;#&#10;# For more details, see&#10;#   http://developer.android.com/guide/developing/tools/proguard.html&#10;&#10;# If your project uses WebView with JS, uncomment the following&#10;# and specify the fully qualified class name to the JavaScript interface&#10;# class:&#10;#-keepclassmembers class fqcn.of.javascript.interface.for.webview {&#10;#   public *;&#10;#}&#10;&#10;# Uncomment this to preserve the line number information for&#10;# debugging stack traces.&#10;#-keepattributes SourceFile,LineNumberTable&#10;&#10;# If you keep the line number information, uncomment this to&#10;# hide the original source file name.&#10;#-renamesourcefileattribute SourceFile&#10;&#10;# Performance optimizations&#10;-optimizationpasses 5&#10;-allowaccessmodification&#10;-mergeinterfacesaggressively&#10;&#10;# Retrofit&#10;-keepattributes Signature, InnerClasses, EnclosingMethod&#10;-keepattributes RuntimeVisibleAnnotations, RuntimeVisibleParameterAnnotations&#10;-keepattributes AnnotationDefault&#10;-keepclassmembers,allowshrinking,allowobfuscation interface * {&#10;    @retrofit2.http.* &lt;methods&gt;;&#10;}&#10;-dontwarn org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement&#10;-dontwarn javax.annotation.**&#10;-dontwarn kotlin.Unit&#10;-dontwarn retrofit2.KotlinExtensions&#10;&#10;# OkHttp&#10;-dontwarn okhttp3.**&#10;-dontwarn okio.**&#10;-dontwarn javax.annotation.**&#10;-keepnames class okhttp3.internal.publicsuffix.PublicSuffixDatabase&#10;&#10;# Room&#10;-keepattributes *Annotation*&#10;-keepclassmembers class * extends androidx.room.RoomDatabase {&#10;    *;&#10;}&#10;-keepclassmembers @androidx.room.Entity class * {&#10;    *;&#10;}&#10;&#10;# Coil&#10;-dontwarn coil.**&#10;&#10;# OSMDroid&#10;-dontwarn org.osmdroid.**&#10;&#10;# Hilt&#10;-dontwarn dagger.hilt.**&#10;&#10;# Kotlin Coroutines&#10;-keepnames class kotlinx.coroutines.internal.MainDispatcherFactory {}&#10;-keepnames class kotlinx.coroutines.CoroutineExceptionHandler {}&#10;-keepclassmembers class kotlinx.coroutines.** {&#10;    volatile &lt;fields&gt;;&#10;}&#10;&#10;# Remove logging in release&#10;-assumenosideeffects class android.util.Log {&#10;    public static *** d(...);&#10;    public static *** v(...);&#10;    public static *** i(...);&#10;}&#10;&#10;# Performance: Remove debug info&#10;-keepattributes !SourceFile,!LineNumberTable" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;!-- Permissions --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:name=&quot;com.example.geogeusserclone.GeoGuessrApplication&quot;&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.GeoGeusserClone&quot;&#10;        android:usesCleartextTraffic=&quot;true&quot;&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;com.example.geogeusserclone.ui.activities.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:theme=&quot;@style/Theme.GeoGeusserClone&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;com.example.geogeusserclone.ui.activities.AuthActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:theme=&quot;@style/Theme.GeoGeusserClone&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;com.example.geogeusserclone.ui.activities.MenuActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:theme=&quot;@style/Theme.GeoGeusserClone&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;com.example.geogeusserclone.ui.activities.GameActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:theme=&quot;@style/Theme.GeoGeusserClone&quot; /&gt;&#10;&#10;    &lt;/application&gt;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;!-- Permissions --&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:name=&quot;com.example.geogeusserclone.GeoGuessrApplication&quot;&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.GeoGeusserClone&quot;&#10;        android:usesCleartextTraffic=&quot;true&quot;&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;com.example.geogeusserclone.ui.activities.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:theme=&quot;@style/Theme.GeoGeusserClone&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;com.example.geogeusserclone.ui.activities.AuthActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:theme=&quot;@style/Theme.GeoGeusserClone&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;com.example.geogeusserclone.ui.activities.MenuActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:theme=&quot;@style/Theme.GeoGeusserClone&quot; /&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;com.example.geogeusserclone.ui.activities.GameActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:theme=&quot;@style/Theme.GeoGeusserClone&quot; /&gt;&#10;&#10;    &lt;/application&gt;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/DatabaseModule.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/DatabaseModule.kt" />
              <option name="originalContent" value="package com.example.geogeusserclone&#10;&#10;import android.content.Context&#10;import androidx.room.Room&#10;import androidx.room.migration.Migration&#10;import androidx.sqlite.db.SupportSQLiteDatabase&#10;import com.example.geogeusserclone.data.database.AppDatabase&#10;import dagger.Module&#10;import dagger.Provides&#10;import dagger.hilt.InstallIn&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#10;import dagger.hilt.components.SingletonComponent&#10;import javax.inject.Singleton&#10;&#10;@Module&#10;@InstallIn(SingletonComponent::class)&#10;object DatabaseModule {&#10;&#10;    private val MIGRATION_1_2 = object : Migration(1, 2) {&#10;        override fun migrate(database: SupportSQLiteDatabase) {&#10;            // Add indices&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_guesses_gameId` ON `guesses` (`gameId`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_guesses_locationId` ON `guesses` (`locationId`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_guesses_timestamp` ON `guesses` (`timestamp`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_userId` ON `games` (`userId`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_timestamp` ON `games` (`timestamp`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_isCompleted` ON `games` (`isCompleted`)&quot;)&#10;        }&#10;    }&#10;&#10;    private val MIGRATION_2_3 = object : Migration(2, 3) {&#10;        override fun migrate(database: SupportSQLiteDatabase) {&#10;            // Add missing columns to users table&#10;            database.execSQL(&quot;ALTER TABLE users ADD COLUMN totalScore INTEGER NOT NULL DEFAULT 0&quot;)&#10;            database.execSQL(&quot;ALTER TABLE users ADD COLUMN gamesPlayed INTEGER NOT NULL DEFAULT 0&quot;)&#10;            database.execSQL(&quot;ALTER TABLE users ADD COLUMN bestScore INTEGER NOT NULL DEFAULT 0&quot;)&#10;            database.execSQL(&quot;ALTER TABLE users ADD COLUMN lastLoginAt INTEGER NOT NULL DEFAULT 0&quot;)&#10;            database.execSQL(&quot;ALTER TABLE users ADD COLUMN createdAt INTEGER NOT NULL DEFAULT 0&quot;)&#10;            database.execSQL(&quot;ALTER TABLE locations ADD COLUMN isUsed INTEGER NOT NULL DEFAULT 0&quot;)&#10;&#10;        }&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {&#10;        return Room.databaseBuilder(&#10;            context,&#10;            AppDatabase::class.java,&#10;            &quot;geoguessr_database&quot;&#10;        )&#10;            .addMigrations(MIGRATION_1_2, MIGRATION_2_3)&#10;            .build()&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.geogeusserclone&#10;&#10;import android.content.Context&#10;import androidx.room.Room&#10;import androidx.room.migration.Migration&#10;import androidx.sqlite.db.SupportSQLiteDatabase&#10;import com.example.geogeusserclone.data.database.AppDatabase&#10;import dagger.Module&#10;import dagger.Provides&#10;import dagger.hilt.InstallIn&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#10;import dagger.hilt.components.SingletonComponent&#10;import java.util.concurrent.Executors&#10;import javax.inject.Singleton&#10;&#10;@Module&#10;@InstallIn(SingletonComponent::class)&#10;object DatabaseModule {&#10;&#10;    private val MIGRATION_1_2 = object : Migration(1, 2) {&#10;        override fun migrate(database: SupportSQLiteDatabase) {&#10;            // Add indices&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_guesses_gameId` ON `guesses` (`gameId`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_guesses_locationId` ON `guesses` (`locationId`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_guesses_timestamp` ON `guesses` (`timestamp`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_userId` ON `games` (`userId`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_timestamp` ON `games` (`timestamp`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_isCompleted` ON `games` (`isCompleted`)&quot;)&#10;        }&#10;    }&#10;&#10;    private val MIGRATION_2_3 = object : Migration(2, 3) {&#10;        override fun migrate(database: SupportSQLiteDatabase) {&#10;            // Add missing columns to users table&#10;            database.execSQL(&quot;ALTER TABLE users ADD COLUMN totalScore INTEGER NOT NULL DEFAULT 0&quot;)&#10;            database.execSQL(&quot;ALTER TABLE users ADD COLUMN gamesPlayed INTEGER NOT NULL DEFAULT 0&quot;)&#10;            database.execSQL(&quot;ALTER TABLE users ADD COLUMN bestScore INTEGER NOT NULL DEFAULT 0&quot;)&#10;            database.execSQL(&quot;ALTER TABLE users ADD COLUMN lastLoginAt INTEGER NOT NULL DEFAULT 0&quot;)&#10;            database.execSQL(&quot;ALTER TABLE users ADD COLUMN createdAt INTEGER NOT NULL DEFAULT 0&quot;)&#10;            database.execSQL(&quot;ALTER TABLE locations ADD COLUMN isUsed INTEGER NOT NULL DEFAULT 0&quot;)&#10;        }&#10;    }&#10;&#10;    private val MIGRATION_3_4 = object : Migration(3, 4) {&#10;        override fun migrate(database: SupportSQLiteDatabase) {&#10;            // Performance-optimierte Indizes hinzufügen&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_locations_isUsed_isCached` ON `locations` (`isUsed`, `isCached`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_locations_difficulty` ON `locations` (`difficulty`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_users_authToken` ON `users` (`authToken`)&quot;)&#10;            &#10;            // Composite Index für bessere Query Performance&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_userId_isCompleted_completedAt` ON `games` (`userId`, `isCompleted`, `completedAt`)&quot;)&#10;        }&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {&#10;        return Room.databaseBuilder(&#10;            context,&#10;            AppDatabase::class.java,&#10;            &quot;geoguessr_database&quot;&#10;        )&#10;            .addMigrations(MIGRATION_1_2, MIGRATION_2_3, MIGRATION_3_4)&#10;            .setQueryExecutor(Executors.newFixedThreadPool(4)) // Thread Pool für bessere Performance&#10;            .build()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/GeoGuessrApplication.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/GeoGuessrApplication.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone&#10;&#10;import android.app.Application&#10;import dagger.hilt.android.HiltAndroidApp&#10;&#10;@HiltAndroidApp&#10;class GeoGuessrApplication : Application() {&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/Networkmodule.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/Networkmodule.kt" />
              <option name="originalContent" value="package com.example.geogeusserclone&#10;&#10;import android.content.Context&#10;import com.example.geogeusserclone.data.network.ApiService&#10;import com.example.geogeusserclone.data.network.AuthInterceptor&#10;import com.example.geogeusserclone.utils.Constants&#10;import dagger.Module&#10;import dagger.Provides&#10;import dagger.hilt.InstallIn&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#10;import dagger.hilt.components.SingletonComponent&#10;import okhttp3.Cache&#10;import okhttp3.OkHttpClient&#10;import okhttp3.logging.HttpLoggingInterceptor&#10;import retrofit2.Retrofit&#10;import retrofit2.converter.gson.GsonConverterFactory&#10;import javax.inject.Singleton&#10;import java.util.concurrent.TimeUnit&#10;&#10;@Module&#10;@InstallIn(SingletonComponent::class)&#10;object NetworkModule {&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideCache(@ApplicationContext context: Context): Cache {&#10;        val cacheSize = 10 * 1024 * 1024L // 10 MB&#10;        return Cache(context.cacheDir, cacheSize)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideAuthInterceptor(): AuthInterceptor {&#10;        return AuthInterceptor()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideOkHttpClient(&#10;        authInterceptor: AuthInterceptor,&#10;        cache: Cache&#10;    ): OkHttpClient {&#10;        val loggingInterceptor = HttpLoggingInterceptor().apply {&#10;            level = HttpLoggingInterceptor.Level.BODY&#10;        }&#10;&#10;        return OkHttpClient.Builder()&#10;            .addInterceptor(authInterceptor)&#10;            .addInterceptor(loggingInterceptor)&#10;            .cache(cache)&#10;            .connectTimeout(5, TimeUnit.SECONDS) // Reduziere Timeout&#10;            .readTimeout(5, TimeUnit.SECONDS)&#10;            .writeTimeout(5, TimeUnit.SECONDS)&#10;            .build()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {&#10;        return Retrofit.Builder()&#10;            .baseUrl(Constants.BASE_URL) // Directly use Constants.BASE_URL&#10;            .client(okHttpClient)&#10;            .addConverterFactory(GsonConverterFactory.create())&#10;            .build()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideApiService(retrofit: Retrofit): ApiService {&#10;        return retrofit.create(ApiService::class.java)&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.geogeusserclone&#10;&#10;import android.content.Context&#10;import com.example.geogeusserclone.data.network.ApiService&#10;import com.example.geogeusserclone.data.network.AuthInterceptor&#10;import com.example.geogeusserclone.utils.Constants&#10;import dagger.Module&#10;import dagger.Provides&#10;import dagger.hilt.InstallIn&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#10;import dagger.hilt.components.SingletonComponent&#10;import okhttp3.Cache&#10;import okhttp3.OkHttpClient&#10;import okhttp3.logging.HttpLoggingInterceptor&#10;import retrofit2.Retrofit&#10;import retrofit2.converter.gson.GsonConverterFactory&#10;import javax.inject.Singleton&#10;import java.util.concurrent.TimeUnit&#10;&#10;@Module&#10;@InstallIn(SingletonComponent::class)&#10;object NetworkModule {&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideCache(@ApplicationContext context: Context): Cache {&#10;        val cacheSize = 10 * 1024 * 1024L // 10 MB&#10;        return Cache(context.cacheDir, cacheSize)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideAuthInterceptor(): AuthInterceptor {&#10;        return AuthInterceptor()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideOkHttpClient(&#10;        authInterceptor: AuthInterceptor,&#10;        cache: Cache&#10;    ): OkHttpClient {&#10;        val loggingInterceptor = HttpLoggingInterceptor().apply {&#10;            level = HttpLoggingInterceptor.Level.BODY&#10;        }&#10;&#10;        return OkHttpClient.Builder()&#10;            .addInterceptor(authInterceptor)&#10;            .addInterceptor(loggingInterceptor)&#10;            .cache(cache)&#10;            .connectTimeout(Constants.CONNECT_TIMEOUT, TimeUnit.SECONDS)&#10;            .readTimeout(Constants.READ_TIMEOUT, TimeUnit.SECONDS)&#10;            .writeTimeout(Constants.WRITE_TIMEOUT, TimeUnit.SECONDS)&#10;            .build()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {&#10;        return Retrofit.Builder()&#10;            .baseUrl(Constants.BASE_URL)&#10;            .client(okHttpClient)&#10;            .addConverterFactory(GsonConverterFactory.create())&#10;            .build()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideApiService(retrofit: Retrofit): ApiService {&#10;        return retrofit.create(ApiService::class.java)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/RepositoryModule.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/RepositoryModule.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone&#10;&#10;import com.example.geogeusserclone.data.database.AppDatabase&#10;import com.example.geogeusserclone.data.network.ApiService&#10;import com.example.geogeusserclone.data.network.AuthInterceptor&#10;import com.example.geogeusserclone.data.repositories.*&#10;import dagger.Module&#10;import dagger.Provides&#10;import dagger.hilt.InstallIn&#10;import dagger.hilt.components.SingletonComponent&#10;import javax.inject.Singleton&#10;&#10;@Module&#10;@InstallIn(SingletonComponent::class)&#10;object RepositoryModule {&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideUserRepository(&#10;        apiService: ApiService,&#10;        database: AppDatabase,&#10;        authInterceptor: AuthInterceptor&#10;    ): UserRepository {&#10;        return UserRepository(&#10;            apiService = apiService,&#10;            userDao = database.userDao(),&#10;            authInterceptor = authInterceptor&#10;        )&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideLocationRepository(&#10;        apiService: ApiService,&#10;        database: AppDatabase&#10;    ): LocationRepository {&#10;        return LocationRepository(&#10;            apiService = apiService,&#10;            locationDao = database.locationDao()&#10;        )&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideGameRepository(&#10;        apiService: ApiService,&#10;        database: AppDatabase,&#10;        userRepository: UserRepository&#10;    ): GameRepository {&#10;        return GameRepository(&#10;            apiService = apiService,&#10;            gameDao = database.gameDao(),&#10;            guessDao = database.guessDao(),&#10;            userRepository = userRepository&#10;        )&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideLocationCacheRepository(&#10;        apiService: ApiService,&#10;        database: AppDatabase&#10;    ): LocationCacheRepository {&#10;        return LocationCacheRepository(&#10;            apiService = apiService,&#10;            locationDao = database.locationDao()&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/database/AppDatabase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/database/AppDatabase.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.database&#10;&#10;import androidx.room.Database&#10;import androidx.room.Room&#10;import androidx.room.RoomDatabase&#10;import androidx.room.TypeConverters&#10;import com.example.geogeusserclone.data.database.dao.GameDao&#10;import com.example.geogeusserclone.data.database.dao.GuessDao&#10;import com.example.geogeusserclone.data.database.dao.LocationDao&#10;import com.example.geogeusserclone.data.database.dao.UserDao&#10;import com.example.geogeusserclone.data.database.entities.GameEntity&#10;import com.example.geogeusserclone.data.database.entities.GuessEntity&#10;import com.example.geogeusserclone.data.database.entities.LocationEntity&#10;import com.example.geogeusserclone.data.database.entities.UserEntity&#10;&#10;@Database(&#10;    entities = [&#10;        UserEntity::class,&#10;        GameEntity::class,&#10;        GuessEntity::class,&#10;        LocationEntity::class&#10;    ],&#10;    version = 4,&#10;    exportSchema = false&#10;)&#10;abstract class AppDatabase : RoomDatabase() {&#10;    abstract fun userDao(): UserDao&#10;    abstract fun gameDao(): GameDao&#10;    abstract fun guessDao(): GuessDao&#10;    abstract fun locationDao(): LocationDao&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/database/dao/GameDao.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/database/dao/GameDao.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.database.dao&#10;&#10;import androidx.room.*&#10;import com.example.geogeusserclone.data.database.entities.GameEntity&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;@Dao&#10;interface GameDao {&#10;&#10;    @Query(&quot;SELECT * FROM games WHERE userId = :userId ORDER BY createdAt DESC&quot;)&#10;    fun getGamesByUser(userId: String): Flow&lt;List&lt;GameEntity&gt;&gt;&#10;&#10;    @Query(&quot;SELECT * FROM games WHERE id = :gameId&quot;)&#10;    suspend fun getGameById(gameId: String): GameEntity?&#10;&#10;    @Query(&quot;SELECT * FROM games WHERE userId = :userId AND isCompleted = 0 ORDER BY createdAt DESC LIMIT 1&quot;)&#10;    suspend fun getCurrentGameForUser(userId: String): GameEntity?&#10;&#10;    @Query(&quot;SELECT * FROM games ORDER BY score DESC LIMIT :limit&quot;)&#10;    suspend fun getTopScores(limit: Int = 10): List&lt;GameEntity&gt;&#10;&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertGame(game: GameEntity)&#10;&#10;    @Update&#10;    suspend fun updateGame(game: GameEntity)&#10;&#10;    @Delete&#10;    suspend fun deleteGame(game: GameEntity)&#10;&#10;    @Query(&quot;DELETE FROM games WHERE userId = :userId&quot;)&#10;    suspend fun deleteAllGamesForUser(userId: String)&#10;&#10;    @Query(&quot;SELECT COUNT(*) FROM games WHERE userId = :userId AND isCompleted = 1&quot;)&#10;    suspend fun getCompletedGamesCount(userId: String): Int&#10;&#10;    @Query(&quot;SELECT AVG(score) FROM games WHERE userId = :userId AND isCompleted = 1&quot;)&#10;    suspend fun getAverageScore(userId: String): Double?&#10;&#10;    @Query(&quot;SELECT MAX(score) FROM games WHERE userId = :userId AND isCompleted = 1&quot;)&#10;    suspend fun getBestScore(userId: String): Int?&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/database/dao/GuessDao.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/database/dao/GuessDao.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.database.dao&#10;&#10;import androidx.room.*&#10;import com.example.geogeusserclone.data.database.entities.GuessEntity&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;@Dao&#10;interface GuessDao {&#10;&#10;    @Query(&quot;SELECT * FROM guesses WHERE gameId = :gameId ORDER BY submittedAt ASC&quot;)&#10;    fun getGuessesByGame(gameId: String): Flow&lt;List&lt;GuessEntity&gt;&gt;&#10;&#10;    @Query(&quot;SELECT * FROM guesses WHERE id = :guessId&quot;)&#10;    suspend fun getGuessById(guessId: String): GuessEntity?&#10;&#10;    @Query(&quot;SELECT * FROM guesses WHERE gameId = :gameId ORDER BY score DESC LIMIT 1&quot;)&#10;    suspend fun getBestGuessForGame(gameId: String): GuessEntity?&#10;&#10;    @Query(&quot;SELECT * FROM guesses WHERE gameId = :gameId ORDER BY score ASC LIMIT 1&quot;)&#10;    suspend fun getWorstGuessForGame(gameId: String): GuessEntity?&#10;&#10;    @Query(&quot;SELECT AVG(distance) FROM guesses WHERE gameId = :gameId&quot;)&#10;    suspend fun getAverageDistanceForGame(gameId: String): Double?&#10;&#10;    @Query(&quot;SELECT AVG(score) FROM guesses WHERE gameId = :gameId&quot;)&#10;    suspend fun getAverageScoreForGame(gameId: String): Double?&#10;&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertGuess(guess: GuessEntity)&#10;&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertGuesses(guesses: List&lt;GuessEntity&gt;)&#10;&#10;    @Update&#10;    suspend fun updateGuess(guess: GuessEntity)&#10;&#10;    @Delete&#10;    suspend fun deleteGuess(guess: GuessEntity)&#10;&#10;    @Query(&quot;DELETE FROM guesses WHERE gameId = :gameId&quot;)&#10;    suspend fun deleteGuessesForGame(gameId: String)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/database/dao/LocationDao.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/database/dao/LocationDao.kt" />
              <option name="originalContent" value="package com.example.geogeusserclone.data.database.dao&#10;&#10;import androidx.room.*&#10;import com.example.geogeusserclone.data.database.entities.LocationEntity&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;@Dao&#10;interface LocationDao {&#10;&#10;    @Query(&quot;SELECT * FROM locations WHERE isCached = 1&quot;)&#10;    fun getCachedLocations(): Flow&lt;List&lt;LocationEntity&gt;&gt;&#10;&#10;    @Query(&quot;SELECT * FROM locations WHERE id = :locationId&quot;)&#10;    suspend fun getLocationById(locationId: String): LocationEntity?&#10;&#10;    @Query(&quot;SELECT * FROM locations ORDER BY RANDOM() LIMIT :count&quot;)&#10;    suspend fun getRandomLocations(count: Int): List&lt;LocationEntity&gt;&#10;&#10;    @Query(&quot;SELECT * FROM locations WHERE isUsed = 0 ORDER BY RANDOM() LIMIT 1&quot;)&#10;    suspend fun getRandomUnusedLocation(): LocationEntity?&#10;&#10;    @Query(&quot;SELECT * FROM locations&quot;)&#10;    suspend fun getAllLocations(): List&lt;LocationEntity&gt;&#10;&#10;    @Query(&quot;UPDATE locations SET isUsed = 1 WHERE id = :locationId&quot;)&#10;    suspend fun markLocationAsUsed(locationId: String)&#10;&#10;    @Query(&quot;UPDATE locations SET isUsed = 0&quot;)&#10;    suspend fun resetAllLocationsUsage()&#10;&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertLocation(location: LocationEntity)&#10;&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertLocations(locations: List&lt;LocationEntity&gt;)&#10;&#10;    @Update&#10;    suspend fun updateLocation(location: LocationEntity)&#10;&#10;    @Query(&quot;DELETE FROM locations WHERE isCached = 0&quot;)&#10;    suspend fun deleteNonCachedLocations()&#10;&#10;    @Query(&quot;SELECT COUNT(*) FROM locations WHERE isCached = 1&quot;)&#10;    suspend fun getCachedLocationCount(): Int&#10;}" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.database.dao&#13;&#10;&#13;&#10;import androidx.room.*&#13;&#10;import com.example.geogeusserclone.data.database.entities.LocationEntity&#13;&#10;import kotlinx.coroutines.flow.Flow&#13;&#10;&#13;&#10;@Dao&#13;&#10;interface LocationDao {&#13;&#10;&#13;&#10;    @Query(&quot;SELECT * FROM locations WHERE isCached = 1&quot;)&#13;&#10;    fun getCachedLocations(): Flow&lt;List&lt;LocationEntity&gt;&gt;&#13;&#10;&#13;&#10;    @Query(&quot;SELECT * FROM locations WHERE id = :locationId&quot;)&#13;&#10;    suspend fun getLocationById(locationId: String): LocationEntity?&#13;&#10;&#13;&#10;    @Query(&quot;SELECT * FROM locations ORDER BY RANDOM() LIMIT :count&quot;)&#13;&#10;    suspend fun getRandomLocations(count: Int): List&lt;LocationEntity&gt;&#13;&#10;&#13;&#10;    @Query(&quot;SELECT * FROM locations WHERE isUsed = 0 ORDER BY RANDOM() LIMIT 1&quot;)&#13;&#10;    suspend fun getRandomUnusedLocation(): LocationEntity?&#13;&#10;&#13;&#10;    @Query(&quot;SELECT * FROM locations WHERE isUsed = 0 ORDER BY RANDOM() LIMIT :count&quot;)&#13;&#10;    suspend fun getUnusedLocations(count: Int): List&lt;LocationEntity&gt;&#13;&#10;&#13;&#10;    @Query(&quot;SELECT * FROM locations&quot;)&#13;&#10;    suspend fun getAllLocations(): List&lt;LocationEntity&gt;&#13;&#10;&#13;&#10;    @Query(&quot;UPDATE locations SET isUsed = 1 WHERE id = :locationId&quot;)&#13;&#10;    suspend fun markLocationAsUsed(locationId: String)&#13;&#10;&#13;&#10;    @Query(&quot;UPDATE locations SET isUsed = 0&quot;)&#13;&#10;    suspend fun resetAllLocationsUsage()&#13;&#10;&#13;&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#13;&#10;    suspend fun insertLocation(location: LocationEntity)&#13;&#10;&#13;&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#13;&#10;    suspend fun insertLocations(locations: List&lt;LocationEntity&gt;)&#13;&#10;&#13;&#10;    @Update&#13;&#10;    suspend fun updateLocation(location: LocationEntity)&#13;&#10;&#13;&#10;    @Query(&quot;DELETE FROM locations WHERE isCached = 0&quot;)&#13;&#10;    suspend fun deleteNonCachedLocations()&#13;&#10;&#13;&#10;    @Query(&quot;SELECT COUNT(*) FROM locations WHERE isCached = 1&quot;)&#13;&#10;    suspend fun getCachedLocationCount(): Int&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/database/dao/UserDao.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/database/dao/UserDao.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.database.dao&#10;&#10;import androidx.room.*&#10;import com.example.geogeusserclone.data.database.entities.UserEntity&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;@Dao&#10;interface UserDao {&#10;&#10;    @Query(&quot;SELECT * FROM users ORDER BY lastLoginAt DESC LIMIT 1&quot;)&#10;    suspend fun getCurrentUser(): UserEntity?&#10;&#10;    @Query(&quot;SELECT * FROM users WHERE id = :userId&quot;)&#10;    suspend fun getUserById(userId: String): UserEntity?&#10;&#10;    @Query(&quot;SELECT * FROM users WHERE email = :email&quot;)&#10;    suspend fun getUserByEmail(email: String): UserEntity?&#10;&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertUser(user: UserEntity)&#10;&#10;    @Update&#10;    suspend fun updateUser(user: UserEntity)&#10;&#10;    @Query(&quot;DELETE FROM users&quot;)&#10;    suspend fun clearCurrentUser()&#10;&#10;    @Query(&quot;SELECT * FROM users ORDER BY totalScore DESC LIMIT :limit&quot;)&#10;    suspend fun getTopUsers(limit: Int = 10): List&lt;UserEntity&gt;&#10;&#10;    @Query(&quot;UPDATE users SET totalScore = totalScore + :scoreToAdd, gamesPlayed = gamesPlayed + 1 WHERE id = :userId&quot;)&#10;    suspend fun updateUserScore(userId: String, scoreToAdd: Int)&#10;&#10;    @Query(&quot;UPDATE users SET bestScore = :newBestScore WHERE id = :userId AND bestScore &lt; :newBestScore&quot;)&#10;    suspend fun updateBestScore(userId: String, newBestScore: Int)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/database/entities/LocationEntity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/database/entities/LocationEntity.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.database.entities&#10;&#10;import androidx.room.Entity&#10;import androidx.room.Index&#10;import androidx.room.PrimaryKey&#10;&#10;@Entity(&#10;    tableName = &quot;locations&quot;,&#10;    indices = [&#10;        Index(value = [&quot;isUsed&quot;, &quot;isCached&quot;]),&#10;        Index(value = [&quot;difficulty&quot;]),&#10;        Index(value = [&quot;country&quot;])&#10;    ]&#10;)&#10;data class LocationEntity(&#10;    @PrimaryKey val id: String,&#10;    val latitude: Double,&#10;    val longitude: Double,&#10;    val imageUrl: String,&#10;    val country: String? = null,&#10;    val city: String? = null,&#10;    val difficulty: Int = 1, // 1-5 Schwierigkeitsgrad&#10;    val isCached: Boolean = false,&#10;    val isUsed: Boolean = false,&#10;    val createdAt: Long = System.currentTimeMillis()&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/database/entities/UserEntity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/database/entities/UserEntity.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.database.entities&#10;&#10;import androidx.room.Entity&#10;import androidx.room.Index&#10;import androidx.room.PrimaryKey&#10;&#10;@Entity(&#10;    tableName = &quot;users&quot;,&#10;    indices = [&#10;        Index(value = [&quot;email&quot;], unique = true),&#10;        Index(value = [&quot;authToken&quot;]),&#10;        Index(value = [&quot;lastLoginAt&quot;])&#10;    ]&#10;)&#10;data class UserEntity(&#10;    @PrimaryKey val id: String,&#10;    val username: String,&#10;    val email: String,&#10;    val authToken: String? = null,&#10;    val totalScore: Int = 0,&#10;    val gamesPlayed: Int = 0,&#10;    val bestScore: Int = 0,&#10;    val lastLoginAt: Long = System.currentTimeMillis(),&#10;    val createdAt: Long = System.currentTimeMillis()&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/models/GameState.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/models/GameState.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.models&#10;&#10;import com.example.geogeusserclone.data.database.entities.GameEntity&#10;import com.example.geogeusserclone.data.database.entities.GuessEntity&#10;import com.example.geogeusserclone.data.database.entities.LocationEntity&#10;&#10;data class GameState(&#10;    val currentGame: GameEntity? = null,&#10;    val currentLocation: LocationEntity? = null,&#10;    val currentGuess: GuessEntity? = null,&#10;    val revealGuessResult: GuessEntity? = null,&#10;    val isLoading: Boolean = false,&#10;    val showMap: Boolean = false,&#10;    val showRoundResult: Boolean = false,&#10;    val showGameCompletion: Boolean = false,&#10;    val timeRemaining: Long = 0L,&#10;    val error: String? = null&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/models/GameStats.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/models/GameStats.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.models&#10;&#10;data class GameStats(&#10;    val totalGames: Int = 0,&#10;    val totalScore: Int = 0,&#10;    val averageScore: Double = 0.0,&#10;    val bestScore: Int = 0,&#10;    val perfectGuesses: Int = 0,&#10;    val averageDistance: Double = 0.0,&#10;    val bestDistance: Double = Double.MAX_VALUE,&#10;    val totalTimeSpent: Long = 0L,&#10;    val averageTimePerRound: Long = 0L,&#10;    val gamesWon: Int = 0,&#10;    val winRate: Double = 0.0,&#10;    val favoriteCountry: String? = null,&#10;    val monthlyStats: List&lt;MonthlyGameStats&gt; = emptyList()&#10;)&#10;&#10;data class MonthlyGameStats(&#10;    val month: String,&#10;    val year: Int,&#10;    val gamesPlayed: Int,&#10;    val totalScore: Int,&#10;    val averageScore: Double&#10;)&#10;&#10;data class UserStats(&#10;    val userId: String,&#10;    val username: String,&#10;    val totalGames: Int,&#10;    val totalScore: Int,&#10;    val averageScore: Double,&#10;    val bestScore: Int,&#10;    val rank: Int = 0,&#10;    val lastActive: Long = 0L&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/network/AuthInterceptor.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/network/AuthInterceptor.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.network&#10;&#10;import okhttp3.Interceptor&#10;import okhttp3.Response&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class AuthInterceptor @Inject constructor() : Interceptor {&#10;    &#10;    private var authToken: String? = null&#10;    &#10;    fun setAuthToken(token: String?) {&#10;        authToken = token&#10;    }&#10;    &#10;    override fun intercept(chain: Interceptor.Chain): Response {&#10;        val originalRequest = chain.request()&#10;        &#10;        val requestBuilder = originalRequest.newBuilder()&#10;            .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;            .addHeader(&quot;Accept&quot;, &quot;application/json&quot;)&#10;        &#10;        authToken?.let { token -&gt;&#10;            requestBuilder.addHeader(&quot;Authorization&quot;, &quot;Bearer $token&quot;)&#10;        }&#10;        &#10;        return chain.proceed(requestBuilder.build())&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/network/NetworkResult.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/network/NetworkResult.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.network&#10;&#10;sealed class NetworkResult&lt;T&gt; {&#10;    data class Success&lt;T&gt;(val data: T) : NetworkResult&lt;T&gt;()&#10;    data class Error&lt;T&gt;(val message: String, val code: Int? = null) : NetworkResult&lt;T&gt;()&#10;    data class Exception&lt;T&gt;(val e: Throwable) : NetworkResult&lt;T&gt;()&#10;    class Loading&lt;T&gt; : NetworkResult&lt;T&gt;()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/repositories/BaseRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/repositories/BaseRepository.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.repositories&#10;&#10;abstract class BaseRepository {&#10;    &#10;    protected suspend fun &lt;T&gt; safeApiCall(&#10;        apiCall: suspend () -&gt; T&#10;    ): Result&lt;T&gt; {&#10;        return try {&#10;            Result.success(apiCall())&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;    &#10;    protected fun &lt;T&gt; handleApiResponse(&#10;        response: retrofit2.Response&lt;T&gt;&#10;    ): Result&lt;T&gt; {&#10;        return if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;            Result.success(response.body()!!)&#10;        } else {&#10;            Result.failure(Exception(&quot;API Error: ${response.code()} ${response.message()}&quot;))&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/repositories/GameRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/repositories/GameRepository.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.repositories&#10;&#10;import com.example.geogeusserclone.data.database.dao.GameDao&#10;import com.example.geogeusserclone.data.database.dao.GuessDao&#10;import com.example.geogeusserclone.data.database.entities.GameEntity&#10;import com.example.geogeusserclone.data.database.entities.GuessEntity&#10;import com.example.geogeusserclone.data.network.ApiService&#10;import com.example.geogeusserclone.data.network.CreateGameRequest&#10;import com.example.geogeusserclone.data.network.GuessRequest&#10;import com.example.geogeusserclone.utils.DistanceCalculator&#10;import com.example.geogeusserclone.utils.ScoreCalculator&#10;import kotlinx.coroutines.flow.Flow&#10;import java.util.UUID&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class GameRepository @Inject constructor(&#10;    private val apiService: ApiService,&#10;    private val gameDao: GameDao,&#10;    private val guessDao: GuessDao,&#10;    private val userRepository: UserRepository&#10;) : BaseRepository() {&#10;&#10;    suspend fun createGame(&#10;        userId: String,&#10;        gameMode: String,&#10;        rounds: Int&#10;    ): Result&lt;GameEntity&gt; {&#10;        return try {&#10;            // Versuche zuerst online zu erstellen&#10;            val response = apiService.createGame(CreateGameRequest(gameMode, rounds))&#10;            if (response.isSuccessful) {&#10;                val gameResponse = response.body()!!&#10;                val gameEntity = GameEntity(&#10;                    id = gameResponse.id,&#10;                    userId = userId,&#10;                    gameMode = gameMode,&#10;                    totalRounds = rounds,&#10;                    currentRound = 1,&#10;                    score = 0,&#10;                    isCompleted = false,&#10;                    createdAt = System.currentTimeMillis(),&#10;                    startedAt = System.currentTimeMillis()&#10;                )&#10;                gameDao.insertGame(gameEntity)&#10;                Result.success(gameEntity)&#10;            } else {&#10;                createOfflineGame(userId, gameMode, rounds)&#10;            }&#10;        } catch (e: Exception) {&#10;            // Fallback für Offline-Modus&#10;            createOfflineGame(userId, gameMode, rounds)&#10;        }&#10;    }&#10;&#10;    private suspend fun createOfflineGame(&#10;        userId: String,&#10;        gameMode: String,&#10;        rounds: Int&#10;    ): Result&lt;GameEntity&gt; {&#10;        val gameEntity = GameEntity(&#10;            id = UUID.randomUUID().toString(),&#10;            userId = userId,&#10;            gameMode = gameMode,&#10;            totalRounds = rounds,&#10;            currentRound = 1,&#10;            score = 0,&#10;            isCompleted = false,&#10;            createdAt = System.currentTimeMillis(),&#10;            startedAt = System.currentTimeMillis()&#10;        )&#10;        gameDao.insertGame(gameEntity)&#10;        return Result.success(gameEntity)&#10;    }&#10;&#10;    suspend fun submitGuess(&#10;        gameId: String,&#10;        locationId: String,&#10;        guessLat: Double,&#10;        guessLng: Double,&#10;        actualLat: Double,&#10;        actualLng: Double,&#10;        timeSpent: Long&#10;    ): Result&lt;GuessEntity&gt; {&#10;        return try {&#10;            // Berechne Score und Distanz lokal&#10;            val distance = DistanceCalculator.calculateDistance(&#10;                guessLat, guessLng, actualLat, actualLng&#10;            )&#10;            val score = ScoreCalculator.calculateScore(distance, timeSpent)&#10;&#10;            val guessEntity = GuessEntity(&#10;                id = UUID.randomUUID().toString(),&#10;                gameId = gameId,&#10;                locationId = locationId,&#10;                guessLat = guessLat,&#10;                guessLng = guessLng,&#10;                actualLat = actualLat,&#10;                actualLng = actualLng,&#10;                distance = distance,&#10;                score = score,&#10;                timeSpent = timeSpent,&#10;                submittedAt = System.currentTimeMillis()&#10;            )&#10;&#10;            // Speichere Guess lokal&#10;            guessDao.insertGuess(guessEntity)&#10;&#10;            // Update Game Score&#10;            val currentGame = gameDao.getGameById(gameId)&#10;            if (currentGame != null) {&#10;                val updatedGame = currentGame.copy(&#10;                    score = currentGame.score + score,&#10;                    currentRound = currentGame.currentRound + 1&#10;                )&#10;                gameDao.updateGame(updatedGame)&#10;            }&#10;&#10;            // Versuche online zu synchronisieren&#10;            try {&#10;                apiService.submitGuess(&#10;                    gameId,&#10;                    GuessRequest(locationId, guessLat, guessLng, timeSpent)&#10;                )&#10;            } catch (e: Exception) {&#10;                // Silent fail - Guess ist bereits lokal gespeichert&#10;            }&#10;&#10;            Result.success(guessEntity)&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    suspend fun completeGame(gameId: String): Result&lt;GameEntity&gt; {&#10;        return try {&#10;            val game = gameDao.getGameById(gameId)&#10;            if (game != null) {&#10;                val completedGame = game.copy(&#10;                    isCompleted = true,&#10;                    completedAt = System.currentTimeMillis(),&#10;                    duration = System.currentTimeMillis() - (game.startedAt ?: game.createdAt)&#10;                )&#10;                gameDao.updateGame(completedGame)&#10;&#10;                // Update User Stats&#10;                userRepository.updateUserStats(&#10;                    totalScore = completedGame.score,&#10;                    gamesPlayed = 1,&#10;                    bestScore = completedGame.score&#10;                )&#10;&#10;                Result.success(completedGame)&#10;            } else {&#10;                Result.failure(Exception(&quot;Spiel nicht gefunden&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    fun getGameHistory(userId: String): Flow&lt;List&lt;GameEntity&gt;&gt; {&#10;        return gameDao.getGamesByUser(userId)&#10;    }&#10;&#10;    fun getGuessesByGame(gameId: String): Flow&lt;List&lt;GuessEntity&gt;&gt; {&#10;        return guessDao.getGuessesByGame(gameId)&#10;    }&#10;&#10;    suspend fun getCurrentGame(userId: String): GameEntity? {&#10;        return gameDao.getCurrentGameForUser(userId)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/repositories/LocationCacheRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/repositories/LocationCacheRepository.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.repositories&#10;&#10;import com.example.geogeusserclone.data.database.dao.LocationDao&#10;import com.example.geogeusserclone.data.database.entities.LocationEntity&#10;import com.example.geogeusserclone.data.network.ApiService&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.withContext&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class LocationCacheRepository @Inject constructor(&#10;    private val apiService: ApiService,&#10;    private val locationDao: LocationDao&#10;) {&#10;&#10;    suspend fun preloadLocationsInBackground() = withContext(Dispatchers.IO) {&#10;        try {&#10;            // Lade nur wenn weniger als 10 Locations im Cache&#10;            val cachedCount = locationDao.getCachedLocationCount()&#10;            if (cachedCount &lt; 10) {&#10;                val response = apiService.getLocations(50)&#10;                if (response.isSuccessful) {&#10;                    val locationsResponse = response.body()!!&#10;                    val locationEntities = locationsResponse.locations.map { location -&gt;&#10;                        LocationEntity(&#10;                            id = location.id,&#10;                            latitude = location.latitude,&#10;                            longitude = location.longitude,&#10;                            imageUrl = location.imageUrl,&#10;                            country = location.country,&#10;                            city = location.city,&#10;                            difficulty = location.difficulty,&#10;                            isCached = true,&#10;                            isUsed = false&#10;                        )&#10;                    }&#10;                    &#10;                    // Batch insert für bessere Performance&#10;                    locationDao.insertLocations(locationEntities)&#10;                    &#10;                    // Preload images im Hintergrund&#10;                    preloadImages(locationEntities.take(5)) // Nur erste 5 Bilder&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            // Silent fail - App funktioniert weiter mit Fallback Locations&#10;        }&#10;    }&#10;&#10;    private suspend fun preloadImages(locations: List&lt;LocationEntity&gt;) = withContext(Dispatchers.IO) {&#10;        // Implementierung für Image Preloading&#10;        // Dies würde die Bilder in den Cache laden ohne sie anzuzeigen&#10;    }&#10;&#10;    suspend fun getNextLocations(count: Int = 3): List&lt;LocationEntity&gt; = withContext(Dispatchers.IO) {&#10;        locationDao.getUnusedLocations(count)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/repositories/UserRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/repositories/UserRepository.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.repositories&#10;&#10;import com.example.geogeusserclone.data.database.dao.UserDao&#10;import com.example.geogeusserclone.data.database.entities.UserEntity&#10;import com.example.geogeusserclone.data.network.ApiService&#10;import com.example.geogeusserclone.data.network.AuthInterceptor&#10;import com.example.geogeusserclone.data.network.LoginRequest&#10;import com.example.geogeusserclone.data.network.RegisterRequest&#10;import kotlinx.coroutines.flow.Flow&#10;import java.util.UUID&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class UserRepository @Inject constructor(&#10;    private val apiService: ApiService,&#10;    private val userDao: UserDao,&#10;    private val authInterceptor: AuthInterceptor&#10;) : BaseRepository() {&#10;&#10;    suspend fun getCurrentUser(): UserEntity? {&#10;        return userDao.getCurrentUser()&#10;    }&#10;&#10;    suspend fun login(email: String, password: String): Result&lt;UserEntity&gt; {&#10;        return try {&#10;            val response = apiService.login(LoginRequest(email, password))&#10;            if (response.isSuccessful) {&#10;                val loginResponse = response.body()!!&#10;                &#10;                // Setze Auth Token&#10;                authInterceptor.setAuthToken(loginResponse.token)&#10;                &#10;                val userEntity = UserEntity(&#10;                    id = loginResponse.user.id,&#10;                    username = loginResponse.user.username,&#10;                    email = loginResponse.user.email,&#10;                    authToken = loginResponse.token,&#10;                    totalScore = loginResponse.user.totalScore,&#10;                    gamesPlayed = loginResponse.user.gamesPlayed,&#10;                    bestScore = loginResponse.user.bestScore,&#10;                    lastLoginAt = System.currentTimeMillis(),&#10;                    createdAt = System.currentTimeMillis()&#10;                )&#10;                &#10;                userDao.insertUser(userEntity)&#10;                Result.success(userEntity)&#10;            } else {&#10;                Result.failure(Exception(&quot;Login fehlgeschlagen: ${response.message()}&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            // Fallback für Offline-Modus&#10;            val offlineUser = createOfflineUser(email)&#10;            userDao.insertUser(offlineUser)&#10;            Result.success(offlineUser)&#10;        }&#10;    }&#10;&#10;    suspend fun register(username: String, email: String, password: String): Result&lt;UserEntity&gt; {&#10;        return try {&#10;            val response = apiService.register(RegisterRequest(username, email, password))&#10;            if (response.isSuccessful) {&#10;                val loginResponse = response.body()!!&#10;                &#10;                authInterceptor.setAuthToken(loginResponse.token)&#10;                &#10;                val userEntity = UserEntity(&#10;                    id = loginResponse.user.id,&#10;                    username = loginResponse.user.username,&#10;                    email = loginResponse.user.email,&#10;                    authToken = loginResponse.token,&#10;                    totalScore = 0,&#10;                    gamesPlayed = 0,&#10;                    bestScore = 0,&#10;                    lastLoginAt = System.currentTimeMillis(),&#10;                    createdAt = System.currentTimeMillis()&#10;                )&#10;                &#10;                userDao.insertUser(userEntity)&#10;                Result.success(userEntity)&#10;            } else {&#10;                Result.failure(Exception(&quot;Registrierung fehlgeschlagen: ${response.message()}&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            // Fallback für Offline-Modus&#10;            val offlineUser = createOfflineUser(email, username)&#10;            userDao.insertUser(offlineUser)&#10;            Result.success(offlineUser)&#10;        }&#10;    }&#10;&#10;    suspend fun logout() {&#10;        authInterceptor.setAuthToken(null)&#10;        userDao.clearCurrentUser()&#10;    }&#10;&#10;    suspend fun updateUserStats(totalScore: Int, gamesPlayed: Int, bestScore: Int) {&#10;        val currentUser = userDao.getCurrentUser()&#10;        currentUser?.let { user -&gt;&#10;            val updatedUser = user.copy(&#10;                totalScore = totalScore,&#10;                gamesPlayed = gamesPlayed,&#10;                bestScore = if (bestScore &gt; user.bestScore) bestScore else user.bestScore,&#10;                lastLoginAt = System.currentTimeMillis()&#10;            )&#10;            userDao.updateUser(updatedUser)&#10;        }&#10;    }&#10;&#10;    private fun createOfflineUser(email: String, username: String? = null): UserEntity {&#10;        return UserEntity(&#10;            id = UUID.randomUUID().toString(),&#10;            username = username ?: email.substringBefore(&quot;@&quot;),&#10;            email = email,&#10;            authToken = null,&#10;            totalScore = 0,&#10;            gamesPlayed = 0,&#10;            bestScore = 0,&#10;            lastLoginAt = System.currentTimeMillis(),&#10;            createdAt = System.currentTimeMillis()&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/ui/activities/GameActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/ui/activities/GameActivity.kt" />
              <option name="originalContent" value="package com.example.geogeusserclone.ui.activities&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.ArrowBack&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import com.example.geogeusserclone.ui.components.MapGuessComponent&#10;import com.example.geogeusserclone.ui.components.StreetViewComponent&#10;import com.example.geogeusserclone.ui.theme.GeoGeusserCloneTheme&#10;import com.example.geogeusserclone.viewmodels.GameViewModel&#10;import dagger.hilt.android.AndroidEntryPoint&#10;import com.example.geogeusserclone.ui.components.GameCompletionScreen&#10;import com.example.geogeusserclone.ui.components.RoundResulView&#10;import com.example.geogeusserclone.utils.enableEdgeToEdge&#10;&#10;@AndroidEntryPoint&#10;class GameActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            GeoGeusserCloneTheme {&#10;                GameScreen(&#10;                    onNavigateBack = { finish() }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun GameScreen(&#10;    onNavigateBack: () -&gt; Unit,&#10;    gameViewModel: GameViewModel = hiltViewModel()&#10;) {&#10;    val gameState by gameViewModel.uiState.collectAsState()&#10;&#10;    LaunchedEffect(Unit) {&#10;        if (gameState.currentGame == null) {&#10;            gameViewModel.startNewGame()&#10;        }&#10;    }&#10;&#10;    if (gameState.isLoading &amp;&amp; gameState.currentGame == null) {&#10;        Box(&#10;            modifier = Modifier.fillMaxSize(),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            CircularProgressIndicator()&#10;        }&#10;        return&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = {&#10;                    gameState.currentGame?.let { game -&gt;&#10;                        Text(&quot;Runde ${game.currentRound}/${game.totalRounds}&quot;)&#10;                    }&#10;                },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onNavigateBack) {&#10;                        Icon(Icons.Default.ArrowBack, contentDescription = &quot;Zurück&quot;)&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    ) { paddingValues -&gt;&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues)&#10;        ) {&#10;            when {&#10;                gameState.showMap -&gt; {&#10;                    MapGuessComponent(&#10;                        onGuessSelected = { lat, lng -&gt;&#10;                            gameViewModel.submitGuess(lat, lng)&#10;                        },&#10;                        onMapClose = {&#10;                            gameViewModel.hideMap()&#10;                        }&#10;                    )&#10;                }&#10;&#10;                gameState.showRoundResult -&gt; {&#10;                    RoundResultScreen(&#10;                        guess = gameState.revealGuessResult,&#10;                        onNextRound = {&#10;                            gameViewModel.proceedToNextRound()&#10;                        }&#10;                    )&#10;                }&#10;&#10;                gameState.showGameCompletion -&gt; {&#10;                    GameCompletionScreen(&#10;                        game = gameState.currentGame,&#10;                        onPlayAgain = {&#10;                            gameViewModel.startNewGame()&#10;                        },&#10;                        onBackToMenu = onNavigateBack&#10;                    )&#10;                }&#10;&#10;                else -&gt; {&#10;                    GamePlayScreen(&#10;                        gameState = gameState,&#10;                        onMapClick = { gameViewModel.showMap() },&#10;                        onClearError = { gameViewModel.clearError() }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun GamePlayScreen(&#10;    gameState: com.example.geogeusserclone.data.models.GameState,&#10;    onMapClick: () -&gt; Unit,&#10;    onClearError: () -&gt; Unit&#10;) {&#10;    Column(modifier = Modifier.fillMaxSize()) {&#10;        // Game Info Header&#10;        gameState.currentGame?.let { game -&gt;&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp)&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier.padding(16.dp),&#10;                    horizontalArrangement = Arrangement.SpaceBetween&#10;                ) {&#10;                    Text(&quot;Punkte: ${game.score}&quot;)&#10;                    Text(&quot;Zeit: ${gameState.timeRemaining / 1000}s&quot;)&#10;                }&#10;            }&#10;        }&#10;&#10;        // Street View&#10;        StreetViewComponent(&#10;            location = gameState.currentLocation,&#10;            onMapClick = onMapClick,&#10;            modifier = Modifier.weight(1f)&#10;        )&#10;    }&#10;&#10;    // Error Snackbar&#10;    gameState.error?.let { error -&gt;&#10;        LaunchedEffect(error) {&#10;            kotlinx.coroutines.delay(3000)&#10;            onClearError()&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun RoundResultScreen(&#10;    guess: com.example.geogeusserclone.data.database.entities.GuessEntity?,&#10;    onNextRound: () -&gt; Unit&#10;) {&#10;    guess?.let { guessEntity -&gt;&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(24.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.Center&#10;            ) {&#10;                Text(&#10;                    text = &quot;Rundenergebnis&quot;,&#10;                    style = MaterialTheme.typography.headlineMedium&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(24.dp))&#10;&#10;                Text(&#10;                    text = &quot;${guessEntity.score} Punkte&quot;,&#10;                    style = MaterialTheme.typography.displayMedium,&#10;                    color = MaterialTheme.colorScheme.primary&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                Text(&#10;                    text = &quot;Entfernung: ${&quot;%.1f&quot;.format(guessEntity.distance)} km&quot;,&#10;                    style = MaterialTheme.typography.titleMedium&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(32.dp))&#10;&#10;                Button(&#10;                    onClick = onNextRound,&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    Text(&quot;Weiter&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.geogeusserclone.ui.activities&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.ArrowBack&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import com.example.geogeusserclone.ui.components.MapGuessComponent&#10;import com.example.geogeusserclone.ui.components.StreetViewComponent&#10;import com.example.geogeusserclone.ui.theme.GeoGeusserCloneTheme&#10;import com.example.geogeusserclone.viewmodels.GameViewModel&#10;import dagger.hilt.android.AndroidEntryPoint&#10;import com.example.geogeusserclone.ui.components.GameCompletionScreen&#10;import com.example.geogeusserclone.ui.components.RoundResultView&#10;&#10;@AndroidEntryPoint&#10;class GameActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            GeoGeusserCloneTheme {&#10;                GameScreen(&#10;                    onNavigateBack = { finish() }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun GameScreen(&#10;    onNavigateBack: () -&gt; Unit,&#10;    gameViewModel: GameViewModel = hiltViewModel()&#10;) {&#10;    val gameState by gameViewModel.uiState.collectAsState()&#10;    var guesses by remember { mutableStateOf&lt;List&lt;com.example.geogeusserclone.data.database.entities.GuessEntity&gt;&gt;(emptyList()) }&#10;&#10;    LaunchedEffect(Unit) {&#10;        if (gameState.currentGame == null) {&#10;            gameViewModel.startNewGame()&#10;        }&#10;    }&#10;&#10;    // Collect guesses&#10;    LaunchedEffect(gameState.currentGame) {&#10;        gameState.currentGame?.let { game -&gt;&#10;            gameViewModel.getGameGuesses().collect { guessList -&gt;&#10;                guesses = guessList&#10;            }&#10;        }&#10;    }&#10;&#10;    if (gameState.isLoading &amp;&amp; gameState.currentGame == null) {&#10;        Box(&#10;            modifier = Modifier.fillMaxSize(),&#10;            contentAlignment = Alignment.Center&#10;        ) {&#10;            CircularProgressIndicator()&#10;        }&#10;        return&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = {&#10;                    gameState.currentGame?.let { game -&gt;&#10;                        Text(&quot;Runde ${game.currentRound}/${game.totalRounds}&quot;)&#10;                    }&#10;                },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onNavigateBack) {&#10;                        Icon(Icons.Default.ArrowBack, contentDescription = &quot;Zurück&quot;)&#10;                    }&#10;                }&#10;            )&#10;        }&#10;    ) { paddingValues -&gt;&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues)&#10;        ) {&#10;            when {&#10;                gameState.showMap -&gt; {&#10;                    MapGuessComponent(&#10;                        onGuessSelected = { lat, lng -&gt;&#10;                            gameViewModel.submitGuess(lat, lng)&#10;                        },&#10;                        onMapClose = {&#10;                            gameViewModel.hideMap()&#10;                        }&#10;                    )&#10;                }&#10;&#10;                gameState.showRoundResult -&gt; {&#10;                    RoundResultView(&#10;                        guess = gameState.revealGuessResult,&#10;                        onNextRound = {&#10;                            gameViewModel.proceedToNextRound()&#10;                        }&#10;                    )&#10;                }&#10;&#10;                gameState.showGameCompletion -&gt; {&#10;                    gameState.currentGame?.let { game -&gt;&#10;                        GameCompletionScreen(&#10;                            game = game,&#10;                            guesses = guesses,&#10;                            onPlayAgain = {&#10;                                gameViewModel.startNewGame()&#10;                            },&#10;                            onMainMenu = onNavigateBack&#10;                        )&#10;                    }&#10;                }&#10;&#10;                else -&gt; {&#10;                    GamePlayScreen(&#10;                        gameState = gameState,&#10;                        onMapClick = { gameViewModel.showMap() },&#10;                        onClearError = { gameViewModel.clearError() }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun GamePlayScreen(&#10;    gameState: com.example.geogeusserclone.data.models.GameState,&#10;    onMapClick: () -&gt; Unit,&#10;    onClearError: () -&gt; Unit&#10;) {&#10;    Column(modifier = Modifier.fillMaxSize()) {&#10;        // Game Info Header&#10;        gameState.currentGame?.let { game -&gt;&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(16.dp)&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier.padding(16.dp),&#10;                    horizontalArrangement = Arrangement.SpaceBetween&#10;                ) {&#10;                    Text(&quot;Punkte: ${game.score}&quot;)&#10;                    Text(&quot;Zeit: ${gameState.timeRemaining / 1000}s&quot;)&#10;                }&#10;            }&#10;        }&#10;&#10;        // Street View&#10;        StreetViewComponent(&#10;            location = gameState.currentLocation,&#10;            onMapClick = onMapClick,&#10;            modifier = Modifier.weight(1f)&#10;        )&#10;    }&#10;&#10;    // Error Snackbar&#10;    gameState.error?.let { error -&gt;&#10;        LaunchedEffect(error) {&#10;            kotlinx.coroutines.delay(3000)&#10;            onClearError()&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun RoundResultScreen(&#10;    guess: com.example.geogeusserclone.data.database.entities.GuessEntity?,&#10;    onNextRound: () -&gt; Unit&#10;) {&#10;    guess?.let { guessEntity -&gt;&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(24.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.Center&#10;            ) {&#10;                Text(&#10;                    text = &quot;Rundenergebnis&quot;,&#10;                    style = MaterialTheme.typography.headlineMedium&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(24.dp))&#10;&#10;                Text(&#10;                    text = &quot;${guessEntity.score} Punkte&quot;,&#10;                    style = MaterialTheme.typography.displayMedium,&#10;                    color = MaterialTheme.colorScheme.primary&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                Text(&#10;                    text = &quot;Entfernung: ${&quot;%.1f&quot;.format(guessEntity.distance)} km&quot;,&#10;                    style = MaterialTheme.typography.titleMedium&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(32.dp))&#10;&#10;                Button(&#10;                    onClick = onNextRound,&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    Text(&quot;Weiter&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/ui/components/RoundResultView.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/ui/components/RoundResultView.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.ui.components&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import com.example.geogeusserclone.data.database.entities.GuessEntity&#10;&#10;@Composable&#10;fun RoundResultView(&#10;    guess: GuessEntity?,&#10;    onNextRound: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    guess?.let { guessEntity -&gt;&#10;        Card(&#10;            modifier = modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(24.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.Center&#10;            ) {&#10;                Text(&#10;                    text = &quot;Rundenergebnis&quot;,&#10;                    style = MaterialTheme.typography.headlineMedium,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(24.dp))&#10;&#10;                Text(&#10;                    text = &quot;${guessEntity.score} Punkte&quot;,&#10;                    style = MaterialTheme.typography.displayMedium,&#10;                    color = MaterialTheme.colorScheme.primary,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                Text(&#10;                    text = &quot;Entfernung: ${&quot;%.1f&quot;.format(guessEntity.distance)} km&quot;,&#10;                    style = MaterialTheme.typography.titleMedium&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(32.dp))&#10;&#10;                Button(&#10;                    onClick = onNextRound,&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    Text(&quot;Weiter&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/ui/theme/Theme.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/ui/theme/Theme.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.ui.theme&#10;&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.lightColorScheme&#10;import androidx.compose.material3.darkColorScheme&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.foundation.isSystemInDarkTheme&#10;import androidx.compose.ui.graphics.Color&#10;&#10;private val LightColorScheme = lightColorScheme(&#10;    primary = Color(0xFF1976D2),&#10;    secondary = Color(0xFF03DAC6),&#10;    tertiary = Color(0xFF3700B3),&#10;    background = Color(0xFFFFFBFE),&#10;    surface = Color(0xFFFFFBFE),&#10;    onPrimary = Color.White,&#10;    onSecondary = Color.Black,&#10;    onTertiary = Color.White,&#10;    onBackground = Color(0xFF1C1B1F),&#10;    onSurface = Color(0xFF1C1B1F),&#10;)&#10;&#10;private val DarkColorScheme = darkColorScheme(&#10;    primary = Color(0xFF90CAF9),&#10;    secondary = Color(0xFF03DAC6),&#10;    tertiary = Color(0xFFBB86FC),&#10;    background = Color(0xFF121212),&#10;    surface = Color(0xFF121212),&#10;    onPrimary = Color.Black,&#10;    onSecondary = Color.Black,&#10;    onTertiary = Color.Black,&#10;    onBackground = Color(0xFFE1E2E1),&#10;    onSurface = Color(0xFFE1E2E1),&#10;)&#10;&#10;@Composable&#10;fun GeoGeusserCloneTheme(&#10;    darkTheme: Boolean = isSystemInDarkTheme(),&#10;    content: @Composable () -&gt; Unit&#10;) {&#10;    val colorScheme = if (darkTheme) {&#10;        DarkColorScheme&#10;    } else {&#10;        LightColorScheme&#10;    }&#10;&#10;    MaterialTheme(&#10;        colorScheme = colorScheme,&#10;        typography = androidx.compose.material3.Typography(),&#10;        content = content&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/utils/Constants.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/utils/Constants.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.utils&#10;&#10;object Constants {&#10;    // Network Configuration&#10;    const val BASE_URL = &quot;https://api.geoguessr-clone.com/&quot;&#10;    const val CONNECT_TIMEOUT = 30L&#10;    const val READ_TIMEOUT = 30L&#10;    const val WRITE_TIMEOUT = 30L&#10;    &#10;    // Game Configuration&#10;    const val MAX_ROUND_TIME_MS = 120000L // 2 Minuten&#10;    const val TIME_BONUS_MAX = 500&#10;    &#10;    // Score Thresholds&#10;    const val PERFECT_DISTANCE_KM = 1.0&#10;    const val EXCELLENT_DISTANCE_KM = 10.0&#10;    const val GOOD_DISTANCE_KM = 50.0&#10;    const val FAIR_DISTANCE_KM = 200.0&#10;    const val POOR_DISTANCE_KM = 1000.0&#10;    &#10;    // Cache Configuration&#10;    const val IMAGE_CACHE_SIZE_MB = 50L&#10;    const val MAP_TILE_CACHE_SIZE_MB = 100L&#10;    const val LOCATION_PRELOAD_COUNT = 10&#10;    &#10;    // Performance Settings&#10;    const val ANIMATION_DURATION_MS = 300L&#10;    const val DEBOUNCE_DELAY_MS = 100L&#10;    const val MAP_ZOOM_MIN = 1.0&#10;    const val MAP_ZOOM_MAX = 19.0&#10;    &#10;    // Background Work&#10;    const val LOCATION_PRELOAD_INTERVAL_HOURS = 2L&#10;    const val CACHE_CLEANUP_INTERVAL_HOURS = 24L&#10;    &#10;    // UI Performance&#10;    const val LAZY_COLUMN_PREFETCH_COUNT = 3&#10;    const val IMAGE_CROSSFADE_DURATION = 200&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/utils/EdgeToEdge.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/utils/EdgeToEdge.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.utils&#10;&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.enableEdgeToEdge as androidEnableEdgeToEdge&#10;&#10;fun ComponentActivity.enableEdgeToEdge() {&#10;    androidEnableEdgeToEdge()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/utils/MapCacheManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/utils/MapCacheManager.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.utils&#10;&#10;import android.content.Context&#10;import androidx.work.*&#10;import com.example.geogeusserclone.data.repositories.LocationCacheRepository&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#10;import java.util.concurrent.TimeUnit&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;/**&#10; * Background-Service für Map Tile Preloading&#10; */&#10;@Singleton&#10;class MapCacheManager @Inject constructor(&#10;    @ApplicationContext private val context: Context,&#10;    private val locationCacheRepository: LocationCacheRepository&#10;) {&#10;&#10;    /**&#10;     * Startet Background-Preloading von Map Tiles&#10;     */&#10;    fun startMapTilePreloading() {&#10;        val constraints = Constraints.Builder()&#10;            .setRequiredNetworkType(NetworkType.UNMETERED) // Nur WLAN&#10;            .setRequiresBatteryNotLow(true)&#10;            .setRequiresCharging(false)&#10;            .build()&#10;&#10;        val preloadWork = OneTimeWorkRequestBuilder&lt;MapTilePreloadWorker&gt;()&#10;            .setConstraints(constraints)&#10;            .setBackoffCriteria(&#10;                BackoffPolicy.EXPONENTIAL,&#10;                WorkRequest.MIN_BACKOFF_MILLIS,&#10;                TimeUnit.MILLISECONDS&#10;            )&#10;            .build()&#10;&#10;        WorkManager.getInstance(context)&#10;            .enqueueUniqueWork(&#10;                &quot;map_tile_preload&quot;,&#10;                ExistingWorkPolicy.KEEP,&#10;                preloadWork&#10;            )&#10;    }&#10;&#10;    /**&#10;     * Bereinigt alte Map Tiles bei Low Memory&#10;     */&#10;    fun cleanupOldTiles() {&#10;        val cleanupWork = OneTimeWorkRequestBuilder&lt;MapTileCleanupWorker&gt;()&#10;            .build()&#10;&#10;        WorkManager.getInstance(context)&#10;            .enqueue(cleanupWork)&#10;    }&#10;&#10;    /**&#10;     * Überwacht Map Performance Metriken&#10;     */&#10;    fun trackMapPerformance(&#10;        loadTime: Long,&#10;        tileCount: Int,&#10;        memoryUsage: Long&#10;    ) {&#10;        // Performance Tracking für Optimierungen&#10;        if (loadTime &gt; 3000) { // Über 3 Sekunden&#10;            // Trigger für Cache-Optimierung&#10;            cleanupOldTiles()&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Worker für Map Tile Preloading&#10; */&#10;class MapTilePreloadWorker(&#10;    context: Context,&#10;    params: WorkerParameters&#10;) : CoroutineWorker(context, params) {&#10;&#10;    override suspend fun doWork(): Result {&#10;        return try {&#10;            // Preload häufig verwendete Gebiete&#10;            preloadPopularRegions()&#10;            Result.success()&#10;        } catch (e: Exception) {&#10;            Result.retry()&#10;        }&#10;    }&#10;&#10;    private suspend fun preloadPopularRegions() {&#10;        val popularRegions = listOf(&#10;            Pair(54.5260, 15.2551), // Europa&#10;            Pair(39.8283, -98.5795), // USA&#10;            Pair(35.6762, 139.6503), // Tokyo&#10;            Pair(-33.8688, 151.2093) // Sydney&#10;        )&#10;&#10;        // Implementierung des Tile-Preloadings&#10;        // Dies würde die Tiles für diese Regionen im Cache speichern&#10;    }&#10;}&#10;&#10;/**&#10; * Worker für Map Cache Cleanup&#10; */&#10;class MapTileCleanupWorker(&#10;    context: Context,&#10;    params: WorkerParameters&#10;) : CoroutineWorker(context, params) {&#10;&#10;    override suspend fun doWork(): Result {&#10;        return try {&#10;            val cacheDir = applicationContext.cacheDir&#10;            val mapCacheDir = java.io.File(cacheDir, &quot;osmdroid&quot;)&#10;            &#10;            if (mapCacheDir.exists()) {&#10;                // Lösche Tiles älter als 7 Tage&#10;                val weekAgo = System.currentTimeMillis() - (7 * 24 * 60 * 60 * 1000)&#10;                &#10;                mapCacheDir.listFiles()?.forEach { file -&gt;&#10;                    if (file.lastModified() &lt; weekAgo) {&#10;                        file.delete()&#10;                    }&#10;                }&#10;            }&#10;            &#10;            Result.success()&#10;        } catch (e: Exception) {&#10;            Result.failure()&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/utils/MapPerformanceUtils.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/utils/MapPerformanceUtils.kt" />
              <option name="originalContent" value="package com.example.geogeusserclone.utils&#10;&#10;import android.content.Context&#10;import android.graphics.Bitmap&#10;import android.graphics.drawable.BitmapDrawable&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.core.content.ContextCompat&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import org.osmdroid.config.Configuration&#10;import org.osmdroid.tileprovider.MapTileProviderBasic&#10;import org.osmdroid.tileprovider.tilesource.ITileSource&#10;import org.osmdroid.tileprovider.tilesource.OnlineTileSourceBase&#10;import org.osmdroid.views.MapView&#10;import java.util.concurrent.Executors&#10;&#10;/**&#10; * Performance-optimierte Map Utilities&#10; */&#10;object MapPerformanceUtils {&#10;&#10;    /**&#10;     * Konfiguriert OSMDroid für optimale Performance&#10;     */&#10;    fun configureMapPerformance(context: Context) {&#10;        Configuration.getInstance().apply {&#10;            // Thread Pool Optimierung&#10;            val coreCount = Runtime.getRuntime().availableProcessors()&#10;            setTileFileSystemThreads(minOf(coreCount, 4).toShort())&#10;            setTileDownloadThreads(minOf(coreCount * 2, 8).toShort())&#10;&#10;            // Cache Optimierung basierend auf verfügbarem Speicher&#10;            val runtime = Runtime.getRuntime()&#10;            val maxMemory = runtime.maxMemory()&#10;            val cacheSize = (maxMemory / 8).coerceAtMost(100 * 1024 * 1024L) // Max 100MB&#10;&#10;            setTileFileSystemCacheMaxBytes(cacheSize)&#10;            setTileFileSystemCacheTrimBytes((cacheSize * 0.8).toLong())&#10;&#10;            // Performance Settings&#10;            setMapViewHardwareAccelerated(true)&#10;            setTileFileSystemMaxQueueSize(40)&#10;            setTileDownloadMaxQueueSize(20)&#10;&#10;            userAgentValue = &quot;GeoGuesserClone/1.0&quot;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Erstellt eine performance-optimierte Tile Source mit Load Balancing&#10;     */&#10;    fun createOptimizedTileSource(): OnlineTileSourceBase {&#10;        val urls = arrayOf(&#10;            &quot;https://a.tile.openstreetmap.org/&quot;,&#10;            &quot;https://b.tile.openstreetmap.org/&quot;,&#10;            &quot;https://c.tile.openstreetmap.org/&quot;&#10;        )&#10;&#10;        return object : OnlineTileSourceBase(&#10;            &quot;PerformanceMapnik&quot;,&#10;            1, 19, 256, &quot;.png&quot;,&#10;            urls&#10;        ) {&#10;            override fun getTileURLString(pMapTileIndex: Long): String {&#10;                val zoom = org.osmdroid.util.MapTileIndex.getZoom(pMapTileIndex)&#10;                val x = org.osmdroid.util.MapTileIndex.getX(pMapTileIndex)&#10;                val y = org.osmdroid.util.MapTileIndex.getY(pMapTileIndex)&#10;&#10;                // Load Balancing über mehrere Server&#10;                val serverIndex = ((x + y) % urls.size)&#10;                val baseUrl = urls[serverIndex]&#10;&#10;                return &quot;$baseUrl$zoom/$x/$y.png&quot;&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Memory-efficient Marker Icon Creation&#10;     */&#10;    suspend fun createOptimizedMarkerIcon(&#10;        context: Context,&#10;        resourceId: Int,&#10;        size: Int = 64&#10;    ): BitmapDrawable? = withContext(Dispatchers.IO) {&#10;        try {&#10;            val drawable = ContextCompat.getDrawable(context, resourceId)&#10;            if (drawable != null) {&#10;                val bitmap = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888)&#10;                val canvas = android.graphics.Canvas(bitmap)&#10;                drawable.setBounds(0, 0, size, size)&#10;                drawable.draw(canvas)&#10;                BitmapDrawable(context.resources, bitmap)&#10;            } else null&#10;        } catch (e: Exception) {&#10;            null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Optimiert MapView Settings für bessere Performance&#10;     */&#10;    fun optimizeMapView(mapView: MapView) {&#10;        mapView.apply {&#10;            // Hardware Acceleration&#10;            setLayerType(android.view.View.LAYER_TYPE_HARDWARE, null)&#10;&#10;            // Disable unnecessary features&#10;            isHorizontalMapRepetitionEnabled = false&#10;            isVerticalMapRepetitionEnabled = false&#10;&#10;            // Optimize tile scaling&#10;            isTilesScaledToDpi = true&#10;&#10;            // Set reasonable zoom limits&#10;            minZoomLevel = 1.0&#10;            maxZoomLevel = 19.0&#10;&#10;            // Optimize overlay rendering&#10;            overlayManager.tilesOverlay.setLoadingBackgroundColor(&#10;                android.graphics.Color.TRANSPARENT&#10;            )&#10;&#10;            // Animation settings werden übersprungen da nicht alle OSMDroid Versionen diese unterstützen&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Cleanup Map Resources&#10;     */&#10;    fun cleanupMapResources(mapView: MapView?) {&#10;        mapView?.let { map -&gt;&#10;            try {&#10;                map.onDetach()&#10;                map.overlays.clear()&#10;                map.tileProvider?.clearTileCache()&#10;            } catch (e: Exception) {&#10;                // Silent cleanup&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Pre-cache tiles für bessere Performance&#10;     */&#10;    suspend fun precacheTiles(&#10;        mapView: MapView,&#10;        centerLat: Double,&#10;        centerLng: Double,&#10;        radiusKm: Double = 100.0&#10;    ) = withContext(Dispatchers.IO) {&#10;        try {&#10;            val boundingBox = calculateBoundingBox(centerLat, centerLng, radiusKm)&#10;            // Pre-cache logic würde hier implementiert werden&#10;            // Dies ist eine vereinfachte Version&#10;        } catch (e: Exception) {&#10;            // Silent fail - App funktioniert weiter ohne Precaching&#10;        }&#10;    }&#10;&#10;    private fun calculateBoundingBox(&#10;        centerLat: Double,&#10;        centerLng: Double,&#10;        radiusKm: Double&#10;    ): org.osmdroid.util.BoundingBox {&#10;        val latOffset = radiusKm / 111.0 // Ungefähr 111km pro Grad&#10;        val lngOffset = radiusKm / (111.0 * kotlin.math.cos(Math.toRadians(centerLat)))&#10;&#10;        return org.osmdroid.util.BoundingBox(&#10;            centerLat + latOffset,&#10;            centerLng + lngOffset,&#10;            centerLat - latOffset,&#10;            centerLng - lngOffset&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * Composable für performance-bewusstes Map Setup&#10; */&#10;@Composable&#10;fun rememberOptimizedMapConfiguration(): Configuration {&#10;    val context = LocalContext.current&#10;&#10;    return remember {&#10;        Configuration.getInstance().also {&#10;            MapPerformanceUtils.configureMapPerformance(context)&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Performance-optimierte Map State Management&#10; */&#10;@Composable&#10;fun rememberMapState(&#10;    initialZoom: Double = 3.0,&#10;    initialCenter: org.osmdroid.util.GeoPoint = org.osmdroid.util.GeoPoint(20.0, 0.0)&#10;): MapState {&#10;    var zoom by remember { mutableDoubleStateOf(initialZoom) }&#10;    var center by remember { mutableStateOf(initialCenter) }&#10;    var isLoading by remember { mutableStateOf(false) }&#10;&#10;    return remember {&#10;        MapState(&#10;            zoom = zoom,&#10;            center = center,&#10;            isLoading = isLoading,&#10;            setZoom = { zoom = it },&#10;            setCenter = { center = it },&#10;            setLoading = { isLoading = it }&#10;        )&#10;    }&#10;}&#10;&#10;data class MapState(&#10;    val zoom: Double,&#10;    val center: org.osmdroid.util.GeoPoint,&#10;    val isLoading: Boolean,&#10;    val setZoom: (Double) -&gt; Unit,&#10;    val setCenter: (org.osmdroid.util.GeoPoint) -&gt; Unit,&#10;    val setLoading: (Boolean) -&gt; Unit&#10;)&#10;" />
              <option name="updatedContent" value="package com.example.geogeusserclone.utils&#10;&#10;import android.content.Context&#10;import android.graphics.Bitmap&#10;import android.graphics.drawable.BitmapDrawable&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.core.content.ContextCompat&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import org.osmdroid.config.Configuration&#10;import org.osmdroid.tileprovider.MapTileProviderBasic&#10;import org.osmdroid.tileprovider.tilesource.ITileSource&#10;import org.osmdroid.tileprovider.tilesource.OnlineTileSourceBase&#10;import org.osmdroid.views.MapView&#10;import java.util.concurrent.Executors&#10;&#10;/**&#10; * Performance-optimierte Map Utilities&#10; */&#10;object MapPerformanceUtils {&#10;&#10;    /**&#10;     * Konfiguriert OSMDroid für optimale Performance&#10;     */&#10;    fun configureMapPerformance(context: Context) {&#10;        Configuration.getInstance().apply {&#10;            // Thread Pool Optimierung&#10;            val coreCount = Runtime.getRuntime().availableProcessors()&#10;            setTileFileSystemThreads(minOf(coreCount, 4).toShort())&#10;            setTileDownloadThreads(minOf(coreCount * 2, 8).toShort())&#10;&#10;            // Cache Optimierung basierend auf verfügbarem Speicher&#10;            val runtime = Runtime.getRuntime()&#10;            val maxMemory = runtime.maxMemory()&#10;            val cacheSize = (maxMemory / 8).coerceAtMost(100 * 1024 * 1024L) // Max 100MB&#10;&#10;            setTileFileSystemCacheMaxBytes(cacheSize)&#10;            setTileFileSystemCacheTrimBytes((cacheSize * 0.8).toLong())&#10;&#10;            // Performance Settings&#10;            setMapViewHardwareAccelerated(true)&#10;            setTileFileSystemMaxQueueSize(40)&#10;            setTileDownloadMaxQueueSize(20)&#10;&#10;            userAgentValue = &quot;GeoGuesserClone/1.0&quot;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Erstellt eine performance-optimierte Tile Source mit Load Balancing&#10;     */&#10;    fun createOptimizedTileSource(): OnlineTileSourceBase {&#10;        val urls = arrayOf(&#10;            &quot;https://a.tile.openstreetmap.org/&quot;,&#10;            &quot;https://b.tile.openstreetmap.org/&quot;,&#10;            &quot;https://c.tile.openstreetmap.org/&quot;&#10;        )&#10;&#10;        return object : OnlineTileSourceBase(&#10;            &quot;PerformanceMapnik&quot;,&#10;            1, 19, 256, &quot;.png&quot;,&#10;            urls&#10;        ) {&#10;            override fun getTileURLString(pMapTileIndex: Long): String {&#10;                val zoom = org.osmdroid.util.MapTileIndex.getZoom(pMapTileIndex)&#10;                val x = org.osmdroid.util.MapTileIndex.getX(pMapTileIndex)&#10;                val y = org.osmdroid.util.MapTileIndex.getY(pMapTileIndex)&#10;&#10;                // Load Balancing über mehrere Server&#10;                val serverIndex = ((x + y) % urls.size)&#10;                val baseUrl = urls[serverIndex]&#10;&#10;                return &quot;$baseUrl$zoom/$x/$y.png&quot;&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Memory-efficient Marker Icon Creation&#10;     */&#10;    suspend fun createOptimizedMarkerIcon(&#10;        context: Context,&#10;        resourceId: Int,&#10;        size: Int = 64&#10;    ): BitmapDrawable? = withContext(Dispatchers.IO) {&#10;        try {&#10;            val drawable = ContextCompat.getDrawable(context, resourceId)&#10;            if (drawable != null) {&#10;                val bitmap = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888)&#10;                val canvas = android.graphics.Canvas(bitmap)&#10;                drawable.setBounds(0, 0, size, size)&#10;                drawable.draw(canvas)&#10;                BitmapDrawable(context.resources, bitmap)&#10;            } else null&#10;        } catch (e: Exception) {&#10;            null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Optimiert MapView Settings für bessere Performance&#10;     */&#10;    fun optimizeMapView(mapView: MapView) {&#10;        mapView.apply {&#10;            // Hardware Acceleration&#10;            setLayerType(android.view.View.LAYER_TYPE_HARDWARE, null)&#10;&#10;            // Disable unnecessary features&#10;            isHorizontalMapRepetitionEnabled = false&#10;            isVerticalMapRepetitionEnabled = false&#10;&#10;            // Optimize tile scaling&#10;            isTilesScaledToDpi = true&#10;&#10;            // Set reasonable zoom limits&#10;            minZoomLevel = 1.0&#10;            maxZoomLevel = 19.0&#10;&#10;            // Optimize overlay rendering&#10;            overlayManager.tilesOverlay.setLoadingBackgroundColor(&#10;                android.graphics.Color.TRANSPARENT&#10;            )&#10;&#10;            // Animation settings werden übersprungen da nicht alle OSMDroid Versionen diese unterstützen&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Cleanup Map Resources&#10;     */&#10;    fun cleanupMapResources(mapView: MapView?) {&#10;        mapView?.let { map -&gt;&#10;            try {&#10;                map.onDetach()&#10;                map.overlays.clear()&#10;                map.tileProvider?.clearTileCache()&#10;            } catch (e: Exception) {&#10;                // Silent cleanup&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Pre-cache tiles für bessere Performance&#10;     */&#10;    suspend fun precacheTiles(&#10;        mapView: MapView,&#10;        centerLat: Double,&#10;        centerLng: Double,&#10;        radiusKm: Double = 100.0&#10;    ) = withContext(Dispatchers.IO) {&#10;        try {&#10;            val boundingBox = calculateBoundingBox(centerLat, centerLng, radiusKm)&#10;            // Pre-cache logic würde hier implementiert werden&#10;            // Dies ist eine vereinfachte Version&#10;        } catch (e: Exception) {&#10;            // Silent fail - App funktioniert weiter ohne Precaching&#10;        }&#10;    }&#10;&#10;    private fun calculateBoundingBox(&#10;        centerLat: Double,&#10;        centerLng: Double,&#10;        radiusKm: Double&#10;    ): org.osmdroid.util.BoundingBox {&#10;        val latOffset = radiusKm / 111.0 // Ungefähr 111km pro Grad&#10;        val lngOffset = radiusKm / (111.0 * kotlin.math.cos(Math.toRadians(centerLat)))&#10;&#10;        return org.osmdroid.util.BoundingBox(&#10;            centerLat + latOffset,&#10;            centerLng + lngOffset,&#10;            centerLat - latOffset,&#10;            centerLng - lngOffset&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * Composable für performance-bewusstes Map Setup&#10; */&#10;@Composable&#10;fun rememberOptimizedMapConfiguration(): org.osmdroid.config.IConfigurationProvider {&#10;    val context = LocalContext.current&#10;&#10;    return remember {&#10;        Configuration.getInstance().also {&#10;            MapPerformanceUtils.configureMapPerformance(context)&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Performance-optimierte Map State Management&#10; */&#10;@Composable&#10;fun rememberMapState(&#10;    initialZoom: Double = 3.0,&#10;    initialCenter: org.osmdroid.util.GeoPoint = org.osmdroid.util.GeoPoint(20.0, 0.0)&#10;): MapState {&#10;    var zoom by remember { mutableDoubleStateOf(initialZoom) }&#10;    var center by remember { mutableStateOf(initialCenter) }&#10;    var isLoading by remember { mutableStateOf(false) }&#10;&#10;    return remember {&#10;        MapState(&#10;            zoom = zoom,&#10;            center = center,&#10;            isLoading = isLoading,&#10;            setZoom = { zoom = it },&#10;            setCenter = { center = it },&#10;            setLoading = { isLoading = it }&#10;        )&#10;    }&#10;}&#10;&#10;data class MapState(&#10;    val zoom: Double,&#10;    val center: org.osmdroid.util.GeoPoint,&#10;    val isLoading: Boolean,&#10;    val setZoom: (Double) -&gt; Unit,&#10;    val setCenter: (org.osmdroid.util.GeoPoint) -&gt; Unit,&#10;    val setLoading: (Boolean) -&gt; Unit&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/utils/ScoreCalculator.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/utils/ScoreCalculator.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.utils&#10;&#10;import androidx.compose.ui.graphics.Color&#10;import com.example.geogeusserclone.utils.Constants&#10;&#10;enum class ScoreRating {&#10;    PERFECT, EXCELLENT, GOOD, FAIR, POOR, TERRIBLE&#10;}&#10;&#10;object ScoreCalculator {&#10;    &#10;    /**&#10;     * Berechnet den Score basierend auf Entfernung und Zeit&#10;     */&#10;    fun calculateScore(&#10;        distanceKm: Double,&#10;        timeSpentMs: Long = 0L,&#10;        maxTimeMs: Long = Constants.MAX_ROUND_TIME_MS&#10;    ): Int {&#10;        // Basis-Score basierend auf Entfernung (0-5000 Punkte)&#10;        val distanceScore = when {&#10;            distanceKm &lt;= Constants.PERFECT_DISTANCE_KM -&gt; 5000&#10;            distanceKm &lt;= Constants.EXCELLENT_DISTANCE_KM -&gt; 4500 - ((distanceKm - 1) * 50).toInt()&#10;            distanceKm &lt;= Constants.GOOD_DISTANCE_KM -&gt; 4000 - ((distanceKm - 10) * 75).toInt()&#10;            distanceKm &lt;= Constants.FAIR_DISTANCE_KM -&gt; 2000 - ((distanceKm - 50) * 10).toInt()&#10;            distanceKm &lt;= Constants.POOR_DISTANCE_KM -&gt; 500 - ((distanceKm - 200) * 0.5).toInt()&#10;            else -&gt; 0&#10;        }.coerceIn(0, 5000)&#10;        &#10;        // Zeit-Bonus (0-500 Punkte)&#10;        val timeBonus = if (timeSpentMs &gt; 0 &amp;&amp; maxTimeMs &gt; 0) {&#10;            val timeRatio = (maxTimeMs - timeSpentMs).toDouble() / maxTimeMs&#10;            (timeRatio * Constants.TIME_BONUS_MAX).toInt().coerceIn(0, Constants.TIME_BONUS_MAX)&#10;        } else 0&#10;        &#10;        return (distanceScore + timeBonus).coerceIn(0, 5500)&#10;    }&#10;    &#10;    /**&#10;     * Bestimmt die Score-Bewertung&#10;     */&#10;    fun getScoreRating(score: Int): ScoreRating {&#10;        return when {&#10;            score &gt;= 4500 -&gt; ScoreRating.PERFECT&#10;            score &gt;= 3500 -&gt; ScoreRating.EXCELLENT&#10;            score &gt;= 2500 -&gt; ScoreRating.GOOD&#10;            score &gt;= 1000 -&gt; ScoreRating.FAIR&#10;            score &gt;= 200 -&gt; ScoreRating.POOR&#10;            else -&gt; ScoreRating.TERRIBLE&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Gibt die passende Farbe für den Score zurück&#10;     */&#10;    fun getScoreColor(rating: ScoreRating): Color {&#10;        return when (rating) {&#10;            ScoreRating.PERFECT -&gt; Color(0xFF4CAF50)      // Grün&#10;            ScoreRating.EXCELLENT -&gt; Color(0xFF8BC34A)    // Hell-Grün&#10;            ScoreRating.GOOD -&gt; Color(0xFFFFC107)         // Gelb&#10;            ScoreRating.FAIR -&gt; Color(0xFFFF9800)         // Orange&#10;            ScoreRating.POOR -&gt; Color(0xFFFF5722)         // Rot-Orange&#10;            ScoreRating.TERRIBLE -&gt; Color(0xFFF44336)     // Rot&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/viewmodels/BaseViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/viewmodels/BaseViewModel.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.viewmodels&#10;&#10;import androidx.lifecycle.ViewModel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;&#10;abstract class BaseViewModel&lt;T&gt;(initialState: T) : ViewModel() {&#10;    &#10;    private val _state = MutableStateFlow(initialState)&#10;    val state: StateFlow&lt;T&gt; = _state.asStateFlow()&#10;&#10;    protected fun setState(newState: T) {&#10;        _state.value = newState&#10;    }&#10;&#10;    protected fun updateState(transform: (T) -&gt; T) {&#10;        _state.value = transform(_state.value)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/viewmodels/StatsViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/viewmodels/StatsViewModel.kt" />
              <option name="originalContent" value="package com.example.geogeusserclone.viewmodels&#10;&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.geogeusserclone.data.database.entities.GameEntity&#10;import com.example.geogeusserclone.data.repositories.GameRepository&#10;import com.example.geogeusserclone.data.repositories.GameStats&#10;import com.example.geogeusserclone.data.repositories.UserRepository&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.collectLatest&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;data class StatsState(&#10;    val isLoading: Boolean = false,&#10;    val userGames: List&lt;GameEntity&gt; = emptyList(),&#10;    val gameStats: GameStats? = null,&#10;    val error: String? = null,&#10;    val selectedTimeRange: TimeRange = TimeRange.ALL_TIME&#10;)&#10;&#10;enum class TimeRange {&#10;    ALL_TIME, LAST_WEEK, LAST_MONTH, LAST_YEAR&#10;}&#10;&#10;@HiltViewModel&#10;class StatsViewModel @Inject constructor(&#10;    private val gameRepository: GameRepository,&#10;    private val userRepository: UserRepository&#10;) : BaseViewModel&lt;StatsState&gt;(StatsState()) {&#10;&#10;    init {&#10;        loadUserStats()&#10;    }&#10;&#10;    private fun loadUserStats() {&#10;        viewModelScope.launch {&#10;            val currentUser = userRepository.getCurrentUser()&#10;            if (currentUser == null) {&#10;                setState(state.value.copy(error = &quot;Benutzer nicht angemeldet&quot;))&#10;                return@launch&#10;            }&#10;&#10;            setState(state.value.copy(isLoading = true))&#10;&#10;            try {&#10;                // Load user games&#10;                gameRepository.getGamesByUser(currentUser.id).collectLatest { games -&gt;&#10;                    val filteredGames = filterGamesByTimeRange(games, state.value.selectedTimeRange)&#10;                    setState(state.value.copy(userGames = filteredGames))&#10;                }&#10;&#10;                // Load game stats&#10;                val stats = gameRepository.getUserStats(currentUser.id)&#10;                setState(state.value.copy(&#10;                    isLoading = false,&#10;                    gameStats = stats,&#10;                    error = null&#10;                ))&#10;&#10;            } catch (e: Exception) {&#10;                setState(state.value.copy(&#10;                    isLoading = false,&#10;                    error = e.message ?: &quot;Statistiken konnten nicht geladen werden&quot;&#10;                ))&#10;            }&#10;        }&#10;    }&#10;&#10;    fun changeTimeRange(timeRange: TimeRange) {&#10;        setState(state.value.copy(selectedTimeRange = timeRange))&#10;        loadUserStats()&#10;    }&#10;&#10;    private fun filterGamesByTimeRange(games: List&lt;GameEntity&gt;, timeRange: TimeRange): List&lt;GameEntity&gt; {&#10;        val currentTime = System.currentTimeMillis()&#10;        val filterTime = when (timeRange) {&#10;            TimeRange.ALL_TIME -&gt; 0L&#10;            TimeRange.LAST_WEEK -&gt; currentTime - (7 * 24 * 60 * 60 * 1000L)&#10;            TimeRange.LAST_MONTH -&gt; currentTime - (30 * 24 * 60 * 60 * 1000L)&#10;            TimeRange.LAST_YEAR -&gt; currentTime - (365 * 24 * 60 * 60 * 1000L)&#10;        }&#10;&#10;        return games.filter { it.timestamp &gt;= filterTime }&#10;    }&#10;&#10;    fun getAverageScoreByGameMode(): Map&lt;String, Double&gt; {&#10;        val games = state.value.userGames.filter { it.isCompleted }&#10;        return games.groupBy { it.gameMode }&#10;            .mapValues { (_, gameList) -&gt;&#10;                if (gameList.isEmpty()) 0.0&#10;                else gameList.map { it.score }.average()&#10;            }&#10;    }&#10;&#10;    fun getBestGamesByMode(): Map&lt;String, GameEntity?&gt; {&#10;        val games = state.value.userGames.filter { it.isCompleted }&#10;        return games.groupBy { it.gameMode }&#10;            .mapValues { (_, gameList) -&gt;&#10;                gameList.maxByOrNull { it.score }&#10;            }&#10;    }&#10;&#10;    fun getRecentGames(limit: Int = 10): List&lt;GameEntity&gt; {&#10;        return state.value.userGames&#10;            .filter { it.isCompleted }&#10;            .sortedByDescending { it.timestamp }&#10;            .take(limit)&#10;    }&#10;&#10;    fun clearError() {&#10;        setState(state.value.copy(error = null))&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.geogeusserclone.viewmodels&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.geogeusserclone.data.database.entities.GameEntity&#10;import com.example.geogeusserclone.data.models.GameStats&#10;import com.example.geogeusserclone.data.models.UserStats&#10;import com.example.geogeusserclone.data.repositories.GameRepository&#10;import com.example.geogeusserclone.data.repositories.UserRepository&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.*&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;data class StatsUiState(&#10;    val gameStats: GameStats = GameStats(),&#10;    val userStats: List&lt;UserStats&gt; = emptyList(),&#10;    val isLoading: Boolean = false,&#10;    val error: String? = null&#10;)&#10;&#10;@HiltViewModel&#10;class StatsViewModel @Inject constructor(&#10;    private val gameRepository: GameRepository,&#10;    private val userRepository: UserRepository&#10;) : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow(StatsUiState())&#10;    val uiState: StateFlow&lt;StatsUiState&gt; = _uiState.asStateFlow()&#10;&#10;    init {&#10;        loadUserStats()&#10;    }&#10;&#10;    private fun loadUserStats() {&#10;        viewModelScope.launch {&#10;            _uiState.update { it.copy(isLoading = true) }&#10;&#10;            try {&#10;                val currentUser = userRepository.getCurrentUser()&#10;                if (currentUser != null) {&#10;                    // Lade Spiele-Statistiken&#10;                    gameRepository.getGameHistory(currentUser.id).collect { games: List&lt;GameEntity&gt; -&gt;&#10;                        val gameStats = calculateGameStats(games)&#10;                        _uiState.update { &#10;                            it.copy(&#10;                                gameStats = gameStats,&#10;                                isLoading = false,&#10;                                error = null&#10;                            )&#10;                        }&#10;                    }&#10;                } else {&#10;                    _uiState.update { &#10;                        it.copy(&#10;                            isLoading = false,&#10;                            error = &quot;Benutzer nicht angemeldet&quot;&#10;                        )&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.update { &#10;                    it.copy(&#10;                        isLoading = false,&#10;                        error = &quot;Fehler beim Laden der Statistiken: ${e.message}&quot;&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun calculateGameStats(games: List&lt;GameEntity&gt;): GameStats {&#10;        if (games.isEmpty()) return GameStats()&#10;&#10;        val completedGames = games.filter { it.isCompleted }&#10;        val totalGames = completedGames.size&#10;        val totalScore = completedGames.sumOf { it.score }&#10;        val averageScore = if (totalGames &gt; 0) totalScore.toDouble() / totalGames else 0.0&#10;        val bestScore = completedGames.maxOfOrNull { it.score } ?: 0&#10;&#10;        // Monatliche Statistiken berechnen&#10;        val monthlyStats = completedGames&#10;            .groupBy { game -&gt;&#10;                val date = java.util.Date(game.completedAt ?: game.createdAt)&#10;                val calendar = java.util.Calendar.getInstance()&#10;                calendar.time = date&#10;                &quot;${calendar.get(java.util.Calendar.MONTH + 1)}-${calendar.get(java.util.Calendar.YEAR)}&quot;&#10;            }&#10;            .map { (monthYear, monthGames) -&gt;&#10;                val parts = monthYear.split(&quot;-&quot;)&#10;                val month = parts[0]&#10;                val year = parts[1].toInt()&#10;                &#10;                com.example.geogeusserclone.data.models.MonthlyGameStats(&#10;                    month = getMonthName(month.toInt()),&#10;                    year = year,&#10;                    gamesPlayed = monthGames.size,&#10;                    totalScore = monthGames.sumOf { it.score },&#10;                    averageScore = monthGames.map { it.score }.average()&#10;                )&#10;            }&#10;            .sortedByDescending { it.year * 12 + getMonthNumber(it.month) }&#10;&#10;        return GameStats(&#10;            totalGames = totalGames,&#10;            totalScore = totalScore,&#10;            averageScore = averageScore,&#10;            bestScore = bestScore,&#10;            monthlyStats = monthlyStats&#10;        )&#10;    }&#10;&#10;    private fun getMonthName(month: Int): String {&#10;        return when (month) {&#10;            1 -&gt; &quot;Januar&quot;&#10;            2 -&gt; &quot;Februar&quot;&#10;            3 -&gt; &quot;März&quot;&#10;            4 -&gt; &quot;April&quot;&#10;            5 -&gt; &quot;Mai&quot;&#10;            6 -&gt; &quot;Juni&quot;&#10;            7 -&gt; &quot;Juli&quot;&#10;            8 -&gt; &quot;August&quot;&#10;            9 -&gt; &quot;September&quot;&#10;            10 -&gt; &quot;Oktober&quot;&#10;            11 -&gt; &quot;November&quot;&#10;            12 -&gt; &quot;Dezember&quot;&#10;            else -&gt; &quot;Unbekannt&quot;&#10;        }&#10;    }&#10;&#10;    private fun getMonthNumber(monthName: String): Int {&#10;        return when (monthName) {&#10;            &quot;Januar&quot; -&gt; 1&#10;            &quot;Februar&quot; -&gt; 2&#10;            &quot;März&quot; -&gt; 3&#10;            &quot;April&quot; -&gt; 4&#10;            &quot;Mai&quot; -&gt; 5&#10;            &quot;Juni&quot; -&gt; 6&#10;            &quot;Juli&quot; -&gt; 7&#10;            &quot;August&quot; -&gt; 8&#10;            &quot;September&quot; -&gt; 9&#10;            &quot;Oktober&quot; -&gt; 10&#10;            &quot;November&quot; -&gt; 11&#10;            &quot;Dezember&quot; -&gt; 12&#10;            else -&gt; 1&#10;        }&#10;    }&#10;&#10;    fun refreshStats() {&#10;        loadUserStats()&#10;    }&#10;&#10;    fun clearError() {&#10;        _uiState.update { it.copy(error = null) }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>