<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/proguard-rules.pro">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/proguard-rules.pro" />
              <option name="originalContent" value="# Add project specific ProGuard rules here.&#10;# You can control the set of applied configuration files using the&#10;# proguardFiles setting in build.gradle.&#10;#&#10;# For more details, see&#10;#   http://developer.android.com/guide/developing/tools/proguard.html&#10;&#10;# If your project uses WebView with JS, uncomment the following&#10;# and specify the fully qualified class name to the JavaScript interface&#10;# class:&#10;#-keepclassmembers class fqcn.of.javascript.interface.for.webview {&#10;#   public *;&#10;#}&#10;&#10;# Uncomment this to preserve the line number information for&#10;# debugging stack traces.&#10;#-keepattributes SourceFile,LineNumberTable&#10;&#10;# If you keep the line number information, uncomment this to&#10;# hide the original source file name.&#10;#-renamesourcefileattribute SourceFile" />
              <option name="updatedContent" value="# Add project specific ProGuard rules here.&#10;# You can control the set of applied configuration files using the&#10;# proguardFiles setting in build.gradle.&#10;#&#10;# For more details, see&#10;#   http://developer.android.com/guide/developing/tools/proguard.html&#10;&#10;# If your project uses WebView with JS, uncomment the following&#10;# and specify the fully qualified class name to the JavaScript interface&#10;# class:&#10;#-keepclassmembers class fqcn.of.javascript.interface.for.webview {&#10;#   public *;&#10;#}&#10;&#10;# Uncomment this to preserve the line number information for&#10;# debugging stack traces.&#10;#-keepattributes SourceFile,LineNumberTable&#10;&#10;# If you keep the line number information, uncomment this to&#10;# hide the original source file name.&#10;#-renamesourcefileattribute SourceFile&#10;&#10;# Performance optimizations&#10;-optimizationpasses 5&#10;-allowaccessmodification&#10;-mergeinterfacesaggressively&#10;&#10;# Retrofit&#10;-keepattributes Signature, InnerClasses, EnclosingMethod&#10;-keepattributes RuntimeVisibleAnnotations, RuntimeVisibleParameterAnnotations&#10;-keepattributes AnnotationDefault&#10;-keepclassmembers,allowshrinking,allowobfuscation interface * {&#10;    @retrofit2.http.* &lt;methods&gt;;&#10;}&#10;-dontwarn org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement&#10;-dontwarn javax.annotation.**&#10;-dontwarn kotlin.Unit&#10;-dontwarn retrofit2.KotlinExtensions&#10;&#10;# OkHttp&#10;-dontwarn okhttp3.**&#10;-dontwarn okio.**&#10;-dontwarn javax.annotation.**&#10;-keepnames class okhttp3.internal.publicsuffix.PublicSuffixDatabase&#10;&#10;# Room&#10;-keepattributes *Annotation*&#10;-keepclassmembers class * extends androidx.room.RoomDatabase {&#10;    *;&#10;}&#10;-keepclassmembers @androidx.room.Entity class * {&#10;    *;&#10;}&#10;&#10;# Coil&#10;-dontwarn coil.**&#10;&#10;# OSMDroid&#10;-dontwarn org.osmdroid.**&#10;&#10;# Hilt&#10;-dontwarn dagger.hilt.**&#10;&#10;# Kotlin Coroutines&#10;-keepnames class kotlinx.coroutines.internal.MainDispatcherFactory {}&#10;-keepnames class kotlinx.coroutines.CoroutineExceptionHandler {}&#10;-keepclassmembers class kotlinx.coroutines.** {&#10;    volatile &lt;fields&gt;;&#10;}&#10;&#10;# Remove logging in release&#10;-assumenosideeffects class android.util.Log {&#10;    public static *** d(...);&#10;    public static *** v(...);&#10;    public static *** i(...);&#10;}&#10;&#10;# Performance: Remove debug info&#10;-keepattributes !SourceFile,!LineNumberTable" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/DatabaseModule.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/DatabaseModule.kt" />
              <option name="originalContent" value="package com.example.geogeusserclone&#10;&#10;import android.content.Context&#10;import androidx.room.Room&#10;import androidx.room.migration.Migration&#10;import androidx.sqlite.db.SupportSQLiteDatabase&#10;import com.example.geogeusserclone.data.database.AppDatabase&#10;import dagger.Module&#10;import dagger.Provides&#10;import dagger.hilt.InstallIn&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#10;import dagger.hilt.components.SingletonComponent&#10;import java.util.concurrent.Executors&#10;import javax.inject.Singleton&#10;&#10;@Module&#10;@InstallIn(SingletonComponent::class)&#10;object DatabaseModule {&#10;&#10;    private val MIGRATION_1_2 = object : Migration(1, 2) {&#10;        override fun migrate(database: SupportSQLiteDatabase) {&#10;            // Add indices&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_guesses_gameId` ON `guesses` (`gameId`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_guesses_locationId` ON `guesses` (`locationId`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_guesses_submittedAt` ON `guesses` (`submittedAt`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_userId` ON `games` (`userId`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_createdAt` ON `games` (`createdAt`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_isCompleted` ON `games` (`isCompleted`)&quot;)&#10;        }&#10;    }&#10;&#10;    private val MIGRATION_2_3 = object : Migration(2, 3) {&#10;        override fun migrate(database: SupportSQLiteDatabase) {&#10;            // Add missing columns to users table&#10;            database.execSQL(&quot;ALTER TABLE users ADD COLUMN totalScore INTEGER NOT NULL DEFAULT 0&quot;)&#10;            database.execSQL(&quot;ALTER TABLE users ADD COLUMN gamesPlayed INTEGER NOT NULL DEFAULT 0&quot;)&#10;            database.execSQL(&quot;ALTER TABLE users ADD COLUMN bestScore INTEGER NOT NULL DEFAULT 0&quot;)&#10;            database.execSQL(&quot;ALTER TABLE users ADD COLUMN lastLoginAt INTEGER NOT NULL DEFAULT 0&quot;)&#10;            database.execSQL(&quot;ALTER TABLE users ADD COLUMN createdAt INTEGER NOT NULL DEFAULT 0&quot;)&#10;            database.execSQL(&quot;ALTER TABLE locations ADD COLUMN isUsed INTEGER NOT NULL DEFAULT 0&quot;)&#10;        }&#10;    }&#10;&#10;    private val MIGRATION_3_4 = object : Migration(3, 4) {&#10;        override fun migrate(database: SupportSQLiteDatabase) {&#10;            // Performance-optimierte Indizes hinzufügen&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_locations_isUsed_isCached` ON `locations` (`isUsed`, `isCached`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_locations_difficulty` ON `locations` (`difficulty`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_users_authToken` ON `users` (`authToken`)&quot;)&#10;&#10;            // Game Performance Indizes&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_userId_isCompleted` ON `games` (`userId`, `isCompleted`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_guesses_gameId_submittedAt` ON `guesses` (`gameId`, `submittedAt`)&quot;)&#10;        }&#10;    }&#10;&#10;    private val MIGRATION_4_5 = object : Migration(4, 5) {&#10;        override fun migrate(database: SupportSQLiteDatabase) {&#10;            // Version 5: Optimierung für bessere Performance und Memory Management&#10;&#10;            // Neue Game Spalten für erweiterte Statistiken&#10;            database.execSQL(&quot;ALTER TABLE games ADD COLUMN startedAt INTEGER&quot;)&#10;            database.execSQL(&quot;ALTER TABLE games ADD COLUMN completedAt INTEGER&quot;)&#10;            database.execSQL(&quot;ALTER TABLE games ADD COLUMN duration INTEGER&quot;)&#10;&#10;            // Location Cache Optimierungen&#10;            database.execSQL(&quot;ALTER TABLE locations ADD COLUMN cachedAt INTEGER NOT NULL DEFAULT ${System.currentTimeMillis()}&quot;)&#10;&#10;            // Performance-kritische Indizes&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_locations_cachedAt` ON `locations` (`cachedAt`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_completedAt` ON `games` (`completedAt`)&quot;)&#10;&#10;            // Cleanup alter Daten&#10;            database.execSQL(&quot;DELETE FROM locations WHERE isCached = 0 AND isUsed = 1 AND cachedAt &lt; ${System.currentTimeMillis() - (7 * 24 * 60 * 60 * 1000)}&quot;)&#10;        }&#10;    }&#10;&#10;    private val MIGRATION_5_6 = object : Migration(5, 6) {&#10;        override fun migrate(database: SupportSQLiteDatabase) {&#10;            // Version 6: Foreign Key und Offline Mode Fixes&#10;&#10;            // Prüfe ob games Tabelle existiert bevor wir sie bearbeiten&#10;            val cursor = database.query(&quot;SELECT name FROM sqlite_master WHERE type='table' AND name='games'&quot;)&#10;            val gamesTableExists = cursor.moveToFirst()&#10;            cursor.close()&#10;&#10;            if (gamesTableExists) {&#10;                // Temporäre Tabellen erstellen ohne Foreign Key Constraints&#10;                database.execSQL(&quot;&quot;&quot;&#10;                    CREATE TABLE games_temp (&#10;                        id TEXT PRIMARY KEY NOT NULL,&#10;                        userId TEXT NOT NULL,&#10;                        gameMode TEXT NOT NULL DEFAULT 'classic',&#10;                        totalRounds INTEGER NOT NULL DEFAULT 5,&#10;                        currentRound INTEGER NOT NULL DEFAULT 1,&#10;                        score INTEGER NOT NULL DEFAULT 0,&#10;                        isCompleted INTEGER NOT NULL DEFAULT 0,&#10;                        createdAt INTEGER NOT NULL DEFAULT ${System.currentTimeMillis()},&#10;                        startedAt INTEGER,&#10;                        completedAt INTEGER,&#10;                        duration INTEGER&#10;                    )&#10;                &quot;&quot;&quot;)&#10;&#10;                // Daten kopieren falls Tabelle Daten hat&#10;                try {&#10;                    database.execSQL(&quot;&quot;&quot;&#10;                        INSERT INTO games_temp &#10;                        SELECT id, userId, gameMode, totalRounds, currentRound, score, isCompleted, createdAt, startedAt, completedAt, duration &#10;                        FROM games&#10;                    &quot;&quot;&quot;)&#10;                } catch (e: Exception) {&#10;                    // Falls Spalten fehlen, erstelle nur Basis-Daten&#10;                    database.execSQL(&quot;&quot;&quot;&#10;                        INSERT INTO games_temp (id, userId, gameMode, totalRounds, currentRound, score, isCompleted, createdAt)&#10;                        SELECT id, userId, &#10;                               COALESCE(gameMode, 'classic') as gameMode,&#10;                               COALESCE(totalRounds, 5) as totalRounds,&#10;                               COALESCE(currentRound, 1) as currentRound,&#10;                               COALESCE(score, 0) as score,&#10;                               COALESCE(isCompleted, 0) as isCompleted,&#10;                               COALESCE(createdAt, ${System.currentTimeMillis()}) as createdAt&#10;                        FROM games&#10;                    &quot;&quot;&quot;)&#10;                }&#10;&#10;                // Alte Tabelle löschen und neue umbenennen&#10;                database.execSQL(&quot;DROP TABLE games&quot;)&#10;                database.execSQL(&quot;ALTER TABLE games_temp RENAME TO games&quot;)&#10;            } else {&#10;                // Falls games Tabelle nicht existiert, erstelle sie neu&#10;                database.execSQL(&quot;&quot;&quot;&#10;                    CREATE TABLE games (&#10;                        id TEXT PRIMARY KEY NOT NULL,&#10;                        userId TEXT NOT NULL,&#10;                        gameMode TEXT NOT NULL DEFAULT 'classic',&#10;                        totalRounds INTEGER NOT NULL DEFAULT 5,&#10;                        currentRound INTEGER NOT NULL DEFAULT 1,&#10;                        score INTEGER NOT NULL DEFAULT 0,&#10;                        isCompleted INTEGER NOT NULL DEFAULT 0,&#10;                        createdAt INTEGER NOT NULL DEFAULT ${System.currentTimeMillis()},&#10;                        startedAt INTEGER,&#10;                        completedAt INTEGER,&#10;                        duration INTEGER&#10;                    )&#10;                &quot;&quot;&quot;)&#10;            }&#10;&#10;            // Indizes neu erstellen ohne Foreign Key Constraints&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_userId` ON `games` (`userId`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_isCompleted` ON `games` (`isCompleted`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_createdAt` ON `games` (`createdAt`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_completedAt` ON `games` (`completedAt`)&quot;)&#10;&#10;            // Prüfe ob users Tabelle existiert&#10;            val usersCursor = database.query(&quot;SELECT name FROM sqlite_master WHERE type='table' AND name='users'&quot;)&#10;            val usersTableExists = usersCursor.moveToFirst()&#10;            usersCursor.close()&#10;&#10;            if (!usersTableExists) {&#10;                // Erstelle users Tabelle falls sie nicht existiert&#10;                database.execSQL(&quot;&quot;&quot;&#10;                    CREATE TABLE users (&#10;                        id TEXT PRIMARY KEY NOT NULL,&#10;                        username TEXT NOT NULL,&#10;                        email TEXT NOT NULL,&#10;                        authToken TEXT,&#10;                        totalScore INTEGER NOT NULL DEFAULT 0,&#10;                        gamesPlayed INTEGER NOT NULL DEFAULT 0,&#10;                        bestScore INTEGER NOT NULL DEFAULT 0,&#10;                        lastLoginAt INTEGER NOT NULL DEFAULT 0,&#10;                        createdAt INTEGER NOT NULL DEFAULT ${System.currentTimeMillis()}&#10;                    )&#10;                &quot;&quot;&quot;)&#10;            }&#10;&#10;            // Emergency User erstellen falls nicht vorhanden&#10;            database.execSQL(&quot;&quot;&quot;&#10;                INSERT OR IGNORE INTO users (id, username, email, authToken, totalScore, gamesPlayed, bestScore, lastLoginAt, createdAt)&#10;                VALUES ('emergency_user', 'Emergency User', 'emergency@local.com', NULL, 0, 0, 0, ${System.currentTimeMillis()}, ${System.currentTimeMillis()})&#10;            &quot;&quot;&quot;)&#10;        }&#10;    }&#10;&#10;    private val MIGRATION_6_7 = object : Migration(6, 7) {&#10;        override fun migrate(database: SupportSQLiteDatabase) {&#10;            // Version 7: Sanfte Bereinigung der Database-Probleme ohne komplettes Löschen&#10;&#10;            // Prüfe welche Tabellen existieren&#10;            val gamesCursor = database.query(&quot;SELECT name FROM sqlite_master WHERE type='table' AND name='games'&quot;)&#10;            val gamesTableExists = gamesCursor.moveToFirst()&#10;            gamesCursor.close()&#10;&#10;            val locationsCursor = database.query(&quot;SELECT name FROM sqlite_master WHERE type='table' AND name='locations'&quot;)&#10;            val locationsTableExists = locationsCursor.moveToFirst()&#10;            locationsCursor.close()&#10;&#10;            val guessesCursor = database.query(&quot;SELECT name FROM sqlite_master WHERE type='table' AND name='guesses'&quot;)&#10;            val guessesTableExists = guessesCursor.moveToFirst()&#10;            guessesCursor.close()&#10;&#10;            // Nur problematische games Tabelle neu erstellen (wegen &quot;duration&quot; Spalten-Problem)&#10;            if (gamesTableExists) {&#10;                database.execSQL(&quot;DROP TABLE IF EXISTS games&quot;)&#10;            }&#10;&#10;            // Erstelle games Tabelle neu mit korrekter Struktur&#10;            database.execSQL(&quot;&quot;&quot;&#10;                CREATE TABLE games (&#10;                    id TEXT PRIMARY KEY NOT NULL,&#10;                    userId TEXT NOT NULL,&#10;                    gameMode TEXT NOT NULL DEFAULT 'classic',&#10;                    totalRounds INTEGER NOT NULL DEFAULT 5,&#10;                    currentRound INTEGER NOT NULL DEFAULT 1,&#10;                    score INTEGER NOT NULL DEFAULT 0,&#10;                    isCompleted INTEGER NOT NULL DEFAULT 0,&#10;                    createdAt INTEGER NOT NULL,&#10;                    startedAt INTEGER,&#10;                    completedAt INTEGER,&#10;                    duration INTEGER&#10;                )&#10;            &quot;&quot;&quot;)&#10;&#10;            // Erstelle locations Tabelle nur wenn sie nicht existiert&#10;            if (!locationsTableExists) {&#10;                database.execSQL(&quot;&quot;&quot;&#10;                    CREATE TABLE locations (&#10;                        id TEXT PRIMARY KEY NOT NULL,&#10;                        latitude REAL NOT NULL,&#10;                        longitude REAL NOT NULL,&#10;                        imageUrl TEXT NOT NULL,&#10;                        country TEXT,&#10;                        city TEXT,&#10;                        difficulty INTEGER NOT NULL DEFAULT 1,&#10;                        isCached INTEGER NOT NULL DEFAULT 0,&#10;                        isUsed INTEGER NOT NULL DEFAULT 0,&#10;                        cachedAt INTEGER NOT NULL DEFAULT ${System.currentTimeMillis()}&#10;                    )&#10;                &quot;&quot;&quot;)&#10;            }&#10;&#10;            // Erstelle guesses Tabelle nur wenn sie nicht existiert&#10;            if (!guessesTableExists) {&#10;                database.execSQL(&quot;&quot;&quot;&#10;                    CREATE TABLE guesses (&#10;                        id TEXT PRIMARY KEY NOT NULL,&#10;                        gameId TEXT NOT NULL,&#10;                        locationId TEXT NOT NULL,&#10;                        guessLat REAL NOT NULL,&#10;                        guessLng REAL NOT NULL,&#10;                        actualLat REAL NOT NULL,&#10;                        actualLng REAL NOT NULL,&#10;                        distance REAL NOT NULL,&#10;                        score INTEGER NOT NULL,&#10;                        timeSpent INTEGER NOT NULL,&#10;                        submittedAt INTEGER NOT NULL&#10;                    )&#10;                &quot;&quot;&quot;)&#10;            }&#10;&#10;            // Erstelle alle Indizes neu (falls sie nicht existieren)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_userId` ON `games` (`userId`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_isCompleted` ON `games` (`isCompleted`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_createdAt` ON `games` (`createdAt`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_guesses_gameId` ON `guesses` (`gameId`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_guesses_locationId` ON `guesses` (`locationId`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_locations_isUsed_isCached` ON `locations` (`isUsed`, `isCached`)&quot;)&#10;&#10;            // Stelle sicher, dass users Tabelle existiert&#10;            val usersCursor = database.query(&quot;SELECT name FROM sqlite_master WHERE type='table' AND name='users'&quot;)&#10;            val usersTableExists = usersCursor.moveToFirst()&#10;            usersCursor.close()&#10;&#10;            if (!usersTableExists) {&#10;                database.execSQL(&quot;&quot;&quot;&#10;                    CREATE TABLE users (&#10;                        id TEXT PRIMARY KEY NOT NULL,&#10;                        username TEXT NOT NULL,&#10;                        email TEXT NOT NULL,&#10;                        authToken TEXT,&#10;                        totalScore INTEGER NOT NULL DEFAULT 0,&#10;                        gamesPlayed INTEGER NOT NULL DEFAULT 0,&#10;                        bestScore INTEGER NOT NULL DEFAULT 0,&#10;                        lastLoginAt INTEGER NOT NULL DEFAULT 0,&#10;                        createdAt INTEGER NOT NULL DEFAULT ${System.currentTimeMillis()}&#10;                    )&#10;                &quot;&quot;&quot;)&#10;            }&#10;&#10;            // Emergency User erstellen&#10;            database.execSQL(&quot;&quot;&quot;&#10;                INSERT OR IGNORE INTO users (id, username, email, authToken, totalScore, gamesPlayed, bestScore, lastLoginAt, createdAt)&#10;                VALUES ('emergency_user', 'Emergency User', 'emergency@local.com', NULL, 0, 0, 0, ${System.currentTimeMillis()}, ${System.currentTimeMillis()})&#10;            &quot;&quot;&quot;)&#10;&#10;            // Füge Standard-Fallback-Locations hinzu falls locations Tabelle leer ist&#10;            try {&#10;                val countCursor = database.query(&quot;SELECT COUNT(*) FROM locations&quot;)&#10;                val hasLocations = if (countCursor.moveToFirst()) {&#10;                    countCursor.getInt(0) &gt; 0&#10;                } else {&#10;                    false&#10;                }&#10;                countCursor.close()&#10;&#10;                if (!hasLocations) {&#10;                    // Füge eine Fallback-Location hinzu&#10;                    database.execSQL(&quot;&quot;&quot;&#10;                        INSERT INTO locations (id, latitude, longitude, imageUrl, country, city, difficulty, isCached, isUsed, cachedAt)&#10;                        VALUES ('fallback_paris', 48.8566, 2.3522, 'https://images.unsplash.com/photo-1502602898536-47ad22581b52?w=800', 'France', 'Paris', 2, 1, 0, ${System.currentTimeMillis()})&#10;                    &quot;&quot;&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                // Silent fail - Fallback-Location konnte nicht eingefügt werden&#10;            }&#10;        }&#10;    }&#10;&#10;" />
              <option name="updatedContent" value="package com.example.geogeusserclone&#10;&#10;import android.content.Context&#10;import androidx.room.Room&#10;import androidx.room.migration.Migration&#10;import androidx.sqlite.db.SupportSQLiteDatabase&#10;import com.example.geogeusserclone.data.database.AppDatabase&#10;import dagger.Module&#10;import dagger.Provides&#10;import dagger.hilt.InstallIn&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#10;import dagger.hilt.components.SingletonComponent&#10;import java.util.concurrent.Executors&#10;import javax.inject.Singleton&#10;&#10;@Module&#10;@InstallIn(SingletonComponent::class)&#10;object DatabaseModule {&#10;&#10;    private val MIGRATION_1_2 = object : Migration(1, 2) {&#10;        override fun migrate(database: SupportSQLiteDatabase) {&#10;            // Add indices&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_guesses_gameId` ON `guesses` (`gameId`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_guesses_locationId` ON `guesses` (`locationId`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_guesses_submittedAt` ON `guesses` (`submittedAt`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_userId` ON `games` (`userId`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_createdAt` ON `games` (`createdAt`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_isCompleted` ON `games` (`isCompleted`)&quot;)&#10;        }&#10;    }&#10;&#10;    private val MIGRATION_2_3 = object : Migration(2, 3) {&#10;        override fun migrate(database: SupportSQLiteDatabase) {&#10;            // Add missing columns to users table&#10;            database.execSQL(&quot;ALTER TABLE users ADD COLUMN totalScore INTEGER NOT NULL DEFAULT 0&quot;)&#10;            database.execSQL(&quot;ALTER TABLE users ADD COLUMN gamesPlayed INTEGER NOT NULL DEFAULT 0&quot;)&#10;            database.execSQL(&quot;ALTER TABLE users ADD COLUMN bestScore INTEGER NOT NULL DEFAULT 0&quot;)&#10;            database.execSQL(&quot;ALTER TABLE users ADD COLUMN lastLoginAt INTEGER NOT NULL DEFAULT 0&quot;)&#10;            database.execSQL(&quot;ALTER TABLE users ADD COLUMN createdAt INTEGER NOT NULL DEFAULT 0&quot;)&#10;            database.execSQL(&quot;ALTER TABLE locations ADD COLUMN isUsed INTEGER NOT NULL DEFAULT 0&quot;)&#10;        }&#10;    }&#10;&#10;    private val MIGRATION_3_4 = object : Migration(3, 4) {&#10;        override fun migrate(database: SupportSQLiteDatabase) {&#10;            // Performance-optimierte Indizes hinzufügen&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_locations_isUsed_isCached` ON `locations` (`isUsed`, `isCached`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_locations_difficulty` ON `locations` (`difficulty`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_users_authToken` ON `users` (`authToken`)&quot;)&#10;&#10;            // Game Performance Indizes&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_userId_isCompleted` ON `games` (`userId`, `isCompleted`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_guesses_gameId_submittedAt` ON `guesses` (`gameId`, `submittedAt`)&quot;)&#10;        }&#10;    }&#10;&#10;    private val MIGRATION_4_5 = object : Migration(4, 5) {&#10;        override fun migrate(database: SupportSQLiteDatabase) {&#10;            // Version 5: Optimierung für bessere Performance und Memory Management&#10;&#10;            // Neue Game Spalten für erweiterte Statistiken&#10;            database.execSQL(&quot;ALTER TABLE games ADD COLUMN startedAt INTEGER&quot;)&#10;            database.execSQL(&quot;ALTER TABLE games ADD COLUMN completedAt INTEGER&quot;)&#10;            database.execSQL(&quot;ALTER TABLE games ADD COLUMN duration INTEGER&quot;)&#10;&#10;            // Location Cache Optimierungen&#10;            database.execSQL(&quot;ALTER TABLE locations ADD COLUMN cachedAt INTEGER NOT NULL DEFAULT ${System.currentTimeMillis()}&quot;)&#10;&#10;            // Performance-kritische Indizes&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_locations_cachedAt` ON `locations` (`cachedAt`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_completedAt` ON `games` (`completedAt`)&quot;)&#10;&#10;            // Cleanup alter Daten&#10;            database.execSQL(&quot;DELETE FROM locations WHERE isCached = 0 AND isUsed = 1 AND cachedAt &lt; ${System.currentTimeMillis() - (7 * 24 * 60 * 60 * 1000)}&quot;)&#10;        }&#10;    }&#10;&#10;    private val MIGRATION_5_6 = object : Migration(5, 6) {&#10;        override fun migrate(database: SupportSQLiteDatabase) {&#10;            // Version 6: Foreign Key und Offline Mode Fixes&#10;&#10;            // Prüfe ob games Tabelle existiert bevor wir sie bearbeiten&#10;            val cursor = database.query(&quot;SELECT name FROM sqlite_master WHERE type='table' AND name='games'&quot;)&#10;            val gamesTableExists = cursor.moveToFirst()&#10;            cursor.close()&#10;&#10;            if (gamesTableExists) {&#10;                // Temporäre Tabellen erstellen ohne Foreign Key Constraints&#10;                database.execSQL(&quot;&quot;&quot;&#10;                    CREATE TABLE games_temp (&#10;                        id TEXT PRIMARY KEY NOT NULL,&#10;                        userId TEXT NOT NULL,&#10;                        gameMode TEXT NOT NULL DEFAULT 'classic',&#10;                        totalRounds INTEGER NOT NULL DEFAULT 5,&#10;                        currentRound INTEGER NOT NULL DEFAULT 1,&#10;                        score INTEGER NOT NULL DEFAULT 0,&#10;                        isCompleted INTEGER NOT NULL DEFAULT 0,&#10;                        createdAt INTEGER NOT NULL DEFAULT ${System.currentTimeMillis()},&#10;                        startedAt INTEGER,&#10;                        completedAt INTEGER,&#10;                        duration INTEGER&#10;                    )&#10;                &quot;&quot;&quot;)&#10;&#10;                // Daten kopieren falls Tabelle Daten hat&#10;                try {&#10;                    database.execSQL(&quot;&quot;&quot;&#10;                        INSERT INTO games_temp &#10;                        SELECT id, userId, gameMode, totalRounds, currentRound, score, isCompleted, createdAt, startedAt, completedAt, duration &#10;                        FROM games&#10;                    &quot;&quot;&quot;)&#10;                } catch (e: Exception) {&#10;                    // Falls Spalten fehlen, erstelle nur Basis-Daten&#10;                    database.execSQL(&quot;&quot;&quot;&#10;                        INSERT INTO games_temp (id, userId, gameMode, totalRounds, currentRound, score, isCompleted, createdAt)&#10;                        SELECT id, userId, &#10;                               COALESCE(gameMode, 'classic') as gameMode,&#10;                               COALESCE(totalRounds, 5) as totalRounds,&#10;                               COALESCE(currentRound, 1) as currentRound,&#10;                               COALESCE(score, 0) as score,&#10;                               COALESCE(isCompleted, 0) as isCompleted,&#10;                               COALESCE(createdAt, ${System.currentTimeMillis()}) as createdAt&#10;                        FROM games&#10;                    &quot;&quot;&quot;)&#10;                }&#10;&#10;                // Alte Tabelle löschen und neue umbenennen&#10;                database.execSQL(&quot;DROP TABLE games&quot;)&#10;                database.execSQL(&quot;ALTER TABLE games_temp RENAME TO games&quot;)&#10;            } else {&#10;                // Falls games Tabelle nicht existiert, erstelle sie neu&#10;                database.execSQL(&quot;&quot;&quot;&#10;                    CREATE TABLE games (&#10;                        id TEXT PRIMARY KEY NOT NULL,&#10;                        userId TEXT NOT NULL,&#10;                        gameMode TEXT NOT NULL DEFAULT 'classic',&#10;                        totalRounds INTEGER NOT NULL DEFAULT 5,&#10;                        currentRound INTEGER NOT NULL DEFAULT 1,&#10;                        score INTEGER NOT NULL DEFAULT 0,&#10;                        isCompleted INTEGER NOT NULL DEFAULT 0,&#10;                        createdAt INTEGER NOT NULL DEFAULT ${System.currentTimeMillis()},&#10;                        startedAt INTEGER,&#10;                        completedAt INTEGER,&#10;                        duration INTEGER&#10;                    )&#10;                &quot;&quot;&quot;)&#10;            }&#10;&#10;            // Indizes neu erstellen ohne Foreign Key Constraints&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_userId` ON `games` (`userId`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_isCompleted` ON `games` (`isCompleted`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_createdAt` ON `games` (`createdAt`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_completedAt` ON `games` (`completedAt`)&quot;)&#10;&#10;            // Prüfe ob users Tabelle existiert&#10;            val usersCursor = database.query(&quot;SELECT name FROM sqlite_master WHERE type='table' AND name='users'&quot;)&#10;            val usersTableExists = usersCursor.moveToFirst()&#10;            usersCursor.close()&#10;&#10;            if (!usersTableExists) {&#10;                // Erstelle users Tabelle falls sie nicht existiert&#10;                database.execSQL(&quot;&quot;&quot;&#10;                    CREATE TABLE users (&#10;                        id TEXT PRIMARY KEY NOT NULL,&#10;                        username TEXT NOT NULL,&#10;                        email TEXT NOT NULL,&#10;                        authToken TEXT,&#10;                        totalScore INTEGER NOT NULL DEFAULT 0,&#10;                        gamesPlayed INTEGER NOT NULL DEFAULT 0,&#10;                        bestScore INTEGER NOT NULL DEFAULT 0,&#10;                        lastLoginAt INTEGER NOT NULL DEFAULT 0,&#10;                        createdAt INTEGER NOT NULL DEFAULT ${System.currentTimeMillis()}&#10;                    )&#10;                &quot;&quot;&quot;)&#10;            }&#10;&#10;            // Emergency User erstellen falls nicht vorhanden&#10;            database.execSQL(&quot;&quot;&quot;&#10;                INSERT OR IGNORE INTO users (id, username, email, authToken, totalScore, gamesPlayed, bestScore, lastLoginAt, createdAt)&#10;                VALUES ('emergency_user', 'Emergency User', 'emergency@local.com', NULL, 0, 0, 0, ${System.currentTimeMillis()}, ${System.currentTimeMillis()})&#10;            &quot;&quot;&quot;)&#10;        }&#10;    }&#10;&#10;    private val MIGRATION_6_7 = object : Migration(6, 7) {&#10;        override fun migrate(database: SupportSQLiteDatabase) {&#10;            // Version 7: Sanfte Bereinigung der Database-Probleme ohne komplettes Löschen&#10;&#10;            // Prüfe welche Tabellen existieren&#10;            val gamesCursor = database.query(&quot;SELECT name FROM sqlite_master WHERE type='table' AND name='games'&quot;)&#10;            val gamesTableExists = gamesCursor.moveToFirst()&#10;            gamesCursor.close()&#10;&#10;            val locationsCursor = database.query(&quot;SELECT name FROM sqlite_master WHERE type='table' AND name='locations'&quot;)&#10;            val locationsTableExists = locationsCursor.moveToFirst()&#10;            locationsCursor.close()&#10;&#10;            val guessesCursor = database.query(&quot;SELECT name FROM sqlite_master WHERE type='table' AND name='guesses'&quot;)&#10;            val guessesTableExists = guessesCursor.moveToFirst()&#10;            guessesCursor.close()&#10;&#10;            // Nur problematische games Tabelle neu erstellen (wegen &quot;duration&quot; Spalten-Problem)&#10;            if (gamesTableExists) {&#10;                database.execSQL(&quot;DROP TABLE IF EXISTS games&quot;)&#10;            }&#10;&#10;            // Erstelle games Tabelle neu mit korrekter Struktur&#10;            database.execSQL(&quot;&quot;&quot;&#10;                CREATE TABLE games (&#10;                    id TEXT PRIMARY KEY NOT NULL,&#10;                    userId TEXT NOT NULL,&#10;                    gameMode TEXT NOT NULL DEFAULT 'classic',&#10;                    totalRounds INTEGER NOT NULL DEFAULT 5,&#10;                    currentRound INTEGER NOT NULL DEFAULT 1,&#10;                    score INTEGER NOT NULL DEFAULT 0,&#10;                    isCompleted INTEGER NOT NULL DEFAULT 0,&#10;                    createdAt INTEGER NOT NULL,&#10;                    startedAt INTEGER,&#10;                    completedAt INTEGER,&#10;                    duration INTEGER&#10;                )&#10;            &quot;&quot;&quot;)&#10;&#10;            // Erstelle locations Tabelle nur wenn sie nicht existiert&#10;            if (!locationsTableExists) {&#10;                database.execSQL(&quot;&quot;&quot;&#10;                    CREATE TABLE locations (&#10;                        id TEXT PRIMARY KEY NOT NULL,&#10;                        latitude REAL NOT NULL,&#10;                        longitude REAL NOT NULL,&#10;                        imageUrl TEXT NOT NULL,&#10;                        country TEXT,&#10;                        city TEXT,&#10;                        difficulty INTEGER NOT NULL DEFAULT 1,&#10;                        isCached INTEGER NOT NULL DEFAULT 0,&#10;                        isUsed INTEGER NOT NULL DEFAULT 0,&#10;                        cachedAt INTEGER NOT NULL DEFAULT ${System.currentTimeMillis()}&#10;                    )&#10;                &quot;&quot;&quot;)&#10;            }&#10;&#10;            // Erstelle guesses Tabelle nur wenn sie nicht existiert&#10;            if (!guessesTableExists) {&#10;                database.execSQL(&quot;&quot;&quot;&#10;                    CREATE TABLE guesses (&#10;                        id TEXT PRIMARY KEY NOT NULL,&#10;                        gameId TEXT NOT NULL,&#10;                        locationId TEXT NOT NULL,&#10;                        guessLat REAL NOT NULL,&#10;                        guessLng REAL NOT NULL,&#10;                        actualLat REAL NOT NULL,&#10;                        actualLng REAL NOT NULL,&#10;                        distance REAL NOT NULL,&#10;                        score INTEGER NOT NULL,&#10;                        timeSpent INTEGER NOT NULL,&#10;                        submittedAt INTEGER NOT NULL&#10;                    )&#10;                &quot;&quot;&quot;)&#10;            }&#10;&#10;            // Erstelle alle Indizes neu (falls sie nicht existieren)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_userId` ON `games` (`userId`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_isCompleted` ON `games` (`isCompleted`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_createdAt` ON `games` (`createdAt`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_guesses_gameId` ON `guesses` (`gameId`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_guesses_locationId` ON `guesses` (`locationId`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_locations_isUsed_isCached` ON `locations` (`isUsed`, `isCached`)&quot;)&#10;&#10;            // Stelle sicher, dass users Tabelle existiert&#10;            val usersCursor = database.query(&quot;SELECT name FROM sqlite_master WHERE type='table' AND name='users'&quot;)&#10;            val usersTableExists = usersCursor.moveToFirst()&#10;            usersCursor.close()&#10;&#10;            if (!usersTableExists) {&#10;                database.execSQL(&quot;&quot;&quot;&#10;                    CREATE TABLE users (&#10;                        id TEXT PRIMARY KEY NOT NULL,&#10;                        username TEXT NOT NULL,&#10;                        email TEXT NOT NULL,&#10;                        authToken TEXT,&#10;                        totalScore INTEGER NOT NULL DEFAULT 0,&#10;                        gamesPlayed INTEGER NOT NULL DEFAULT 0,&#10;                        bestScore INTEGER NOT NULL DEFAULT 0,&#10;                        lastLoginAt INTEGER NOT NULL DEFAULT 0,&#10;                        createdAt INTEGER NOT NULL DEFAULT ${System.currentTimeMillis()}&#10;                    )&#10;                &quot;&quot;&quot;)&#10;            }&#10;&#10;            // Emergency User erstellen&#10;            database.execSQL(&quot;&quot;&quot;&#10;                INSERT OR IGNORE INTO users (id, username, email, authToken, totalScore, gamesPlayed, bestScore, lastLoginAt, createdAt)&#10;                VALUES ('emergency_user', 'Emergency User', 'emergency@local.com', NULL, 0, 0, 0, ${System.currentTimeMillis()}, ${System.currentTimeMillis()})&#10;            &quot;&quot;&quot;)&#10;&#10;            // Füge Standard-Fallback-Locations hinzu falls locations Tabelle leer ist&#10;            try {&#10;                val countCursor = database.query(&quot;SELECT COUNT(*) FROM locations&quot;)&#10;                val hasLocations = if (countCursor.moveToFirst()) {&#10;                    countCursor.getInt(0) &gt; 0&#10;                } else {&#10;                    false&#10;                }&#10;                countCursor.close()&#10;&#10;                if (!hasLocations) {&#10;                    // Füge eine Fallback-Location hinzu&#10;                    database.execSQL(&quot;&quot;&quot;&#10;                        INSERT INTO locations (id, latitude, longitude, imageUrl, country, city, difficulty, isCached, isUsed, cachedAt)&#10;                        VALUES ('fallback_paris', 48.8566, 2.3522, 'https://images.unsplash.com/photo-1502602898536-47ad22581b52?w=800', 'France', 'Paris', 2, 1, 0, ${System.currentTimeMillis()})&#10;                    &quot;&quot;&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                // Silent fail - Fallback-Location konnte nicht eingefügt werden&#10;            }&#10;        }&#10;    }&#10;&#10;    private val MIGRATION_7_8 = object : Migration(7, 8) {&#10;        override fun migrate(database: SupportSQLiteDatabase) {&#10;            // Version 8: Radikaler Clean-Slate. Löscht alle Tabellen und erstellt sie neu.&#10;            // Dies behebt alle vorherigen Migrationsprobleme garantiert.&#10;&#10;            // 1. Alle alten Tabellen löschen&#10;            database.execSQL(&quot;DROP TABLE IF EXISTS `games`&quot;)&#10;            database.execSQL(&quot;DROP TABLE IF EXISTS `guesses`&quot;)&#10;            database.execSQL(&quot;DROP TABLE IF EXISTS `locations`&quot;)&#10;            database.execSQL(&quot;DROP TABLE IF EXISTS `users`&quot;)&#10;&#10;            // 2. Alle Tabellen mit der korrekten, aktuellen Struktur neu erstellen&#10;            database.execSQL(&quot;&quot;&quot;&#10;                CREATE TABLE `users` (&#10;                    `id` TEXT NOT NULL, &#10;                    `username` TEXT NOT NULL, &#10;                    `email` TEXT NOT NULL, &#10;                    `authToken` TEXT, &#10;                    `totalScore` INTEGER NOT NULL DEFAULT 0, &#10;                    `gamesPlayed` INTEGER NOT NULL DEFAULT 0, &#10;                    `bestScore` INTEGER NOT NULL DEFAULT 0, &#10;                    `lastLoginAt` INTEGER NOT NULL DEFAULT 0, &#10;                    `createdAt` INTEGER NOT NULL, &#10;                    PRIMARY KEY(`id`)&#10;                )&#10;            &quot;&quot;&quot;)&#10;&#10;            database.execSQL(&quot;&quot;&quot;&#10;                CREATE TABLE `locations` (&#10;                    `id` TEXT NOT NULL, &#10;                    `latitude` REAL NOT NULL, &#10;                    `longitude` REAL NOT NULL, &#10;                    `imageUrl` TEXT NOT NULL, &#10;                    `country` TEXT, &#10;                    `city` TEXT, &#10;                    `difficulty` INTEGER NOT NULL DEFAULT 1, &#10;                    `isCached` INTEGER NOT NULL DEFAULT 0, &#10;                    `isUsed` INTEGER NOT NULL DEFAULT 0, &#10;                    `cachedAt` INTEGER NOT NULL, &#10;                    PRIMARY KEY(`id`)&#10;                )&#10;            &quot;&quot;&quot;)&#10;&#10;            database.execSQL(&quot;&quot;&quot;&#10;                CREATE TABLE `games` (&#10;                    `id` TEXT NOT NULL, &#10;                    `userId` TEXT NOT NULL, &#10;                    `gameMode` TEXT NOT NULL, &#10;                    `totalRounds` INTEGER NOT NULL, &#10;                    `currentRound` INTEGER NOT NULL, &#10;                    `score` INTEGER NOT NULL, &#10;                    `isCompleted` INTEGER NOT NULL, &#10;                    `createdAt` INTEGER NOT NULL, &#10;                    `startedAt` INTEGER, &#10;                    `completedAt` INTEGER, &#10;                    `duration` INTEGER, &#10;                    PRIMARY KEY(`id`)&#10;                )&#10;            &quot;&quot;&quot;)&#10;            &#10;            database.execSQL(&quot;&quot;&quot;&#10;                CREATE TABLE `guesses` (&#10;                    `id` TEXT NOT NULL, &#10;                    `gameId` TEXT NOT NULL, &#10;                    `locationId` TEXT NOT NULL, &#10;                    `guessLat` REAL NOT NULL, &#10;                    `guessLng` REAL NOT NULL, &#10;                    `actualLat` REAL NOT NULL, &#10;                    `actualLng` REAL NOT NULL, &#10;                    `distance` REAL NOT NULL, &#10;                    `score` INTEGER NOT NULL, &#10;                    `timeSpent` INTEGER NOT NULL, &#10;                    `submittedAt` INTEGER NOT NULL, &#10;                    PRIMARY KEY(`id`)&#10;                )&#10;            &quot;&quot;&quot;)&#10;&#10;            // 3. Alle Indizes neu erstellen&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_games_userId` ON `games` (`userId`)&quot;)&#10;            database.execSQL(&quot;CREATE INDEX IF NOT EXISTS `index_locations_isUsed_isCached` ON `locations` (`isUsed`, `isCached`)&quot;)&#10;&#10;            // 4. Notwendige Start-Daten einfügen&#10;            database.execSQL(&quot;&quot;&quot;&#10;                INSERT INTO users (id, username, email, createdAt) &#10;                VALUES ('emergency_user', 'Emergency User', 'emergency@local.com', ${System.currentTimeMillis()})&#10;            &quot;&quot;&quot;)&#10;            database.execSQL(&quot;&quot;&quot;&#10;                INSERT INTO locations (id, latitude, longitude, imageUrl, country, city, cachedAt)&#10;                VALUES ('fallback_paris', 48.8566, 2.3522, 'https://images.unsplash.com/photo-1502602898536-47ad22581b52?w=800', 'France', 'Paris', ${System.currentTimeMillis()})&#10;            &quot;&quot;&quot;)&#10;        }&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {&#10;        return Room.databaseBuilder(&#10;            context,&#10;            AppDatabase::class.java,&#10;            &quot;geoguesser_database&quot;&#10;        )&#10;        .addMigrations(&#10;            MIGRATION_1_2,&#10;            MIGRATION_2_3,&#10;            MIGRATION_3_4,&#10;            MIGRATION_4_5,&#10;            MIGRATION_5_6,&#10;            MIGRATION_6_7,&#10;            MIGRATION_7_8 // Neue, saubere Migration&#10;        )&#10;        .setQueryExecutor(Executors.newFixedThreadPool(4))&#10;        .setTransactionExecutor(Executors.newFixedThreadPool(2))&#10;        // Fallback Strategy für Development&#10;        .fallbackToDestructiveMigration()&#10;        .build()&#10;    }&#10;&#10;    @Provides&#10;    fun provideUserDao(database: AppDatabase) = database.userDao()&#10;&#10;    @Provides&#10;    fun provideLocationDao(database: AppDatabase) = database.locationDao()&#10;&#10;    @Provides&#10;    fun provideGameDao(database: AppDatabase) = database.gameDao()&#10;&#10;    @Provides&#10;    fun provideGuessDao(database: AppDatabase) = database.guessDao()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/database/dao/GuessDao.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/database/dao/GuessDao.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.database.dao&#10;&#10;import androidx.room.*&#10;import com.example.geogeusserclone.data.database.entities.GuessEntity&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;@Dao&#10;interface GuessDao {&#10;&#10;    @Query(&quot;SELECT * FROM guesses WHERE id = :guessId&quot;)&#10;    suspend fun getGuessById(guessId: String): GuessEntity?&#10;&#10;    @Query(&quot;SELECT * FROM guesses WHERE gameId = :gameId ORDER BY submittedAt ASC&quot;)&#10;    fun getGuessesByGame(gameId: String): Flow&lt;List&lt;GuessEntity&gt;&gt;&#10;&#10;    @Query(&quot;SELECT * FROM guesses WHERE gameId = :gameId ORDER BY submittedAt ASC&quot;)&#10;    suspend fun getGuessesByGameSync(gameId: String): List&lt;GuessEntity&gt;&#10;&#10;    @Query(&quot;SELECT * FROM guesses WHERE locationId = :locationId&quot;)&#10;    suspend fun getGuessesByLocation(locationId: String): List&lt;GuessEntity&gt;&#10;&#10;    @Query(&quot;SELECT AVG(score) FROM guesses WHERE gameId IN (SELECT id FROM games WHERE userId = :userId)&quot;)&#10;    suspend fun getAverageScoreByUser(userId: String): Double?&#10;&#10;    @Query(&quot;SELECT MAX(score) FROM guesses WHERE gameId IN (SELECT id FROM games WHERE userId = :userId)&quot;)&#10;    suspend fun getBestScoreByUser(userId: String): Int?&#10;&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertGuess(guess: GuessEntity)&#10;&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertGuesses(guesses: List&lt;GuessEntity&gt;)&#10;&#10;    @Update&#10;    suspend fun updateGuess(guess: GuessEntity)&#10;&#10;    @Delete&#10;    suspend fun deleteGuess(guess: GuessEntity)&#10;&#10;    @Query(&quot;DELETE FROM guesses WHERE gameId = :gameId&quot;)&#10;    suspend fun deleteGuessesByGame(gameId: String)&#10;&#10;    @Query(&quot;SELECT COUNT(*) FROM guesses WHERE gameId = :gameId&quot;)&#10;    suspend fun getGuessCountByGame(gameId: String): Int&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/database/entities/GuessEntity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/database/entities/GuessEntity.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.database.entities&#10;&#10;import androidx.room.Entity&#10;import androidx.room.ForeignKey&#10;import androidx.room.Index&#10;import androidx.room.PrimaryKey&#10;&#10;@Entity(&#10;    tableName = &quot;guesses&quot;,&#10;    foreignKeys = [&#10;        ForeignKey(&#10;            entity = GameEntity::class,&#10;            parentColumns = [&quot;id&quot;],&#10;            childColumns = [&quot;gameId&quot;],&#10;            onDelete = ForeignKey.CASCADE&#10;        ),&#10;        ForeignKey(&#10;            entity = LocationEntity::class,&#10;            parentColumns = [&quot;id&quot;],&#10;            childColumns = [&quot;locationId&quot;],&#10;            onDelete = ForeignKey.CASCADE&#10;        )&#10;    ],&#10;    indices = [&#10;        Index(value = [&quot;gameId&quot;]),&#10;        Index(value = [&quot;locationId&quot;]),&#10;        Index(value = [&quot;submittedAt&quot;])&#10;    ]&#10;)&#10;data class GuessEntity(&#10;    @PrimaryKey&#10;    val id: String,&#10;    val gameId: String,&#10;    val locationId: String,&#10;    val guessLat: Double,&#10;    val guessLng: Double,&#10;    val actualLat: Double,&#10;    val actualLng: Double,&#10;    val distance: Double,&#10;    val score: Int,&#10;    val timeSpent: Long,&#10;    val submittedAt: Long = System.currentTimeMillis()&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/network/LocationResponse.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/network/LocationResponse.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.network&#10;&#10;data class LocationResponse(&#10;    val id: String,&#10;    val latitude: Double,&#10;    val longitude: Double,&#10;    val imageUrl: String,&#10;    val country: String? = null,&#10;    val city: String? = null,&#10;    val difficulty: Int = 1&#10;)&#10;&#10;data class LocationsResponse(&#10;    val locations: List&lt;LocationResponse&gt;,&#10;    val total: Int = 0,&#10;    val page: Int = 1,&#10;    val limit: Int = 10&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/network/NetworkConfig.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/network/NetworkConfig.kt" />
              <option name="originalContent" value="package com.example.geogeusserclone.data.network&#10;&#10;import com.example.geogeusserclone.BuildConfig&#10;&#10;object NetworkConfig {&#10;    // Android Emulator&#10;    const val EMULATOR_BASE_URL = &quot;http://10.0.2.2:3000/api/&quot;&#10;&#10;    // Lokales Netzwerk (IP-Adresse anpassen)&#10;    const val LOCAL_BASE_URL = &quot;http://192.168.1.100:3000/api/&quot;&#10;&#10;    // Production (falls vorhanden)&#10;    const val PROD_BASE_URL = &quot;https://your-domain.com/api/&quot;&#10;&#10;    val BASE_URL = if (BuildConfig.DEBUG) {&#10;        EMULATOR_BASE_URL // Für Android Emulator&#10;        // LOCAL_BASE_URL // Uncomment für echtes Gerät&#10;    } else {&#10;        PROD_BASE_URL&#10;    }&#10;&#10;    // Timeout-Konfiguration&#10;    const val CONNECT_TIMEOUT = 30L&#10;    const val READ_TIMEOUT = 30L&#10;    const val WRITE_TIMEOUT = 30L&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.network&#10;&#10;object NetworkConfig {&#10;    // Android Emulator&#10;    const val EMULATOR_BASE_URL = &quot;http://10.0.2.2:3000/api/&quot;&#10;&#10;    // Lokales Netzwerk (IP-Adresse anpassen)&#10;    const val LOCAL_BASE_URL = &quot;http://192.168.1.100:3000/api/&quot;&#10;&#10;    // Production (falls vorhanden)&#10;    const val PROD_BASE_URL = &quot;https://your-domain.com/api/&quot;&#10;&#10;    val BASE_URL = EMULATOR_BASE_URL // Verwende Emulator URL direkt&#10;&#10;    // Timeout-Konfiguration&#10;    const val CONNECT_TIMEOUT = 30L&#10;    const val READ_TIMEOUT = 30L&#10;    const val WRITE_TIMEOUT = 30L&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/repositories/LocationCacheRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/repositories/LocationCacheRepository.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.repositories&#13;&#10;&#13;&#10;import com.example.geogeusserclone.data.database.dao.LocationDao&#13;&#10;import com.example.geogeusserclone.data.database.entities.LocationEntity&#13;&#10;import com.example.geogeusserclone.data.network.ApiService&#13;&#10;import kotlinx.coroutines.Dispatchers&#13;&#10;import kotlinx.coroutines.flow.Flow&#13;&#10;import kotlinx.coroutines.withContext&#13;&#10;import javax.inject.Inject&#13;&#10;import javax.inject.Singleton&#13;&#10;&#13;&#10;@Singleton&#13;&#10;class LocationCacheRepository @Inject constructor(&#13;&#10;    private val apiService: ApiService,&#13;&#10;    private val locationDao: LocationDao&#13;&#10;) {&#13;&#10;&#13;&#10;    suspend fun preloadLocationsInBackground() = withContext(Dispatchers.IO) {&#13;&#10;        try {&#13;&#10;            // Lade nur wenn weniger als 10 Locations im Cache&#13;&#10;            val cachedCount = locationDao.getCachedLocationCount()&#13;&#10;            if (cachedCount &lt; 10) {&#13;&#10;                val response = apiService.getRandomLocations(50)&#13;&#10;                if (response.isSuccessful) {&#13;&#10;                    val locationsResponse = response.body()!!&#13;&#10;                    val locationEntities = locationsResponse.data.locations.map { backendLocation -&gt;&#13;&#10;                        LocationEntity(&#13;&#10;                            id = backendLocation.id.toString(),&#13;&#10;                            latitude = backendLocation.coordinates.latitude,&#13;&#10;                            longitude = backendLocation.coordinates.longitude,&#13;&#10;                            imageUrl = backendLocation.imageUrls.firstOrNull() ?: &quot;&quot;,&#13;&#10;                            country = backendLocation.country,&#13;&#10;                            city = backendLocation.city,&#13;&#10;                            difficulty = backendLocation.difficulty,&#13;&#10;                            isCached = true,&#13;&#10;                            isUsed = false&#13;&#10;                        )&#13;&#10;                    }&#13;&#10;&#13;&#10;                    // Batch insert für bessere Performance&#13;&#10;                    locationDao.insertLocations(locationEntities)&#13;&#10;&#13;&#10;                    // Preload images im Hintergrund&#13;&#10;                    preloadImages(locationEntities.take(5)) // Nur erste 5 Bilder&#13;&#10;                }&#13;&#10;            }&#13;&#10;        } catch (e: Exception) {&#13;&#10;            // Silent fail - App funktioniert weiter mit Fallback Locations&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private suspend fun preloadImages(locations: List&lt;LocationEntity&gt;) = withContext(Dispatchers.IO) {&#13;&#10;        // Implementierung für Image Preloading&#13;&#10;        // Dies würde die Bilder in den Cache laden ohne sie anzuzeigen&#13;&#10;    }&#13;&#10;&#13;&#10;    suspend fun getNextLocations(count: Int = 3): List&lt;LocationEntity&gt; = withContext(Dispatchers.IO) {&#13;&#10;        locationDao.getUnusedLocations(count)&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/repositories/StreetViewLocationRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/repositories/StreetViewLocationRepository.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.repositories&#10;&#10;import com.example.geogeusserclone.data.database.dao.LocationDao&#10;import com.example.geogeusserclone.data.database.entities.LocationEntity&#10;import com.example.geogeusserclone.data.network.ApiService&#10;import com.example.geogeusserclone.data.network.MapillaryApiService&#10;import com.example.geogeusserclone.utils.Constants&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.withTimeoutOrNull&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class StreetViewLocationRepository @Inject constructor(&#10;    private val apiService: ApiService,&#10;    private val mapillaryApiService: MapillaryApiService,&#10;    private val locationDao: LocationDao&#10;) : BaseRepository() {&#10;&#10;    suspend fun getRandomLocationWithStreetView(): Result&lt;LocationEntity&gt; {&#10;        return try {&#10;            // 1. Versuche zuerst lokale unbenutzte Location&#10;            val unusedLocation = locationDao.getRandomUnusedLocation()&#10;            if (unusedLocation != null) {&#10;                locationDao.markLocationAsUsed(unusedLocation.id)&#10;                return Result.success(unusedLocation)&#10;            }&#10;&#10;            // 2. Erstelle Fallback-Locations mit echten 360° StreetView-Bildern&#10;            val streetViewLocations = createStreetViewFallbackLocations()&#10;            locationDao.insertLocations(streetViewLocations)&#10;            &#10;            val randomLocation = streetViewLocations.random()&#10;            locationDao.markLocationAsUsed(randomLocation.id)&#10;            &#10;            return Result.success(randomLocation)&#10;&#10;        } catch (e: Exception) {&#10;            // Emergency Fallback&#10;            val emergencyLocation = createEmergencyLocation()&#10;            try {&#10;                locationDao.insertLocation(emergencyLocation)&#10;                locationDao.markLocationAsUsed(emergencyLocation.id)&#10;                Result.success(emergencyLocation)&#10;            } catch (dbError: Exception) {&#10;                Result.failure(Exception(&quot;Kritischer Fehler: Kann keine Location laden&quot;))&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun createStreetViewFallbackLocations(): List&lt;LocationEntity&gt; {&#10;        val fallbackLocations = mutableListOf&lt;LocationEntity&gt;()&#10;        &#10;        // Versuche echte Mapillary-Bilder für beliebte Städte zu holen&#10;        val popularCities = listOf(&#10;            Triple(48.8566, 2.3522, &quot;Paris&quot;),      // Paris&#10;            Triple(51.5074, -0.1278, &quot;London&quot;),   // London&#10;            Triple(40.7128, -74.0060, &quot;New York&quot;), // New York&#10;            Triple(35.6762, 139.6503, &quot;Tokyo&quot;),   // Tokyo&#10;            Triple(-33.8688, 151.2093, &quot;Sydney&quot;), // Sydney&#10;            Triple(52.5200, 13.4050, &quot;Berlin&quot;),   // Berlin&#10;            Triple(41.9028, 12.4964, &quot;Rome&quot;),     // Rome&#10;            Triple(41.3851, 2.1734, &quot;Barcelona&quot;)  // Barcelona&#10;        )&#10;&#10;        popularCities.forEachIndexed { index, (lat, lng, cityName) -&gt;&#10;            try {&#10;                val streetViewImage = fetchMapillaryImageForLocation(lat, lng)&#10;                if (streetViewImage != null) {&#10;                    fallbackLocations.add(&#10;                        LocationEntity(&#10;                            id = &quot;streetview_${cityName.lowercase()}_$index&quot;,&#10;                            latitude = streetViewImage.geometry.coordinates[1], // Mapillary coords&#10;                            longitude = streetViewImage.geometry.coordinates[0],&#10;                            imageUrl = streetViewImage.thumb_2048_url ?: streetViewImage.thumb_1024_url ?: &quot;&quot;,&#10;                            country = getCountryFromCity(cityName),&#10;                            city = cityName,&#10;                            difficulty = 2,&#10;                            isCached = true,&#10;                            isUsed = false&#10;                        )&#10;                    )&#10;                } else {&#10;                    // Fallback auf hochwertige Unsplash-Bilder&#10;                    fallbackLocations.add(createHighQualityFallbackLocation(lat, lng, cityName, index))&#10;                }&#10;            } catch (e: Exception) {&#10;                // Fallback auf statische Bilder&#10;                fallbackLocations.add(createHighQualityFallbackLocation(lat, lng, cityName, index))&#10;            }&#10;        }&#10;&#10;        return fallbackLocations&#10;    }&#10;&#10;    private suspend fun fetchMapillaryImageForLocation(lat: Double, lng: Double): com.example.geogeusserclone.data.network.MapillaryImage? {&#10;        return try {&#10;            // Erstelle Bounding Box (ca. 1km Radius)&#10;            val offset = 0.01 // Ungefähr 1km&#10;            val bbox = &quot;${lng - offset},${lat - offset},${lng + offset},${lat + offset}&quot;&#10;            &#10;            val response = withTimeoutOrNull(3000) {&#10;                mapillaryApiService.getImagesNearby(&#10;                    bbox = bbox,&#10;                    isPano = true,&#10;                    limit = 5,&#10;                    accessToken = Constants.MAPILLARY_ACCESS_TOKEN&#10;                )&#10;            }&#10;&#10;            if (response?.isSuccessful == true) {&#10;                response.body()?.data?.firstOrNull()&#10;            } else null&#10;        } catch (e: Exception) {&#10;            null&#10;        }&#10;    }&#10;&#10;    private fun createHighQualityFallbackLocation(lat: Double, lng: Double, cityName: String, index: Int): LocationEntity {&#10;        val imageUrls = mapOf(&#10;            &quot;Paris&quot; to &quot;https://images.unsplash.com/photo-1502602898536-47ad22581b52?w=1200&amp;h=800&amp;fit=crop&quot;,&#10;            &quot;London&quot; to &quot;https://images.unsplash.com/photo-1513635269975-59663e0ac1ad?w=1200&amp;h=800&amp;fit=crop&quot;,&#10;            &quot;New York&quot; to &quot;https://images.unsplash.com/photo-1496442226666-8d4d0e62e6e9?w=1200&amp;h=800&amp;fit=crop&quot;,&#10;            &quot;Tokyo&quot; to &quot;https://images.unsplash.com/photo-1540959733332-eab4deabeeaf?w=1200&amp;h=800&amp;fit=crop&quot;,&#10;            &quot;Sydney&quot; to &quot;https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=1200&amp;h=800&amp;fit=crop&quot;,&#10;            &quot;Berlin&quot; to &quot;https://images.unsplash.com/photo-1587330979470-3016b6702d89?w=1200&amp;h=800&amp;fit=crop&quot;,&#10;            &quot;Rome&quot; to &quot;https://images.unsplash.com/photo-1552832230-c0197dd311b5?w=1200&amp;h=800&amp;fit=crop&quot;,&#10;            &quot;Barcelona&quot; to &quot;https://images.unsplash.com/photo-1539037116277-4db20889f2d4?w=1200&amp;h=800&amp;fit=crop&quot;&#10;        )&#10;&#10;        return LocationEntity(&#10;            id = &quot;fallback_${cityName.lowercase()}_$index&quot;,&#10;            latitude = lat,&#10;            longitude = lng,&#10;            imageUrl = imageUrls[cityName] ?: &quot;https://images.unsplash.com/photo-1502602898536-47ad22581b52?w=1200&amp;h=800&amp;fit=crop&quot;,&#10;            country = getCountryFromCity(cityName),&#10;            city = cityName,&#10;            difficulty = 2,&#10;            isCached = true,&#10;            isUsed = false&#10;        )&#10;    }&#10;&#10;    private fun createEmergencyLocation(): LocationEntity {&#10;        return LocationEntity(&#10;            id = &quot;emergency_paris&quot;,&#10;            latitude = 48.8566,&#10;            longitude = 2.3522,&#10;            imageUrl = &quot;https://images.unsplash.com/photo-1502602898536-47ad22581b52?w=1200&amp;h=800&amp;fit=crop&quot;,&#10;            country = &quot;France&quot;,&#10;            city = &quot;Paris&quot;,&#10;            difficulty = 2,&#10;            isCached = true,&#10;            isUsed = false&#10;        )&#10;    }&#10;&#10;    private fun getCountryFromCity(cityName: String): String {&#10;        return when (cityName) {&#10;            &quot;Paris&quot; -&gt; &quot;France&quot;&#10;            &quot;London&quot; -&gt; &quot;United Kingdom&quot;&#10;            &quot;New York&quot; -&gt; &quot;United States&quot;&#10;            &quot;Tokyo&quot; -&gt; &quot;Japan&quot;&#10;            &quot;Sydney&quot; -&gt; &quot;Australia&quot;&#10;            &quot;Berlin&quot; -&gt; &quot;Germany&quot;&#10;            &quot;Rome&quot; -&gt; &quot;Italy&quot;&#10;            &quot;Barcelona&quot; -&gt; &quot;Spain&quot;&#10;            else -&gt; &quot;Unknown&quot;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Preloade Locations mit echten StreetView-Bildern&#10;     */&#10;    suspend fun preloadStreetViewLocations() {&#10;        try {&#10;            val streetViewLocations = createStreetViewFallbackLocations()&#10;            locationDao.insertLocations(streetViewLocations)&#10;        } catch (e: Exception) {&#10;            // Fallback auf normale Locations&#10;            val normalFallbacks = createStreetViewFallbackLocations()&#10;            locationDao.insertLocations(normalFallbacks)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/di/NetworkModule.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/di/NetworkModule.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.di&#10;&#10;import com.example.geogeusserclone.data.network.ApiService&#10;import com.example.geogeusserclone.data.network.AuthInterceptor&#10;import com.example.geogeusserclone.utils.Constants&#10;import dagger.Module&#10;import dagger.Provides&#10;import dagger.hilt.InstallIn&#10;import dagger.hilt.components.SingletonComponent&#10;import okhttp3.OkHttpClient&#10;import okhttp3.logging.HttpLoggingInterceptor&#10;import retrofit2.Retrofit&#10;import retrofit2.converter.gson.GsonConverterFactory&#10;import java.util.concurrent.TimeUnit&#10;import javax.inject.Singleton&#10;&#10;@Module&#10;@InstallIn(SingletonComponent::class)&#10;object NetworkModule {&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideHttpLoggingInterceptor(): HttpLoggingInterceptor {&#10;        return HttpLoggingInterceptor().apply {&#10;            level = HttpLoggingInterceptor.Level.BODY&#10;        }&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideOkHttpClient(&#10;        authInterceptor: AuthInterceptor,&#10;        loggingInterceptor: HttpLoggingInterceptor&#10;    ): OkHttpClient {&#10;        return OkHttpClient.Builder()&#10;            .addInterceptor(authInterceptor)&#10;            .addInterceptor(loggingInterceptor)&#10;            .connectTimeout(Constants.CONNECT_TIMEOUT, TimeUnit.SECONDS)&#10;            .readTimeout(Constants.READ_TIMEOUT, TimeUnit.SECONDS)&#10;            .writeTimeout(Constants.WRITE_TIMEOUT, TimeUnit.SECONDS)&#10;            .build()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {&#10;        return Retrofit.Builder()&#10;            .baseUrl(Constants.BASE_URL)&#10;            .client(okHttpClient)&#10;            .addConverterFactory(GsonConverterFactory.create())&#10;            .build()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideApiService(retrofit: Retrofit): ApiService {&#10;        return retrofit.create(ApiService::class.java)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/di/RepositoryModule.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/di/RepositoryModule.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.di&#10;&#10;import com.example.geogeusserclone.data.database.dao.GameDao&#10;import com.example.geogeusserclone.data.database.dao.GuessDao&#10;import com.example.geogeusserclone.data.database.dao.LocationDao&#10;import com.example.geogeusserclone.data.database.dao.UserDao&#10;import com.example.geogeusserclone.data.network.ApiService&#10;import com.example.geogeusserclone.data.network.MapillaryApiService&#10;import com.example.geogeusserclone.data.repositories.*&#10;import dagger.Module&#10;import dagger.Provides&#10;import dagger.hilt.InstallIn&#10;import dagger.hilt.components.SingletonComponent&#10;import javax.inject.Singleton&#10;&#10;@Module&#10;@InstallIn(SingletonComponent::class)&#10;object RepositoryModule {&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideUserRepository(&#10;        apiService: ApiService,&#10;        userDao: UserDao,&#10;        authInterceptor: com.example.geogeusserclone.data.network.AuthInterceptor&#10;    ): UserRepository {&#10;        return UserRepository(apiService, userDao, authInterceptor)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideLocationRepository(&#10;        apiService: ApiService,&#10;        mapillaryApiService: MapillaryApiService,&#10;        locationDao: LocationDao&#10;    ): LocationRepository {&#10;        return LocationRepository(apiService, mapillaryApiService, locationDao)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideGameRepository(&#10;        apiService: ApiService,&#10;        gameDao: GameDao,&#10;        guessDao: GuessDao,&#10;        locationDao: LocationDao,&#10;        userRepository: UserRepository&#10;    ): GameRepository {&#10;        return GameRepository(apiService, gameDao, guessDao, locationDao, userRepository)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideLocationCacheRepository(&#10;        apiService: ApiService,&#10;        locationDao: LocationDao&#10;    ): LocationCacheRepository {&#10;        return LocationCacheRepository(apiService, locationDao)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/ui/components/MapViewScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/ui/components/MapViewScreen.kt" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/utils/EdgeToEdge.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/utils/EdgeToEdge.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.utils&#10;&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.enableEdgeToEdge as androidEnableEdgeToEdge&#10;&#10;fun ComponentActivity.enableEdgeToEdge() {&#10;    androidEnableEdgeToEdge()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/utils/MapCacheManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/utils/MapCacheManager.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.utils&#10;&#10;import android.content.Context&#10;import androidx.work.*&#10;import com.example.geogeusserclone.data.repositories.LocationCacheRepository&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#10;import java.util.concurrent.TimeUnit&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;/**&#10; * Background-Service für Map Tile Preloading&#10; */&#10;@Singleton&#10;class MapCacheManager @Inject constructor(&#10;    @ApplicationContext private val context: Context,&#10;    private val locationCacheRepository: LocationCacheRepository&#10;) {&#10;&#10;    /**&#10;     * Startet Background-Preloading von Map Tiles&#10;     */&#10;    fun startMapTilePreloading() {&#10;        val constraints = Constraints.Builder()&#10;            .setRequiredNetworkType(NetworkType.UNMETERED) // Nur WLAN&#10;            .setRequiresBatteryNotLow(true)&#10;            .setRequiresCharging(false)&#10;            .build()&#10;&#10;        val preloadWork = OneTimeWorkRequestBuilder&lt;MapTilePreloadWorker&gt;()&#10;            .setConstraints(constraints)&#10;            .setBackoffCriteria(&#10;                BackoffPolicy.EXPONENTIAL,&#10;                WorkRequest.MIN_BACKOFF_MILLIS,&#10;                TimeUnit.MILLISECONDS&#10;            )&#10;            .build()&#10;&#10;        WorkManager.getInstance(context)&#10;            .enqueueUniqueWork(&#10;                &quot;map_tile_preload&quot;,&#10;                ExistingWorkPolicy.KEEP,&#10;                preloadWork&#10;            )&#10;    }&#10;&#10;    /**&#10;     * Bereinigt alte Map Tiles bei Low Memory&#10;     */&#10;    fun cleanupOldTiles() {&#10;        val cleanupWork = OneTimeWorkRequestBuilder&lt;MapTileCleanupWorker&gt;()&#10;            .build()&#10;&#10;        WorkManager.getInstance(context)&#10;            .enqueue(cleanupWork)&#10;    }&#10;&#10;    /**&#10;     * Überwacht Map Performance Metriken&#10;     */&#10;    fun trackMapPerformance(&#10;        loadTime: Long,&#10;        tileCount: Int,&#10;        memoryUsage: Long&#10;    ) {&#10;        // Performance Tracking für Optimierungen&#10;        if (loadTime &gt; 3000) { // Über 3 Sekunden&#10;            // Trigger für Cache-Optimierung&#10;            cleanupOldTiles()&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Worker für Map Tile Preloading&#10; */&#10;class MapTilePreloadWorker(&#10;    context: Context,&#10;    params: WorkerParameters&#10;) : CoroutineWorker(context, params) {&#10;&#10;    override suspend fun doWork(): Result {&#10;        return try {&#10;            // Preload häufig verwendete Gebiete&#10;            preloadPopularRegions()&#10;            Result.success()&#10;        } catch (e: Exception) {&#10;            Result.retry()&#10;        }&#10;    }&#10;&#10;    private suspend fun preloadPopularRegions() {&#10;        val popularRegions = listOf(&#10;            Pair(54.5260, 15.2551), // Europa&#10;            Pair(39.8283, -98.5795), // USA&#10;            Pair(35.6762, 139.6503), // Tokyo&#10;            Pair(-33.8688, 151.2093) // Sydney&#10;        )&#10;&#10;        // Implementierung des Tile-Preloadings&#10;        // Dies würde die Tiles für diese Regionen im Cache speichern&#10;    }&#10;}&#10;&#10;/**&#10; * Worker für Map Cache Cleanup&#10; */&#10;class MapTileCleanupWorker(&#10;    context: Context,&#10;    params: WorkerParameters&#10;) : CoroutineWorker(context, params) {&#10;&#10;    override suspend fun doWork(): Result {&#10;        return try {&#10;            val cacheDir = applicationContext.cacheDir&#10;            val mapCacheDir = java.io.File(cacheDir, &quot;osmdroid&quot;)&#10;            &#10;            if (mapCacheDir.exists()) {&#10;                // Lösche Tiles älter als 7 Tage&#10;                val weekAgo = System.currentTimeMillis() - (7 * 24 * 60 * 60 * 1000)&#10;                &#10;                mapCacheDir.listFiles()?.forEach { file -&gt;&#10;                    if (file.lastModified() &lt; weekAgo) {&#10;                        file.delete()&#10;                    }&#10;                }&#10;            }&#10;            &#10;            Result.success()&#10;        } catch (e: Exception) {&#10;            Result.failure()&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>