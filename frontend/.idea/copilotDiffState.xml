<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/network/ApiService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/network/ApiService.kt" />
              <option name="originalContent" value="package com.example.geogeusserclone.data.network&#10;&#10;import retrofit2.Response&#10;import retrofit2.http.*&#10;&#10;interface ApiService {&#10;&#10;    // Authentication Endpoints&#10;    @POST(&quot;api/auth/login&quot;)&#10;    suspend fun login(@Body loginRequest: LoginRequest): Response&lt;AuthResponse&gt;&#10;&#10;    @POST(&quot;api/auth/register&quot;)&#10;    suspend fun register(@Body registerRequest: RegisterRequest): Response&lt;AuthResponse&gt;&#10;&#10;    @POST(&quot;api/auth/refresh&quot;)&#10;    suspend fun refreshToken(@Body refreshRequest: RefreshTokenRequest): Response&lt;AuthResponse&gt;&#10;&#10;    @POST(&quot;api/auth/logout&quot;)&#10;    suspend fun logout(): Response&lt;Unit&gt;&#10;&#10;    // Game Endpoints&#10;    @GET(&quot;api/game/location&quot;)&#10;    suspend fun getRandomLocation(): Response&lt;LocationResponse&gt;&#10;&#10;    @POST(&quot;api/game/create&quot;)&#10;    suspend fun createGame(@Body gameRequest: CreateGameRequest): Response&lt;GameResponse&gt;&#10;&#10;    @POST(&quot;api/game/guess&quot;)&#10;    suspend fun submitGuess(@Body guessRequest: GuessRequest): Response&lt;GuessResponse&gt;&#10;&#10;    @GET(&quot;api/game/{gameId}&quot;)&#10;    suspend fun getGame(@Path(&quot;gameId&quot;) gameId: String): Response&lt;GameResponse&gt;&#10;&#10;    @PUT(&quot;api/game/{gameId}/complete&quot;)&#10;    suspend fun completeGame(@Path(&quot;gameId&quot;) gameId: String): Response&lt;GameResponse&gt;&#10;&#10;    // User &amp; Stats Endpoints&#10;    @GET(&quot;api/user/stats&quot;)&#10;    suspend fun getUserStats(): Response&lt;UserStatsResponse&gt;&#10;&#10;    @GET(&quot;api/user/profile&quot;)&#10;    suspend fun getUserProfile(): Response&lt;UserDto&gt;&#10;&#10;    @PUT(&quot;api/user/profile&quot;)&#10;    suspend fun updateUserProfile(@Body updateRequest: UpdateProfileRequest): Response&lt;UserDto&gt;&#10;&#10;    // Leaderboard &amp; Social&#10;    @GET(&quot;api/leaderboard&quot;)&#10;    suspend fun getLeaderboard(@Query(&quot;limit&quot;) limit: Int = 10): Response&lt;LeaderboardResponse&gt;&#10;&#10;    @GET(&quot;api/leaderboard/friends&quot;)&#10;    suspend fun getFriendsLeaderboard(): Response&lt;LeaderboardResponse&gt;&#10;&#10;    // Battle Royale Endpoints&#10;    @POST(&quot;api/battle-royale/join&quot;)&#10;    suspend fun joinBattleRoyale(): Response&lt;BattleRoyaleResponse&gt;&#10;&#10;    @GET(&quot;api/battle-royale/{gameId}&quot;)&#10;    suspend fun getBattleRoyaleStatus(@Path(&quot;gameId&quot;) gameId: String): Response&lt;BattleRoyaleResponse&gt;&#10;&#10;    // Location Management&#10;    @GET(&quot;api/locations/batch&quot;)&#10;    suspend fun getLocationsBatch(@Query(&quot;count&quot;) count: Int = 10): Response&lt;LocationBatchResponse&gt;&#10;&#10;    @POST(&quot;api/locations/{locationId}/report&quot;)&#10;    suspend fun reportLocation(@Path(&quot;locationId&quot;) locationId: String, @Body report: LocationReportRequest): Response&lt;Unit&gt;&#10;&#10;&#10;    @PUT(&quot;users/{userId}/stats&quot;)&#10;    suspend fun updateUserStats(&#10;        @Path(&quot;userId&quot;) userId: String,&#10;        @Query(&quot;totalScore&quot;) totalScore: Int,&#10;        @Query(&quot;gamesPlayed&quot;) gamesPlayed: Int,&#10;        @Query(&quot;bestScore&quot;) bestScore: Int&#10;    ): Response&lt;Unit&gt;&#10;}&#10;&#10;// Request Data Classes&#10;data class LoginRequest(val email: String, val password: String)&#10;data class RegisterRequest(val username: String, val email: String, val password: String)&#10;data class RefreshTokenRequest(val refreshToken: String)&#10;data class CreateGameRequest(val gameMode: String, val rounds: Int = 5)&#10;data class GuessRequest(val gameId: String, val locationId: String, val latitude: Double, val longitude: Double)&#10;data class UpdateProfileRequest(val username: String?, val email: String?)&#10;data class LocationReportRequest(val reason: String, val description: String)&#10;&#10;// Response Data Classes&#10;data class AuthResponse(&#10;    val token: String,&#10;    val refreshToken: String,&#10;    val user: UserDto,&#10;    val expiresIn: Long&#10;)&#10;&#10;&#10;data class GameResponse(&#10;    val id: String,&#10;    val status: String,&#10;    val currentRound: Int,&#10;    val totalRounds: Int,&#10;    val score: Int,&#10;    val gameMode: String,&#10;    val isCompleted: Boolean,&#10;    val duration: Long?&#10;)&#10;&#10;data class GuessResponse(&#10;    val score: Int,&#10;    val distance: Double,&#10;    val points: Int,&#10;    val totalScore: Int,&#10;    val isCorrect: Boolean,&#10;    val timeBonus: Int = 0&#10;)&#10;&#10;data class UserStatsResponse(&#10;    val gamesPlayed: Int,&#10;    val totalScore: Int,&#10;    val bestScore: Int,&#10;    val averageScore: Double,&#10;    val totalDistance: Double,&#10;    val averageDistance: Double,&#10;    val bestDistance: Double,&#10;    val perfectGuesses: Int,&#10;    val rank: Int&#10;)&#10;&#10;data class LeaderboardResponse(&#10;    val users: List&lt;LeaderboardEntry&gt;,&#10;    val userRank: Int?,&#10;    val totalUsers: Int&#10;)&#10;&#10;data class BattleRoyaleResponse(&#10;    val gameId: String,&#10;    val status: String,&#10;    val players: List&lt;BattleRoyalePlayer&gt;,&#10;    val currentRound: Int,&#10;    val timeRemaining: Long,&#10;    val isEliminated: Boolean = false&#10;)&#10;&#10;data class LocationBatchResponse(&#10;    val locations: List&lt;LocationResponse&gt;&#10;)&#10;&#10;// Supporting Data Classes&#10;data class UserDto(&#10;    val id: String,&#10;    val username: String,&#10;    val email: String,&#10;    val createdAt: String,&#10;    val totalScore: Int = 0,&#10;    val gamesPlayed: Int = 0&#10;)&#10;&#10;data class LeaderboardEntry(&#10;    val userId: String,&#10;    val username: String,&#10;    val score: Int,&#10;    val rank: Int,&#10;    val gamesPlayed: Int,&#10;    val averageScore: Double&#10;)&#10;&#10;data class BattleRoyalePlayer(&#10;    val userId: String,&#10;    val username: String,&#10;    val score: Int,&#10;    val isEliminated: Boolean,&#10;    val rank: Int?&#10;)" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.network&#10;&#10;import retrofit2.Response&#10;import retrofit2.http.*&#10;&#10;interface ApiService {&#10;&#10;    // Authentication Endpoints&#10;    @POST(&quot;api/auth/login&quot;)&#10;    suspend fun login(@Body loginRequest: LoginRequest): Response&lt;AuthResponse&gt;&#10;&#10;    @POST(&quot;api/auth/register&quot;)&#10;    suspend fun register(@Body registerRequest: RegisterRequest): Response&lt;AuthResponse&gt;&#10;&#10;    @POST(&quot;api/auth/refresh&quot;)&#10;    suspend fun refreshToken(@Body refreshRequest: RefreshTokenRequest): Response&lt;AuthResponse&gt;&#10;&#10;    @POST(&quot;api/auth/logout&quot;)&#10;    suspend fun logout(): Response&lt;Unit&gt;&#10;&#10;    // Game Endpoints&#10;    @GET(&quot;api/game/location&quot;)&#10;    suspend fun getRandomLocation(): Response&lt;LocationResponse&gt;&#10;&#10;    @POST(&quot;api/game/create&quot;)&#10;    suspend fun createGame(@Body gameRequest: CreateGameRequest): Response&lt;GameResponse&gt;&#10;&#10;    @POST(&quot;api/game/guess&quot;)&#10;    suspend fun submitGuess(@Body guessRequest: GuessRequest): Response&lt;GuessResponse&gt;&#10;&#10;    @GET(&quot;api/game/{gameId}&quot;)&#10;    suspend fun getGame(@Path(&quot;gameId&quot;) gameId: String): Response&lt;GameResponse&gt;&#10;&#10;    @PUT(&quot;api/game/{gameId}/complete&quot;)&#10;    suspend fun completeGame(@Path(&quot;gameId&quot;) gameId: String): Response&lt;GameResponse&gt;&#10;&#10;    // User &amp; Stats Endpoints&#10;    @GET(&quot;api/user/stats&quot;)&#10;    suspend fun getUserStats(): Response&lt;UserStatsResponse&gt;&#10;&#10;    @GET(&quot;api/user/profile&quot;)&#10;    suspend fun getUserProfile(): Response&lt;UserDto&gt;&#10;&#10;    @PUT(&quot;api/user/profile&quot;)&#10;    suspend fun updateUserProfile(@Body updateRequest: UpdateProfileRequest): Response&lt;UserDto&gt;&#10;&#10;    // Leaderboard &amp; Social&#10;    @GET(&quot;api/leaderboard&quot;)&#10;    suspend fun getLeaderboard(@Query(&quot;limit&quot;) limit: Int = 10): Response&lt;LeaderboardResponse&gt;&#10;&#10;    @GET(&quot;api/leaderboard/friends&quot;)&#10;    suspend fun getFriendsLeaderboard(): Response&lt;LeaderboardResponse&gt;&#10;&#10;    // Battle Royale Endpoints&#10;    @POST(&quot;api/battle-royale/join&quot;)&#10;    suspend fun joinBattleRoyale(): Response&lt;BattleRoyaleResponse&gt;&#10;&#10;    @GET(&quot;api/battle-royale/{gameId}&quot;)&#10;    suspend fun getBattleRoyaleStatus(@Path(&quot;gameId&quot;) gameId: String): Response&lt;BattleRoyaleResponse&gt;&#10;&#10;    // Location Management&#10;    @GET(&quot;api/locations/batch&quot;)&#10;    suspend fun getLocationsBatch(@Query(&quot;count&quot;) count: Int = 10): Response&lt;LocationBatchResponse&gt;&#10;&#10;    @GET(&quot;api/locations&quot;)&#10;    suspend fun getLocations(@Query(&quot;count&quot;) count: Int = 50): Response&lt;LocationBatchResponse&gt;&#10;&#10;    @POST(&quot;api/locations/{locationId}/report&quot;)&#10;    suspend fun reportLocation(@Path(&quot;locationId&quot;) locationId: String, @Body report: LocationReportRequest): Response&lt;Unit&gt;&#10;&#10;&#10;    @PUT(&quot;users/{userId}/stats&quot;)&#10;    suspend fun updateUserStats(&#10;        @Path(&quot;userId&quot;) userId: String,&#10;        @Query(&quot;totalScore&quot;) totalScore: Int,&#10;        @Query(&quot;gamesPlayed&quot;) gamesPlayed: Int,&#10;        @Query(&quot;bestScore&quot;) bestScore: Int&#10;    ): Response&lt;Unit&gt;&#10;}&#10;&#10;// Request Data Classes&#10;data class LoginRequest(val email: String, val password: String)&#10;data class RegisterRequest(val username: String, val email: String, val password: String)&#10;data class RefreshTokenRequest(val refreshToken: String)&#10;data class CreateGameRequest(val gameMode: String, val rounds: Int = 5)&#10;data class GuessRequest(val gameId: String, val locationId: String, val latitude: Double, val longitude: Double)&#10;data class UpdateProfileRequest(val username: String?, val email: String?)&#10;data class LocationReportRequest(val reason: String, val description: String)&#10;&#10;// Response Data Classes&#10;data class AuthResponse(&#10;    val token: String,&#10;    val refreshToken: String,&#10;    val user: UserDto,&#10;    val expiresIn: Long&#10;)&#10;&#10;&#10;data class GameResponse(&#10;    val id: String,&#10;    val status: String,&#10;    val currentRound: Int,&#10;    val totalRounds: Int,&#10;    val score: Int,&#10;    val gameMode: String,&#10;    val isCompleted: Boolean,&#10;    val duration: Long?&#10;)&#10;&#10;data class GuessResponse(&#10;    val score: Int,&#10;    val distance: Double,&#10;    val points: Int,&#10;    val totalScore: Int,&#10;    val isCorrect: Boolean,&#10;    val timeBonus: Int = 0&#10;)&#10;&#10;data class UserStatsResponse(&#10;    val gamesPlayed: Int,&#10;    val totalScore: Int,&#10;    val bestScore: Int,&#10;    val averageScore: Double,&#10;    val totalDistance: Double,&#10;    val averageDistance: Double,&#10;    val bestDistance: Double,&#10;    val perfectGuesses: Int,&#10;    val rank: Int&#10;)&#10;&#10;data class LeaderboardResponse(&#10;    val users: List&lt;LeaderboardEntry&gt;,&#10;    val userRank: Int?,&#10;    val totalUsers: Int&#10;)&#10;&#10;data class BattleRoyaleResponse(&#10;    val gameId: String,&#10;    val status: String,&#10;    val players: List&lt;BattleRoyalePlayer&gt;,&#10;    val currentRound: Int,&#10;    val timeRemaining: Long,&#10;    val isEliminated: Boolean = false&#10;)&#10;&#10;data class LocationBatchResponse(&#10;    val locations: List&lt;LocationResponse&gt;&#10;)&#10;&#10;// Supporting Data Classes&#10;data class UserDto(&#10;    val id: String,&#10;    val username: String,&#10;    val email: String,&#10;    val createdAt: String,&#10;    val totalScore: Int = 0,&#10;    val gamesPlayed: Int = 0&#10;)&#10;&#10;data class LeaderboardEntry(&#10;    val userId: String,&#10;    val username: String,&#10;    val score: Int,&#10;    val rank: Int,&#10;    val gamesPlayed: Int,&#10;    val averageScore: Double&#10;)&#10;&#10;data class BattleRoyalePlayer(&#10;    val userId: String,&#10;    val username: String,&#10;    val score: Int,&#10;    val isEliminated: Boolean,&#10;    val rank: Int?&#10;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/network/AuthInterceptor.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/network/AuthInterceptor.kt" />
              <option name="originalContent" value="package com.example.geogeusserclone.data.network&#10;&#10;import kotlinx.coroutines.runBlocking&#10;import okhttp3.Interceptor&#10;import okhttp3.Response&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class AuthInterceptor @Inject constructor() : Interceptor {&#10;&#10;    private var authToken: String? = null&#10;    private var refreshToken: String? = null&#10;    private var tokenRefreshCallback: (suspend () -&gt; String?)? = null&#10;&#10;    override fun intercept(chain: Interceptor.Chain): Response {&#10;        val originalRequest = chain.request()&#10;&#10;        // Add auth token if available&#10;        val requestBuilder = originalRequest.newBuilder()&#10;        authToken?.let { token -&gt;&#10;            requestBuilder.addHeader(&quot;Authorization&quot;, &quot;Bearer $token&quot;)&#10;        }&#10;&#10;        val response = chain.proceed(requestBuilder.build())&#10;&#10;        // Handle 401 Unauthorized - try to refresh token&#10;        if (response.code == 401 &amp;&amp; refreshToken != null) {&#10;            response.close()&#10;&#10;            val newToken = runBlocking {&#10;                tokenRefreshCallback?.invoke()&#10;            }&#10;&#10;            if (newToken != null) {&#10;                authToken = newToken&#10;&#10;                // Retry the original request with new token&#10;                val newRequest = originalRequest.newBuilder()&#10;                    .addHeader(&quot;Authorization&quot;, &quot;Bearer $newToken&quot;)&#10;                    .build()&#10;&#10;                return chain.proceed(newRequest)&#10;            }&#10;        }&#10;&#10;        return response&#10;    }&#10;&#10;    fun setToken(token: String?) {&#10;        this.authToken = token&#10;    }&#10;&#10;    //Retry Logic:&#10;    fun setRefreshToken(token: String?) {&#10;        this.refreshToken = token&#10;    }&#10;&#10;    fun setTokenRefreshCallback(callback: suspend () -&gt; String?) {&#10;        this.tokenRefreshCallback = callback&#10;    }&#10;&#10;    fun clearTokens() {&#10;        authToken = null&#10;        refreshToken = null&#10;        tokenRefreshCallback = null&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.network&#10;&#10;import kotlinx.coroutines.runBlocking&#10;import okhttp3.Interceptor&#10;import okhttp3.Response&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class AuthInterceptor @Inject constructor() : Interceptor {&#10;&#10;    private var authToken: String? = null&#10;    private var refreshToken: String? = null&#10;    private var tokenRefreshCallback: (suspend () -&gt; String?)? = null&#10;&#10;    override fun intercept(chain: Interceptor.Chain): Response {&#10;        val originalRequest = chain.request()&#10;&#10;        // Add auth token if available&#10;        val requestBuilder = originalRequest.newBuilder()&#10;        authToken?.let { token -&gt;&#10;            requestBuilder.addHeader(&quot;Authorization&quot;, &quot;Bearer $token&quot;)&#10;        }&#10;&#10;        val response = chain.proceed(requestBuilder.build())&#10;&#10;        // Handle 401 Unauthorized - try to refresh token&#10;        if (response.code == 401 &amp;&amp; refreshToken != null) {&#10;            response.close()&#10;&#10;            val newToken = runBlocking {&#10;                tokenRefreshCallback?.invoke()&#10;            }&#10;&#10;            if (newToken != null) {&#10;                authToken = newToken&#10;&#10;                // Retry the original request with new token&#10;                val newRequest = originalRequest.newBuilder()&#10;                    .addHeader(&quot;Authorization&quot;, &quot;Bearer $newToken&quot;)&#10;                    .build()&#10;&#10;                return chain.proceed(newRequest)&#10;            }&#10;        }&#10;&#10;        return response&#10;    }&#10;&#10;    fun setAuthToken(token: String?) {&#10;        this.authToken = token&#10;    }&#10;&#10;    fun setToken(token: String?) {&#10;        this.authToken = token&#10;    }&#10;&#10;    //Retry Logic:&#10;    fun setRefreshToken(token: String?) {&#10;        this.refreshToken = token&#10;    }&#10;&#10;    fun setTokenRefreshCallback(callback: suspend () -&gt; String?) {&#10;        this.tokenRefreshCallback = callback&#10;    }&#10;&#10;    fun clearTokens() {&#10;        authToken = null&#10;        refreshToken = null&#10;        tokenRefreshCallback = null&#10;    }&#10;&#10;    fun clearAuthToken() {&#10;        authToken = null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/repositories/UserRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/repositories/UserRepository.kt" />
              <option name="originalContent" value="package com.example.geogeusserclone.data.repositories&#10;&#10;import com.example.geogeusserclone.data.database.dao.UserDao&#10;import com.example.geogeusserclone.data.database.entities.UserEntity&#10;import com.example.geogeusserclone.data.network.ApiService&#10;import com.example.geogeusserclone.data.network.AuthInterceptor&#10;import com.example.geogeusserclone.data.network.LoginRequest&#10;import com.example.geogeusserclone.data.network.RegisterRequest&#10;import com.example.geogeusserclone.data.network.RefreshTokenRequest&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.Flow&#10;import java.util.UUID&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class UserRepository @Inject constructor(&#10;    private val apiService: ApiService,&#10;    private val userDao: UserDao,&#10;    private val authInterceptor: AuthInterceptor&#10;) : BaseRepository() {&#10;&#10;    fun getCurrentUserFlow(): Flow&lt;UserEntity?&gt; = userDao.getCurrentUserFlow()&#10;&#10;    suspend fun getCurrentUser(): UserEntity? = userDao.getCurrentUserSync()&#10;&#10;    suspend fun login(email: String, password: String): Result&lt;UserEntity&gt; {&#10;        return try {&#10;            val response = apiService.login(LoginRequest(email, password))&#10;&#10;            if (response.isSuccessful) {&#10;                val loginResponse = response.body()!!&#10;                val user = UserEntity(&#10;                    id = loginResponse.user.id,&#10;                    username = loginResponse.user.username,&#10;                    email = loginResponse.user.email,&#10;                    authToken = loginResponse.token,&#10;                    refreshToken = loginResponse.refreshToken,&#10;                    totalScore = loginResponse.user.totalScore,&#10;                    gamesPlayed = loginResponse.user.gamesPlayed,&#10;                    bestScore = loginResponse.user.bestScore,&#10;                    lastLoginAt = System.currentTimeMillis()&#10;                )&#10;&#10;                userDao.clearCurrentUser()&#10;                userDao.insertUser(user)&#10;                authInterceptor.setAuthToken(loginResponse.token)&#10;&#10;                Result.success(user)&#10;            } else {&#10;                Result.failure(Exception(&quot;Login fehlgeschlagen&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    suspend fun register(username: String, email: String, password: String): Result&lt;UserEntity&gt; {&#10;        return try {&#10;            val response = apiService.register(RegisterRequest(username, email, password))&#10;&#10;            if (response.isSuccessful) {&#10;                val registerResponse = response.body()!!&#10;                val user = UserEntity(&#10;                    id = registerResponse.user.id,&#10;                    username = registerResponse.user.username,&#10;                    email = registerResponse.user.email,&#10;                    authToken = registerResponse.token,&#10;                    refreshToken = registerResponse.refreshToken,&#10;                    createdAt = System.currentTimeMillis(),&#10;                    lastLoginAt = System.currentTimeMillis()&#10;                )&#10;&#10;                userDao.clearCurrentUser()&#10;                userDao.insertUser(user)&#10;                authInterceptor.setAuthToken(registerResponse.token)&#10;&#10;                Result.success(user)&#10;            } else {&#10;                Result.failure(Exception(&quot;Registrierung fehlgeschlagen&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            // Offline Fallback für Registrierung&#10;            val offlineUser = UserEntity(&#10;                id = UUID.randomUUID().toString(),&#10;                username = username,&#10;                email = email,&#10;                authToken = &quot;offline_token&quot;,&#10;                createdAt = System.currentTimeMillis(),&#10;                lastLoginAt = System.currentTimeMillis()&#10;            )&#10;&#10;            userDao.clearCurrentUser()&#10;            userDao.insertUser(offlineUser)&#10;            authInterceptor.setAuthToken(&quot;offline_token&quot;)&#10;&#10;            Result.success(offlineUser)&#10;        }&#10;    }&#10;&#10;    suspend fun logout() {&#10;        try {&#10;            apiService.logout()&#10;        } catch (e: Exception) {&#10;            // Ignoriere Netzwerkfehler beim Logout&#10;        } finally {&#10;            userDao.clearCurrentUser()&#10;            authInterceptor.clearAuthToken()&#10;        }&#10;    }&#10;&#10;    suspend fun updateUserStats(userId: String, totalScore: Int, gamesPlayed: Int, bestScore: Int) {&#10;        userDao.updateUserStats(userId, totalScore, gamesPlayed, bestScore)&#10;&#10;        try {&#10;            // Versuche auch online zu synchronisieren&#10;            apiService.updateUserStats(userId, totalScore, gamesPlayed, bestScore)&#10;        } catch (e: Exception) {&#10;            // Ignoriere Netzwerkfehler&#10;        }&#10;    }&#10;&#10;    suspend fun refreshToken(): Result&lt;String&gt; {&#10;        return try {&#10;            val currentUser = getCurrentUser()&#10;            if (currentUser?.refreshToken != null) {&#10;                val response = apiService.refreshToken(RefreshTokenRequest(currentUser.refreshToken))&#10;                if (response.isSuccessful) {&#10;                    val tokenResponse = response.body()!!&#10;                    userDao.updateAuthToken(currentUser.id, tokenResponse.token, System.currentTimeMillis())&#10;                    authInterceptor.setAuthToken(tokenResponse.token)&#10;                    Result.success(tokenResponse.token)&#10;                } else {&#10;                    Result.failure(Exception(&quot;Token refresh failed&quot;))&#10;                }&#10;            } else {&#10;                Result.failure(Exception(&quot;No refresh token available&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.geogeusserclone.data.repositories&#10;&#10;import com.example.geogeusserclone.data.database.dao.UserDao&#10;import com.example.geogeusserclone.data.database.entities.UserEntity&#10;import com.example.geogeusserclone.data.network.ApiService&#10;import com.example.geogeusserclone.data.network.AuthInterceptor&#10;import com.example.geogeusserclone.data.network.LoginRequest&#10;import com.example.geogeusserclone.data.network.RegisterRequest&#10;import com.example.geogeusserclone.data.network.RefreshTokenRequest&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.Flow&#10;import java.util.UUID&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class UserRepository @Inject constructor(&#10;    private val apiService: ApiService,&#10;    private val userDao: UserDao,&#10;    private val authInterceptor: AuthInterceptor&#10;) : BaseRepository() {&#10;&#10;    fun getCurrentUserFlow(): Flow&lt;UserEntity?&gt; = userDao.getCurrentUserFlow()&#10;&#10;    suspend fun getCurrentUser(): UserEntity? = userDao.getCurrentUserSync()&#10;&#10;    suspend fun login(email: String, password: String): Result&lt;UserEntity&gt; {&#10;        return try {&#10;            val response = apiService.login(LoginRequest(email, password))&#10;&#10;            if (response.isSuccessful) {&#10;                val loginResponse = response.body()!!&#10;                val user = UserEntity(&#10;                    id = loginResponse.user.id,&#10;                    username = loginResponse.user.username,&#10;                    email = loginResponse.user.email,&#10;                    authToken = loginResponse.token,&#10;                    refreshToken = loginResponse.refreshToken,&#10;                    totalScore = loginResponse.user.totalScore ?: 0,&#10;                    gamesPlayed = loginResponse.user.gamesPlayed ?: 0,&#10;                    bestScore = 0, // Verwende Standardwert da bestScore möglicherweise nicht verfügbar ist&#10;                    lastLoginAt = System.currentTimeMillis()&#10;                )&#10;&#10;                userDao.clearCurrentUser()&#10;                userDao.insertUser(user)&#10;                authInterceptor.setAuthToken(loginResponse.token)&#10;&#10;                Result.success(user)&#10;            } else {&#10;                Result.failure(Exception(&quot;Login fehlgeschlagen&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    suspend fun register(username: String, email: String, password: String): Result&lt;UserEntity&gt; {&#10;        return try {&#10;            val response = apiService.register(RegisterRequest(username, email, password))&#10;&#10;            if (response.isSuccessful) {&#10;                val registerResponse = response.body()!!&#10;                val user = UserEntity(&#10;                    id = registerResponse.user.id,&#10;                    username = registerResponse.user.username,&#10;                    email = registerResponse.user.email,&#10;                    authToken = registerResponse.token,&#10;                    refreshToken = registerResponse.refreshToken,&#10;                    createdAt = System.currentTimeMillis(),&#10;                    lastLoginAt = System.currentTimeMillis()&#10;                )&#10;&#10;                userDao.clearCurrentUser()&#10;                userDao.insertUser(user)&#10;                authInterceptor.setAuthToken(registerResponse.token)&#10;&#10;                Result.success(user)&#10;            } else {&#10;                Result.failure(Exception(&quot;Registrierung fehlgeschlagen&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            // Offline Fallback für Registrierung&#10;            val offlineUser = UserEntity(&#10;                id = UUID.randomUUID().toString(),&#10;                username = username,&#10;                email = email,&#10;                authToken = &quot;offline_token&quot;,&#10;                createdAt = System.currentTimeMillis(),&#10;                lastLoginAt = System.currentTimeMillis()&#10;            )&#10;&#10;            userDao.clearCurrentUser()&#10;            userDao.insertUser(offlineUser)&#10;            authInterceptor.setAuthToken(&quot;offline_token&quot;)&#10;&#10;            Result.success(offlineUser)&#10;        }&#10;    }&#10;&#10;    suspend fun logout() {&#10;        try {&#10;            apiService.logout()&#10;        } catch (e: Exception) {&#10;            // Ignoriere Netzwerkfehler beim Logout&#10;        } finally {&#10;            userDao.clearCurrentUser()&#10;            authInterceptor.clearAuthToken()&#10;        }&#10;    }&#10;&#10;    suspend fun updateUserStats(userId: String, totalScore: Int, gamesPlayed: Int, bestScore: Int) {&#10;        userDao.updateUserStats(userId, totalScore, gamesPlayed, bestScore)&#10;&#10;        try {&#10;            // Versuche auch online zu synchronisieren&#10;            apiService.updateUserStats(userId, totalScore, gamesPlayed, bestScore)&#10;        } catch (e: Exception) {&#10;            // Ignoriere Netzwerkfehler&#10;        }&#10;    }&#10;&#10;    suspend fun refreshToken(): Result&lt;String&gt; {&#10;        return try {&#10;            val currentUser = getCurrentUser()&#10;            if (currentUser?.refreshToken != null) {&#10;                val response = apiService.refreshToken(RefreshTokenRequest(currentUser.refreshToken))&#10;                if (response.isSuccessful) {&#10;                    val tokenResponse = response.body()!!&#10;                    userDao.updateAuthToken(currentUser.id, tokenResponse.token, System.currentTimeMillis())&#10;                    authInterceptor.setAuthToken(tokenResponse.token)&#10;                    Result.success(tokenResponse.token)&#10;                } else {&#10;                    Result.failure(Exception(&quot;Token refresh failed&quot;))&#10;                }&#10;            } else {&#10;                Result.failure(Exception(&quot;No refresh token available&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/viewmodels/BaseViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/viewmodels/BaseViewModel.kt" />
              <option name="updatedContent" value="package com.example.geogeusserclone.viewmodels&#10;&#10;import androidx.lifecycle.ViewModel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;&#10;abstract class BaseViewModel&lt;T&gt;(initialState: T) : ViewModel() {&#10;    &#10;    private val _state = MutableStateFlow(initialState)&#10;    val state: StateFlow&lt;T&gt; = _state.asStateFlow()&#10;&#10;    protected fun setState(newState: T) {&#10;        _state.value = newState&#10;    }&#10;&#10;    protected fun updateState(transform: (T) -&gt; T) {&#10;        _state.value = transform(_state.value)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>