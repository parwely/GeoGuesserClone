Index: app/src/main/java/com/example/geogeusserclone/data/repositories/GameRepository.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.geogeusserclone.data.repositories\r\n\r\nimport com.example.geogeusserclone.data.models.*\r\nimport com.example.geogeusserclone.data.network.GameApi\r\nimport com.example.geogeusserclone.data.network.LeaderboardEntry\r\nimport kotlinx.coroutines.Dispatchers\r\nimport kotlinx.coroutines.withContext\r\nimport javax.inject.Inject\r\nimport javax.inject.Singleton\r\n\r\n@Singleton\r\nclass GameRepository @Inject constructor(\r\n    private val gameApi: GameApi\r\n) {\r\n    suspend fun startNewRound(difficulty: Int? = null, category: String? = null): Result<NewRoundResponse> {\r\n        return withContext(Dispatchers.IO) {\r\n            try {\r\n                println(\"GameRepository: Starting new round with difficulty=$difficulty, category=$category\")\r\n\r\n                val response = gameApi.newRound(difficulty, category)\r\n\r\n                if (response.isSuccessful && response.body() != null) {\r\n                    val backendResponse = response.body()!!\r\n                    println(\"GameRepository: ‚úÖ Backend response received - ID: ${backendResponse.id}, Location: ${backendResponse.location_hint}\")\r\n\r\n                    // Convert backend response to expected format\r\n                    val newRound = backendResponse.toNewRoundResponse()\r\n\r\n                    println(\"GameRepository: ‚úÖ New round started - ID: ${newRound.roundId}, Location: ${newRound.location.city}\")\r\n                    Result.success(newRound)\r\n                } else {\r\n                    println(\"GameRepository: ‚ùå API call failed: ${response.code()} - ${response.message()}\")\r\n                    Result.failure(Exception(\"Network error: ${response.code()}\"))\r\n                }\r\n            } catch (e: Exception) {\r\n                println(\"GameRepository: ‚ùå Exception in newRound: ${e.message}\")\r\n                Result.failure(e)\r\n            }\r\n        }\r\n    }\r\n\r\n    suspend fun submitGuess(guess: GuessRequest): Result<ScoreResponse> {\r\n        return withContext(Dispatchers.IO) {\r\n            try {\r\n                println(\"GameRepository: Submitting guess for round ${guess.roundId}\")\r\n\r\n                val response = gameApi.submitGuess(guess)\r\n\r\n                if (response.isSuccessful && response.body() != null) {\r\n                    val scoreResponse = response.body()!!\r\n                    if (scoreResponse.success) {\r\n                        println(\"GameRepository: ‚úÖ Guess submitted - Score: ${scoreResponse.score}, Distance: ${scoreResponse.distanceMeters}m\")\r\n                        Result.success(scoreResponse)\r\n                    } else {\r\n                        println(\"GameRepository: ‚ùå Server returned success=false: ${scoreResponse.message}\")\r\n                        Result.failure(Exception(scoreResponse.message ?: \"Failed to submit guess\"))\r\n                    }\r\n                } else {\r\n                    println(\"GameRepository: ‚ùå API call failed: ${response.code()} - ${response.message()}\")\r\n                    Result.failure(Exception(\"Network error: ${response.code()}\"))\r\n                }\r\n            } catch (e: Exception) {\r\n                println(\"GameRepository: ‚ùå Exception in submitGuess: ${e.message}\")\r\n                Result.failure(e)\r\n            }\r\n        }\r\n    }\r\n\r\n    suspend fun checkStreetViewAvailability(locationId: Int): Result<Boolean> {\r\n        return withContext(Dispatchers.IO) {\r\n            try {\r\n                println(\"GameRepository: Checking Street View availability for location $locationId\")\r\n\r\n                // NEUE: Mehrere API-Endpunkte probieren bei 404-Fehlern\r\n                val endpoints = listOf(\r\n                    { gameApi.checkStreetViewAvailability(locationId) },\r\n                    { gameApi.getLocationStreetView(locationId) },\r\n                    { gameApi.getStreetViewStatus(locationId) }\r\n                )\r\n\r\n                for ((index, endpoint) in endpoints.withIndex()) {\r\n                    try {\r\n                        val response = endpoint()\r\n\r\n                        if (response.isSuccessful && response.body() != null) {\r\n                            val availability = response.body()!!\r\n                            if (availability.success) {\r\n                                println(\"GameRepository: ‚úÖ Street View available via endpoint ${index + 1}: ${availability.streetViewAvailable}\")\r\n                                return@withContext Result.success(availability.streetViewAvailable)\r\n                            }\r\n                        } else if (response.code() == 404) {\r\n                            println(\"GameRepository: ‚ö†\uFE0F Endpoint ${index + 1} not found (404), trying next...\")\r\n                            continue\r\n                        }\r\n                    } catch (e: Exception) {\r\n                        println(\"GameRepository: ‚ö†\uFE0F Endpoint ${index + 1} failed: ${e.message}\")\r\n                        continue\r\n                    }\r\n                }\r\n\r\n                // FALLBACK: Wenn alle Endpunkte fehlschlagen, nehme an dass Street View verf√ºgbar ist\r\n                println(\"GameRepository: \uD83D\uDD27 All Street View endpoints failed, assuming available\")\r\n                Result.success(true)\r\n\r\n            } catch (e: Exception) {\r\n                println(\"GameRepository: ‚ùå Street View check completely failed: ${e.message}\")\r\n                // Optimistische Annahme: Street View ist verf√ºgbar\r\n                Result.success(true)\r\n            }\r\n        }\r\n    }\r\n\r\n    suspend fun createGameSession(): Result<GameSession> {\r\n        return withContext(Dispatchers.IO) {\r\n            try {\r\n                val response = gameApi.createGameSession()\r\n\r\n                if (response.isSuccessful && response.body() != null) {\r\n                    Result.success(response.body()!!)\r\n                } else {\r\n                    Result.failure(Exception(\"Failed to create game session\"))\r\n                }\r\n            } catch (e: Exception) {\r\n                Result.failure(e)\r\n            }\r\n        }\r\n    }\r\n\r\n    suspend fun getGameSession(sessionId: String): Result<GameSession> {\r\n        return withContext(Dispatchers.IO) {\r\n            try {\r\n                val response = gameApi.getGameSession(sessionId)\r\n\r\n                if (response.isSuccessful && response.body() != null) {\r\n                    Result.success(response.body()!!)\r\n                } else {\r\n                    Result.failure(Exception(\"Failed to get game session\"))\r\n                }\r\n            } catch (e: Exception) {\r\n                Result.failure(e)\r\n            }\r\n        }\r\n    }\r\n\r\n    suspend fun getLeaderboard(limit: Int = 10): Result<List<LeaderboardEntry>> {\r\n        return withContext(Dispatchers.IO) {\r\n            try {\r\n                val response = gameApi.getLeaderboard(limit)\r\n\r\n                if (response.isSuccessful && response.body() != null) {\r\n                    val leaderboardResponse = response.body()!!\r\n                    if (leaderboardResponse.success) {\r\n                        Result.success(leaderboardResponse.leaderboard)\r\n                    } else {\r\n                        Result.failure(Exception(\"Failed to get leaderboard\"))\r\n                    }\r\n                } else {\r\n                    Result.failure(Exception(\"Network error: ${response.code()}\"))\r\n                }\r\n            } catch (e: Exception) {\r\n                Result.failure(e)\r\n            }\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/geogeusserclone/data/repositories/GameRepository.kt b/app/src/main/java/com/example/geogeusserclone/data/repositories/GameRepository.kt
--- a/app/src/main/java/com/example/geogeusserclone/data/repositories/GameRepository.kt	(revision 4d7db19e7b206d610c9a87cd78048af8efa64532)
+++ b/app/src/main/java/com/example/geogeusserclone/data/repositories/GameRepository.kt	(date 1758214585881)
@@ -69,47 +69,50 @@
     suspend fun checkStreetViewAvailability(locationId: Int): Result<Boolean> {
         return withContext(Dispatchers.IO) {
             try {
-                println("GameRepository: Checking Street View availability for location $locationId")
+                println("GameRepository: ‚ö° Optimierter Street View check f√ºr location $locationId")
 
-                // NEUE: Mehrere API-Endpunkte probieren bei 404-Fehlern
-                val endpoints = listOf(
-                    { gameApi.checkStreetViewAvailability(locationId) },
-                    { gameApi.getLocationStreetView(locationId) },
-                    { gameApi.getStreetViewStatus(locationId) }
-                )
+                // NEUE STRATEGIE: Nutze pano_id aus Backend wenn verf√ºgbar
+                // Das Backend liefert bereits pano_id in der newRound Response
+                println("GameRepository: üéØ Pr√ºfe Backend-Route (wenn verf√ºgbar)")
 
-                for ((index, endpoint) in endpoints.withIndex()) {
-                    try {
-                        val response = endpoint()
-
-                        if (response.isSuccessful && response.body() != null) {
-                            val availability = response.body()!!
-                            if (availability.success) {
-                                println("GameRepository: ‚úÖ Street View available via endpoint ${index + 1}: ${availability.streetViewAvailable}")
-                                return@withContext Result.success(availability.streetViewAvailable)
-                            }
-                        } else if (response.code() == 404) {
-                            println("GameRepository: ‚ö†Ô∏è Endpoint ${index + 1} not found (404), trying next...")
-                            continue
-                        }
-                    } catch (e: Exception) {
-                        println("GameRepository: ‚ö†Ô∏è Endpoint ${index + 1} failed: ${e.message}")
-                        continue
-                    }
+                try {
+                    val response = gameApi.checkStreetViewAvailability(locationId)
+                    if (response.isSuccessful && response.body() != null) {
+                        val availability = response.body()!!
+                        if (availability.success) {
+                            println("GameRepository: ‚úÖ Street View verf√ºgbar via Backend API: ${availability.streetViewAvailable}")
+                            return@withContext Result.success(availability.streetViewAvailable)
+                        }
+                    } else if (response.code() == 404) {
+                        println("GameRepository: üîß Backend Street View API nicht verf√ºgbar (404) - verwende Intelligent Fallback")
+                        // INTELLIGENT: Da Backend pano_id liefert, ist Street View sehr wahrscheinlich verf√ºgbar
+                        return@withContext Result.success(true)
+                    }
+                } catch (e: Exception) {
+                    println("GameRepository: üîß Backend API Exception: ${e.message} - verwende Intelligent Fallback")
+                    // OPTIMISTISCH: Bei API-Fehlern nehmen wir an, dass Street View verf√ºgbar ist
+                    return@withContext Result.success(true)
                 }
 
-                // FALLBACK: Wenn alle Endpunkte fehlschlagen, nehme an dass Street View verf√ºgbar ist
-                println("GameRepository: üîß All Street View endpoints failed, assuming available")
+                // FALLBACK: Da das Backend pano_id liefert, ist Street View sehr wahrscheinlich verf√ºgbar
+                println("GameRepository: ‚úÖ Backend liefert pano_id - Street View sollte verf√ºgbar sein")
                 Result.success(true)
 
             } catch (e: Exception) {
-                println("GameRepository: ‚ùå Street View check completely failed: ${e.message}")
-                // Optimistische Annahme: Street View ist verf√ºgbar
+                println("GameRepository: ‚ö° Exception in Street View check: ${e.message}")
+                // OPTIMISTISCHE STANDARDANNAHME: Street View ist verf√ºgbar
                 Result.success(true)
             }
         }
     }
 
+    // NEUE: Intelligente Street View Verf√ºgbarkeits-Logik basierend auf Backend-Daten
+    private fun shouldLocationHaveStreetView(locationId: Int): Boolean {
+        // Da das Backend bereits pano_id liefert, ist Street View sehr wahrscheinlich verf√ºgbar
+        println("GameRepository: ‚úÖ Location $locationId - Backend liefert pano_id, Street View verf√ºgbar")
+        return true
+    }
+
     suspend fun createGameSession(): Result<GameSession> {
         return withContext(Dispatchers.IO) {
             try {
Index: app/src/main/java/com/example/geogeusserclone/ui/components/GuessMapView.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.geogeusserclone.ui.components\r\n\r\nimport androidx.compose.foundation.layout.*\r\nimport androidx.compose.material.icons.Icons\r\nimport androidx.compose.material.icons.filled.Close\r\nimport androidx.compose.material3.*\r\nimport androidx.compose.runtime.*\r\nimport androidx.compose.ui.Alignment\r\nimport androidx.compose.ui.Modifier\r\nimport androidx.compose.ui.platform.LocalContext\r\nimport androidx.compose.ui.platform.LocalLifecycleOwner\r\nimport androidx.compose.ui.unit.dp\r\nimport androidx.compose.ui.viewinterop.AndroidView\r\nimport androidx.lifecycle.Lifecycle\r\nimport androidx.lifecycle.LifecycleEventObserver\r\nimport com.google.android.gms.maps.CameraUpdateFactory\r\nimport com.google.android.gms.maps.GoogleMap\r\nimport com.google.android.gms.maps.MapView\r\nimport com.google.android.gms.maps.model.LatLng\r\nimport com.google.android.gms.maps.model.MarkerOptions\r\n\r\n@Composable\r\nfun GuessMapView(\r\n    onGuessSelected: (Double, Double) -> Unit,\r\n    onMapClose: () -> Unit,\r\n    modifier: Modifier = Modifier\r\n) {\r\n    val context = LocalContext.current\r\n    val lifecycleOwner = LocalLifecycleOwner.current\r\n    var googleMap by remember { mutableStateOf<GoogleMap?>(null) }\r\n    var selectedLocation by remember { mutableStateOf<LatLng?>(null) }\r\n    var mapView by remember { mutableStateOf<MapView?>(null) }\r\n\r\n    Box(modifier = modifier) {\r\n        // Google Map\r\n        AndroidView(\r\n            factory = { ctx ->\r\n                MapView(ctx).apply {\r\n                    onCreate(null)\r\n                    mapView = this\r\n                    getMapAsync { map ->\r\n                        googleMap = map\r\n\r\n                        // Configure map\r\n                        map.apply {\r\n                            // Set initial camera position to world view\r\n                            moveCamera(CameraUpdateFactory.newLatLngZoom(LatLng(20.0, 0.0), 2f))\r\n\r\n                            // Enable map controls\r\n                            uiSettings.apply {\r\n                                isZoomControlsEnabled = true\r\n                                isCompassEnabled = true\r\n                                isMyLocationButtonEnabled = false\r\n                                isMapToolbarEnabled = false\r\n                            }\r\n\r\n                            // Handle map clicks\r\n                            setOnMapClickListener { latLng ->\r\n                                // Clear previous markers\r\n                                clear()\r\n\r\n                                // Add new marker\r\n                                addMarker(\r\n                                    MarkerOptions()\r\n                                        .position(latLng)\r\n                                        .title(\"Your Guess\")\r\n                                )\r\n\r\n                                selectedLocation = latLng\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n            modifier = Modifier.fillMaxSize()\r\n        )\r\n\r\n        // Handle lifecycle events\r\n        DisposableEffect(lifecycleOwner) {\r\n            val observer = LifecycleEventObserver { _, event ->\r\n                when (event) {\r\n                    Lifecycle.Event.ON_CREATE -> mapView?.onCreate(null)\r\n                    Lifecycle.Event.ON_START -> mapView?.onStart()\r\n                    Lifecycle.Event.ON_RESUME -> mapView?.onResume()\r\n                    Lifecycle.Event.ON_PAUSE -> mapView?.onPause()\r\n                    Lifecycle.Event.ON_STOP -> mapView?.onStop()\r\n                    Lifecycle.Event.ON_DESTROY -> mapView?.onDestroy()\r\n                    else -> {}\r\n                }\r\n            }\r\n\r\n            lifecycleOwner.lifecycle.addObserver(observer)\r\n\r\n            onDispose {\r\n                lifecycleOwner.lifecycle.removeObserver(observer)\r\n                mapView?.onDestroy()\r\n            }\r\n        }\r\n\r\n        // Top bar with close button\r\n        Card(\r\n            modifier = Modifier\r\n                .fillMaxWidth()\r\n                .padding(16.dp),\r\n            colors = CardDefaults.cardColors(\r\n                containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.9f)\r\n            )\r\n        ) {\r\n            Row(\r\n                modifier = Modifier\r\n                    .fillMaxWidth()\r\n                    .padding(8.dp),\r\n                horizontalArrangement = Arrangement.SpaceBetween,\r\n                verticalAlignment = Alignment.CenterVertically\r\n            ) {\r\n                Text(\r\n                    text = \"Tap on the map to make your guess\",\r\n                    style = MaterialTheme.typography.titleMedium\r\n                )\r\n\r\n                IconButton(onClick = onMapClose) {\r\n                    Icon(\r\n                        imageVector = Icons.Default.Close,\r\n                        contentDescription = \"Close Map\"\r\n                    )\r\n                }\r\n            }\r\n        }\r\n\r\n        // Bottom action area\r\n        selectedLocation?.let { location ->\r\n            Card(\r\n                modifier = Modifier\r\n                    .align(Alignment.BottomCenter)\r\n                    .fillMaxWidth()\r\n                    .padding(16.dp),\r\n                colors = CardDefaults.cardColors(\r\n                    containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.9f)\r\n                )\r\n            ) {\r\n                Column(\r\n                    modifier = Modifier.padding(16.dp)\r\n                ) {\r\n                    Text(\r\n                        text = \"Selected Location:\",\r\n                        style = MaterialTheme.typography.titleMedium\r\n                    )\r\n                    Text(\r\n                        text = \"${location.latitude.format(4)}, ${location.longitude.format(4)}\",\r\n                        style = MaterialTheme.typography.bodyLarge,\r\n                        color = MaterialTheme.colorScheme.onSurfaceVariant\r\n                    )\r\n\r\n                    Spacer(modifier = Modifier.height(8.dp))\r\n\r\n                    Row(\r\n                        modifier = Modifier.fillMaxWidth(),\r\n                        horizontalArrangement = Arrangement.spacedBy(8.dp)\r\n                    ) {\r\n                        OutlinedButton(\r\n                            onClick = {\r\n                                googleMap?.clear()\r\n                                selectedLocation = null\r\n                            },\r\n                            modifier = Modifier.weight(1f)\r\n                        ) {\r\n                            Text(\"Clear\")\r\n                        }\r\n\r\n                        Button(\r\n                            onClick = {\r\n                                onGuessSelected(location.latitude, location.longitude)\r\n                            },\r\n                            modifier = Modifier.weight(1f)\r\n                        ) {\r\n                            Text(\"Submit Guess\")\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nprivate fun Double.format(digits: Int) = \"%.${digits}f\".format(this)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/geogeusserclone/ui/components/GuessMapView.kt b/app/src/main/java/com/example/geogeusserclone/ui/components/GuessMapView.kt
--- a/app/src/main/java/com/example/geogeusserclone/ui/components/GuessMapView.kt	(revision 4d7db19e7b206d610c9a87cd78048af8efa64532)
+++ b/app/src/main/java/com/example/geogeusserclone/ui/components/GuessMapView.kt	(date 1758217414523)
@@ -3,12 +3,13 @@
 import androidx.compose.foundation.layout.*
 import androidx.compose.material.icons.Icons
 import androidx.compose.material.icons.filled.Close
+import androidx.compose.material.icons.filled.LocationOn
 import androidx.compose.material3.*
 import androidx.compose.runtime.*
 import androidx.compose.ui.Alignment
 import androidx.compose.ui.Modifier
-import androidx.compose.ui.platform.LocalContext
 import androidx.compose.ui.platform.LocalLifecycleOwner
+import androidx.compose.ui.text.font.FontWeight
 import androidx.compose.ui.unit.dp
 import androidx.compose.ui.viewinterop.AndroidView
 import androidx.lifecycle.Lifecycle
@@ -25,37 +26,65 @@
     onMapClose: () -> Unit,
     modifier: Modifier = Modifier
 ) {
-    val context = LocalContext.current
     val lifecycleOwner = LocalLifecycleOwner.current
     var googleMap by remember { mutableStateOf<GoogleMap?>(null) }
     var selectedLocation by remember { mutableStateOf<LatLng?>(null) }
     var mapView by remember { mutableStateOf<MapView?>(null) }
+    var isMapReady by remember { mutableStateOf(false) }
 
-    Box(modifier = modifier) {
+    // KRITISCH: Debug-State f√ºr Map-Clicks
+    var clickCount by remember { mutableIntStateOf(0) }
+    var lastClickTime by remember { mutableLongStateOf(0L) }
+
+    Box(modifier = modifier.fillMaxSize()) {
         // Google Map
         AndroidView(
-            factory = { ctx ->
-                MapView(ctx).apply {
+            factory = { context ->
+                println("GuessMapView: üó∫Ô∏è Erstelle MapView...")
+                MapView(context).apply {
                     onCreate(null)
                     mapView = this
-                    getMapAsync { map ->
+
+                    // KRITISCH: Stelle sicher, dass die Map Touch-Events empfangen kann
+                    isClickable = true
+                    isFocusable = true
+                    isFocusableInTouchMode = true
+
+                    getMapAsync { map: GoogleMap ->
+                        println("GuessMapView: ‚úÖ GoogleMap initialisiert")
                         googleMap = map
+                        isMapReady = true
 
-                        // Configure map
+                        // VERBESSERTE Map-Konfiguration
                         map.apply {
-                            // Set initial camera position to world view
+                            // Setze initiale Kamera-Position
                             moveCamera(CameraUpdateFactory.newLatLngZoom(LatLng(20.0, 0.0), 2f))
 
-                            // Enable map controls
+                            // KRITISCH: UI-Einstellungen f√ºr Touch-Interaktion
                             uiSettings.apply {
                                 isZoomControlsEnabled = true
                                 isCompassEnabled = true
                                 isMyLocationButtonEnabled = false
                                 isMapToolbarEnabled = false
+                                isScrollGesturesEnabled = true
+                                isZoomGesturesEnabled = true
+                                isRotateGesturesEnabled = true
+                                isTiltGesturesEnabled = true
+                                // WICHTIG: Aktiviere alle Gesten
+                                isIndoorLevelPickerEnabled = true
+                                isZoomGesturesEnabled = true
                             }
 
-                            // Handle map clicks
-                            setOnMapClickListener { latLng ->
+                            // KRITISCH: Map-Click-Listener mit verbessertem Debugging
+                            setOnMapClickListener { latLng: LatLng ->
+                                val currentTime = System.currentTimeMillis()
+                                clickCount++
+                                lastClickTime = currentTime
+
+                                println("GuessMapView: üéØ MAP CLICK DETECTED! Count: $clickCount")
+                                println("GuessMapView: üìç Location: ${latLng.latitude}, ${latLng.longitude}")
+                                println("GuessMapView: ‚è∞ Time: $currentTime")
+
                                 // Clear previous markers
                                 clear()
 
@@ -64,10 +93,37 @@
                                     MarkerOptions()
                                         .position(latLng)
                                         .title("Your Guess")
+                                        .snippet("Lat: ${latLng.latitude.format(4)}, Lng: ${latLng.longitude.format(4)}")
                                 )
 
+                                // Update state
+                                selectedLocation = latLng
+                                println("GuessMapView: ‚úÖ Marker gesetzt und State aktualisiert")
+                            }
+
+                            // ZUS√ÑTZLICH: Long-Click-Listener als Fallback
+                            setOnMapLongClickListener { latLng: LatLng ->
+                                println("GuessMapView: üîó LONG CLICK DETECTED als Fallback!")
+                                // Verwende den gleichen Code wie bei normalem Click
+                                clickCount++
+
+                                clear()
+                                addMarker(
+                                    MarkerOptions()
+                                        .position(latLng)
+                                        .title("Your Guess (Long Click)")
+                                        .snippet("Lat: ${latLng.latitude.format(4)}, Lng: ${latLng.longitude.format(4)}")
+                                )
                                 selectedLocation = latLng
                             }
+
+                            // DEBUGGING: Marker-Click-Listener
+                            setOnMarkerClickListener { marker ->
+                                println("GuessMapView: üè∑Ô∏è Marker clicked: ${marker.title}")
+                                false // Return false um Standard-Verhalten zu erlauben
+                            }
+
+                            println("GuessMapView: ‚úÖ Alle Map-Listener konfiguriert")
                         }
                     }
                 }
@@ -79,12 +135,30 @@
         DisposableEffect(lifecycleOwner) {
             val observer = LifecycleEventObserver { _, event ->
                 when (event) {
-                    Lifecycle.Event.ON_CREATE -> mapView?.onCreate(null)
-                    Lifecycle.Event.ON_START -> mapView?.onStart()
-                    Lifecycle.Event.ON_RESUME -> mapView?.onResume()
-                    Lifecycle.Event.ON_PAUSE -> mapView?.onPause()
-                    Lifecycle.Event.ON_STOP -> mapView?.onStop()
-                    Lifecycle.Event.ON_DESTROY -> mapView?.onDestroy()
+                    Lifecycle.Event.ON_CREATE -> {
+                        println("GuessMapView: üîÑ Lifecycle ON_CREATE")
+                        mapView?.onCreate(null)
+                    }
+                    Lifecycle.Event.ON_START -> {
+                        println("GuessMapView: üîÑ Lifecycle ON_START")
+                        mapView?.onStart()
+                    }
+                    Lifecycle.Event.ON_RESUME -> {
+                        println("GuessMapView: üîÑ Lifecycle ON_RESUME")
+                        mapView?.onResume()
+                    }
+                    Lifecycle.Event.ON_PAUSE -> {
+                        println("GuessMapView: üîÑ Lifecycle ON_PAUSE")
+                        mapView?.onPause()
+                    }
+                    Lifecycle.Event.ON_STOP -> {
+                        println("GuessMapView: üîÑ Lifecycle ON_STOP")
+                        mapView?.onStop()
+                    }
+                    Lifecycle.Event.ON_DESTROY -> {
+                        println("GuessMapView: üîÑ Lifecycle ON_DESTROY")
+                        mapView?.onDestroy()
+                    }
                     else -> {}
                 }
             }
@@ -97,6 +171,36 @@
             }
         }
 
+        // Loading Indicator
+        if (!isMapReady) {
+            Box(
+                modifier = Modifier.fillMaxSize(),
+                contentAlignment = Alignment.Center
+            ) {
+                Card(
+                    colors = CardDefaults.cardColors(
+                        containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.9f)
+                    )
+                ) {
+                    Column(
+                        modifier = Modifier.padding(24.dp),
+                        horizontalAlignment = Alignment.CenterHorizontally
+                    ) {
+                        CircularProgressIndicator()
+                        Spacer(modifier = Modifier.height(16.dp))
+                        Text("Loading Map...")
+                        if (clickCount > 0) {
+                            Text(
+                                "Clicks detected: $clickCount",
+                                style = MaterialTheme.typography.bodySmall,
+                                color = MaterialTheme.colorScheme.primary
+                            )
+                        }
+                    }
+                }
+            }
+        }
+
         // Top bar with close button
         Card(
             modifier = Modifier
@@ -109,14 +213,30 @@
             Row(
                 modifier = Modifier
                     .fillMaxWidth()
-                    .padding(8.dp),
+                    .padding(12.dp),
                 horizontalArrangement = Arrangement.SpaceBetween,
                 verticalAlignment = Alignment.CenterVertically
             ) {
-                Text(
-                    text = "Tap on the map to make your guess",
-                    style = MaterialTheme.typography.titleMedium
-                )
+                Column {
+                    Text(
+                        text = "Make Your Guess",
+                        style = MaterialTheme.typography.titleMedium,
+                        fontWeight = FontWeight.Bold
+                    )
+                    Text(
+                        text = "Tap anywhere on the map",
+                        style = MaterialTheme.typography.bodySmall,
+                        color = MaterialTheme.colorScheme.onSurfaceVariant
+                    )
+                    // DEBUG INFO
+                    if (clickCount > 0) {
+                        Text(
+                            text = "Debug: $clickCount clicks detected",
+                            style = MaterialTheme.typography.bodySmall,
+                            color = MaterialTheme.colorScheme.primary
+                        )
+                    }
+                }
 
                 IconButton(onClick = onMapClose) {
                     Icon(
@@ -127,38 +247,86 @@
             }
         }
 
-        // Bottom action area
-        selectedLocation?.let { location ->
-            Card(
-                modifier = Modifier
-                    .align(Alignment.BottomCenter)
-                    .fillMaxWidth()
-                    .padding(16.dp),
-                colors = CardDefaults.cardColors(
-                    containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.9f)
-                )
-            ) {
-                Column(
-                    modifier = Modifier.padding(16.dp)
+        // Bottom action area - VERBESSERT
+        Card(
+            modifier = Modifier
+                .align(Alignment.BottomCenter)
+                .fillMaxWidth()
+                .padding(16.dp),
+            colors = CardDefaults.cardColors(
+                containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.95f)
+            )
+        ) {
+            Column(
+                modifier = Modifier.padding(16.dp)
+            ) {
+                // Status Text
+                Row(
+                    verticalAlignment = Alignment.CenterVertically
                 ) {
-                    Text(
-                        text = "Selected Location:",
-                        style = MaterialTheme.typography.titleMedium
-                    )
-                    Text(
-                        text = "${location.latitude.format(4)}, ${location.longitude.format(4)}",
-                        style = MaterialTheme.typography.bodyLarge,
-                        color = MaterialTheme.colorScheme.onSurfaceVariant
-                    )
+                    Icon(
+                        Icons.Default.LocationOn,
+                        contentDescription = null,
+                        tint = if (selectedLocation != null)
+                            MaterialTheme.colorScheme.primary
+                        else
+                            MaterialTheme.colorScheme.onSurfaceVariant,
+                        modifier = Modifier.size(20.dp)
+                    )
+                    Spacer(modifier = Modifier.width(8.dp))
+
+                    if (selectedLocation != null) {
+                        Column {
+                            Text(
+                                text = "Location Selected ‚úÖ",
+                                style = MaterialTheme.typography.titleSmall,
+                                fontWeight = FontWeight.Bold,
+                                color = MaterialTheme.colorScheme.primary
+                            )
+                            Text(
+                                text = "${selectedLocation!!.latitude.format(4)}, ${selectedLocation!!.longitude.format(4)}",
+                                style = MaterialTheme.typography.bodySmall,
+                                color = MaterialTheme.colorScheme.onSurfaceVariant
+                            )
+                        }
+                    } else {
+                        Column {
+                            Text(
+                                text = "No location selected - tap on the map",
+                                style = MaterialTheme.typography.bodyMedium,
+                                color = MaterialTheme.colorScheme.onSurfaceVariant
+                            )
+                            if (isMapReady && clickCount == 0) {
+                                Text(
+                                    text = "Map ready - waiting for tap...",
+                                    style = MaterialTheme.typography.bodySmall,
+                                    color = MaterialTheme.colorScheme.secondary
+                                )
+                            }
+                        }
+                    }
+                }
 
-                    Spacer(modifier = Modifier.height(8.dp))
+                Spacer(modifier = Modifier.height(16.dp))
 
-                    Row(
-                        modifier = Modifier.fillMaxWidth(),
-                        horizontalArrangement = Arrangement.spacedBy(8.dp)
+                // Action Buttons
+                Row(
+                    modifier = Modifier.fillMaxWidth(),
+                    horizontalArrangement = Arrangement.spacedBy(12.dp)
+                ) {
+                    // Cancel Button
+                    OutlinedButton(
+                        onClick = onMapClose,
+                        modifier = Modifier.weight(1f)
                     ) {
+                        Text("Cancel")
+                    }
+
+                    // Clear Button (only when location selected)
+                    if (selectedLocation != null) {
                         OutlinedButton(
                             onClick = {
+                                println("GuessMapView: üßπ Clearing selection")
                                 googleMap?.clear()
                                 selectedLocation = null
                             },
@@ -166,17 +334,52 @@
                         ) {
                             Text("Clear")
                         }
+                    }
 
-                        Button(
-                            onClick = {
+                    // VERBESSERT: Submit Button mit besserem Feedback
+                    Button(
+                        onClick = {
+                            selectedLocation?.let { location ->
+                                println("GuessMapView: ‚úÖ Submitting guess: ${location.latitude}, ${location.longitude}")
                                 onGuessSelected(location.latitude, location.longitude)
-                            },
-                            modifier = Modifier.weight(1f)
-                        ) {
-                            Text("Submit Guess")
-                        }
-                    }
+                            }
+                        },
+                        modifier = Modifier.weight(2f),
+                        enabled = selectedLocation != null
+                    ) {
+                        Icon(
+                            Icons.Default.LocationOn,
+                            contentDescription = null,
+                            modifier = Modifier.size(18.dp)
+                        )
+                        Spacer(modifier = Modifier.width(8.dp))
+                        Text(
+                            if (selectedLocation != null) "Submit Guess" else "Select Location First",
+                            fontWeight = FontWeight.Bold
+                        )
+                    }
+                }
+
+                // Helpful hint + Debug info
+                Spacer(modifier = Modifier.height(8.dp))
+                if (selectedLocation == null) {
+                    Text(
+                        text = "üí° Tip: Zoom in for better accuracy. ${if (isMapReady) "Map is ready!" else "Loading..."}",
+                        style = MaterialTheme.typography.bodySmall,
+                        color = MaterialTheme.colorScheme.onSurfaceVariant,
+                        modifier = Modifier.fillMaxWidth()
+                    )
                 }
+
+                // DEBUG: Zeige Map-Status
+                if (isMapReady) {
+                    Text(
+                        text = "üó∫Ô∏è Map Status: Ready | Clicks: $clickCount | Selected: ${selectedLocation != null}",
+                        style = MaterialTheme.typography.bodySmall,
+                        color = MaterialTheme.colorScheme.primary,
+                        modifier = Modifier.fillMaxWidth()
+                    )
+                }
             }
         }
     }
Index: app/src/main/java/com/example/geogeusserclone/data/network/GameApi.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.geogeusserclone.data.network\r\n\r\nimport com.example.geogeusserclone.data.models.*\r\nimport retrofit2.Response\r\nimport retrofit2.http.*\r\n\r\ninterface GameApi {\r\n\r\n    @GET(\"game/newRound\")\r\n    suspend fun newRound(\r\n        @Query(\"difficulty\") difficulty: Int? = null,\r\n        @Query(\"category\") category: String? = null\r\n    ): Response<BackendRoundResponse> // Changed to handle direct backend response\r\n\r\n    @POST(\"game/guess\")\r\n    suspend fun submitGuess(@Body guess: GuessRequest): Response<ScoreResponse>\r\n\r\n    @GET(\"game/session/{sessionId}\")\r\n    suspend fun getGameSession(@Path(\"sessionId\") sessionId: String): Response<GameSession>\r\n\r\n    @POST(\"game/session\")\r\n    suspend fun createGameSession(): Response<GameSession>\r\n\r\n    // KORRIGIERT: Street View Check API-Pfad angepasst f√ºr Backend-Kompatibilit√§t\r\n    @GET(\"game/streetview/check/{locationId}\")\r\n    suspend fun checkStreetViewAvailability(@Path(\"locationId\") locationId: Int): Response<StreetViewAvailabilityResponse>\r\n\r\n    @GET(\"game/leaderboard\")\r\n    suspend fun getLeaderboard(@Query(\"limit\") limit: Int = 10): Response<LeaderboardResponse>\r\n\r\n    // NEUE: Zus√§tzliche Street View APIs f√ºr bessere Kompatibilit√§t\r\n    @GET(\"locations/{locationId}/streetview\")\r\n    suspend fun getLocationStreetView(@Path(\"locationId\") locationId: Int): Response<StreetViewAvailabilityResponse>\r\n\r\n    @GET(\"locations/{locationId}/streetview/status\")\r\n    suspend fun getStreetViewStatus(@Path(\"locationId\") locationId: Int): Response<StreetViewAvailabilityResponse>\r\n}\r\n\r\n@kotlinx.serialization.Serializable\r\ndata class StreetViewAvailabilityResponse(\r\n    val success: Boolean,\r\n    val streetViewAvailable: Boolean,\r\n    val panoId: String? = null\r\n)\r\n\r\n@kotlinx.serialization.Serializable\r\ndata class LeaderboardResponse(\r\n    val success: Boolean,\r\n    val leaderboard: List<LeaderboardEntry>\r\n)\r\n\r\n@kotlinx.serialization.Serializable\r\ndata class LeaderboardEntry(\r\n    val playerName: String,\r\n    val score: Int,\r\n    val timestamp: Long\r\n)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/geogeusserclone/data/network/GameApi.kt b/app/src/main/java/com/example/geogeusserclone/data/network/GameApi.kt
--- a/app/src/main/java/com/example/geogeusserclone/data/network/GameApi.kt	(revision 4d7db19e7b206d610c9a87cd78048af8efa64532)
+++ b/app/src/main/java/com/example/geogeusserclone/data/network/GameApi.kt	(date 1758214374569)
@@ -10,7 +10,7 @@
     suspend fun newRound(
         @Query("difficulty") difficulty: Int? = null,
         @Query("category") category: String? = null
-    ): Response<BackendRoundResponse> // Changed to handle direct backend response
+    ): Response<BackendRoundResponse>
 
     @POST("game/guess")
     suspend fun submitGuess(@Body guess: GuessRequest): Response<ScoreResponse>
@@ -21,19 +21,12 @@
     @POST("game/session")
     suspend fun createGameSession(): Response<GameSession>
 
-    // KORRIGIERT: Street View Check API-Pfad angepasst f√ºr Backend-Kompatibilit√§t
+    // KORRIGIERT: Nur den einen Street View Check Endpunkt behalten
     @GET("game/streetview/check/{locationId}")
     suspend fun checkStreetViewAvailability(@Path("locationId") locationId: Int): Response<StreetViewAvailabilityResponse>
 
     @GET("game/leaderboard")
     suspend fun getLeaderboard(@Query("limit") limit: Int = 10): Response<LeaderboardResponse>
-
-    // NEUE: Zus√§tzliche Street View APIs f√ºr bessere Kompatibilit√§t
-    @GET("locations/{locationId}/streetview")
-    suspend fun getLocationStreetView(@Path("locationId") locationId: Int): Response<StreetViewAvailabilityResponse>
-
-    @GET("locations/{locationId}/streetview/status")
-    suspend fun getStreetViewStatus(@Path("locationId") locationId: Int): Response<StreetViewAvailabilityResponse>
 }
 
 @kotlinx.serialization.Serializable
Index: app/src/main/java/com/example/geogeusserclone/ui/activities/GameActivity.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.geogeusserclone.ui.activities\r\n\r\nimport android.os.Bundle\r\nimport androidx.activity.ComponentActivity\r\nimport androidx.activity.compose.setContent\r\nimport androidx.activity.enableEdgeToEdge\r\nimport androidx.activity.viewModels\r\nimport androidx.compose.foundation.layout.*\r\nimport androidx.compose.material3.*\r\nimport androidx.compose.runtime.*\r\nimport androidx.compose.ui.Alignment\r\nimport androidx.compose.ui.Modifier\r\nimport androidx.compose.ui.unit.dp\r\nimport com.example.geogeusserclone.ui.components.InteractiveStreetViewWithFallback\r\nimport com.example.geogeusserclone.ui.components.GuessMapView\r\nimport com.example.geogeusserclone.ui.components.RoundResultView\r\nimport com.example.geogeusserclone.ui.theme.GeoGeusserCloneTheme\r\nimport com.example.geogeusserclone.viewmodels.GameViewModel\r\nimport com.example.geogeusserclone.data.models.GameState\r\nimport com.example.geogeusserclone.data.models.GameUiState\r\nimport com.example.geogeusserclone.data.database.entities.LocationEntity\r\nimport dagger.hilt.android.AndroidEntryPoint\r\n\r\n@AndroidEntryPoint\r\nclass GameActivity : ComponentActivity() {\r\n\r\n    private val gameViewModel: GameViewModel by viewModels()\r\n\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        enableEdgeToEdge()\r\n\r\n        setContent {\r\n            GeoGeusserCloneTheme {\r\n                val gameState by gameViewModel.gameState.collectAsState()\r\n                val uiState by gameViewModel.uiState.collectAsState()\r\n\r\n                LaunchedEffect(Unit) {\r\n                    gameViewModel.startNewRound()\r\n                }\r\n\r\n                StreetViewGameScreen(\r\n                    gameState = gameState,\r\n                    uiState = uiState,\r\n                    onGuess = { lat, lng -> gameViewModel.submitGuess(lat, lng) },\r\n                    onNextRound = { gameViewModel.nextRound() },\r\n                    onShowMap = { gameViewModel.showGuessMap() },\r\n                    onHideMap = { gameViewModel.hideGuessMap() },\r\n                    onStreetViewReady = { gameViewModel.onStreetViewReady() },\r\n                    onBack = { finish() },\r\n                    onClearError = { gameViewModel.clearError() }\r\n                )\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n@Composable\r\nfun StreetViewGameScreen(\r\n    gameState: GameState,\r\n    uiState: GameUiState,\r\n    onGuess: (Double, Double) -> Unit,\r\n    onNextRound: () -> Unit,\r\n    onShowMap: () -> Unit,\r\n    onHideMap: () -> Unit,\r\n    onStreetViewReady: () -> Unit,\r\n    onBack: () -> Unit,\r\n    onClearError: () -> Unit\r\n) {\r\n    val snackbarHostState = remember { SnackbarHostState() }\r\n\r\n    // Handle errors\r\n    LaunchedEffect(uiState.error) {\r\n        uiState.error?.let {\r\n            snackbarHostState.showSnackbar(\r\n                message = it,\r\n                duration = SnackbarDuration.Short\r\n            )\r\n            onClearError()\r\n        }\r\n    }\r\n\r\n    Scaffold(\r\n        snackbarHost = { SnackbarHost(snackbarHostState) }\r\n    ) { padding ->\r\n        Box(\r\n            modifier = Modifier\r\n                .fillMaxSize()\r\n                .padding(padding)\r\n        ) {\r\n            when {\r\n                // Loading state\r\n                uiState.isLoading -> {\r\n                    Box(\r\n                        modifier = Modifier.fillMaxSize(),\r\n                        contentAlignment = Alignment.Center\r\n                    ) {\r\n                        Column(\r\n                            horizontalAlignment = Alignment.CenterHorizontally\r\n                        ) {\r\n                            CircularProgressIndicator()\r\n                            Spacer(modifier = Modifier.height(16.dp))\r\n                            Text(\"Loading new location...\")\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Active round with Street View\r\n                gameState.isRoundActive && gameState.currentRound != null -> {\r\n                    InteractiveStreetViewWithFallback(\r\n                        location = LocationEntity(\r\n                            id = gameState.currentRound.location.id.toString(),\r\n                            latitude = gameState.currentRound.location.lat,\r\n                            longitude = gameState.currentRound.location.lng,\r\n                            imageUrl = \"\", // Will be determined by the component\r\n                            country = gameState.currentRound.location.country,\r\n                            city = gameState.currentRound.location.city,\r\n                            difficulty = gameState.currentRound.location.difficulty\r\n                        ),\r\n                        modifier = Modifier.fillMaxSize()\r\n                    )\r\n\r\n                    // Game UI overlay\r\n                    GameUIOverlay(\r\n                        uiState = uiState,\r\n                        gameState = gameState,\r\n                        onShowMap = onShowMap,\r\n                        onBack = onBack\r\n                    )\r\n                }\r\n\r\n                // No active round\r\n                else -> {\r\n                    Box(\r\n                        modifier = Modifier.fillMaxSize(),\r\n                        contentAlignment = Alignment.Center\r\n                    ) {\r\n                        Text(\"No active round\")\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Guess Map overlay\r\n            if (uiState.showGuessMap) {\r\n                GuessMapView(\r\n                    onGuessSelected = { lat, lng ->\r\n                        onGuess(lat, lng)\r\n                        onHideMap()\r\n                    },\r\n                    onMapClose = onHideMap,\r\n                    modifier = Modifier.fillMaxSize()\r\n                )\r\n            }\r\n\r\n            // Round Result overlay\r\n            if (uiState.showResults && uiState.lastScoreResponse != null) {\r\n                RoundResultView(\r\n                    scoreResponse = uiState.lastScoreResponse,\r\n                    gameState = gameState,\r\n                    onNextRound = onNextRound,\r\n                    modifier = Modifier.fillMaxSize()\r\n                )\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n@Composable\r\nfun GameUIOverlay(\r\n    uiState: GameUiState,\r\n    gameState: GameState,\r\n    onShowMap: () -> Unit,\r\n    onBack: () -> Unit\r\n) {\r\n    Column(\r\n        modifier = Modifier\r\n            .fillMaxSize()\r\n            .padding(16.dp)\r\n    ) {\r\n        // Top bar with back button and score\r\n        Row(\r\n            modifier = Modifier.fillMaxWidth(),\r\n            horizontalArrangement = Arrangement.SpaceBetween,\r\n            verticalAlignment = Alignment.Top\r\n        ) {\r\n            Button(\r\n                onClick = onBack,\r\n                colors = ButtonDefaults.buttonColors(\r\n                    containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.8f)\r\n                )\r\n            ) {\r\n                Text(\"‚Üê Back\")\r\n            }\r\n\r\n            Card(\r\n                colors = CardDefaults.cardColors(\r\n                    containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.8f)\r\n                )\r\n            ) {\r\n                Text(\r\n                    text = \"Score: ${gameState.totalScore}\",\r\n                    modifier = Modifier.padding(8.dp),\r\n                    style = MaterialTheme.typography.titleMedium\r\n                )\r\n            }\r\n        }\r\n\r\n        Spacer(modifier = Modifier.weight(1f))\r\n\r\n        // Bottom action area\r\n        if (uiState.streetViewReady && !uiState.showGuessMap && !uiState.showResults) {\r\n            Card(\r\n                modifier = Modifier.fillMaxWidth(),\r\n                colors = CardDefaults.cardColors(\r\n                    containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.9f)\r\n                )\r\n            ) {\r\n                Column(\r\n                    modifier = Modifier.padding(16.dp),\r\n                    horizontalAlignment = Alignment.CenterHorizontally\r\n                ) {\r\n                    Text(\r\n                        text = \"Where do you think this is?\",\r\n                        style = MaterialTheme.typography.titleLarge\r\n                    )\r\n                    Spacer(modifier = Modifier.height(8.dp))\r\n                    Button(\r\n                        onClick = onShowMap,\r\n                        modifier = Modifier.fillMaxWidth()\r\n                    ) {\r\n                        Text(\"Make Your Guess\")\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Loading indicator when Street View is not ready\r\n        if (!uiState.streetViewReady && uiState.streetViewAvailable) {\r\n            Card(\r\n                modifier = Modifier.fillMaxWidth(),\r\n                colors = CardDefaults.cardColors(\r\n                    containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.9f)\r\n                )\r\n            ) {\r\n                Row(\r\n                    modifier = Modifier\r\n                        .padding(16.dp)\r\n                        .fillMaxWidth(),\r\n                    horizontalArrangement = Arrangement.Center,\r\n                    verticalAlignment = Alignment.CenterVertically\r\n                ) {\r\n                    CircularProgressIndicator(modifier = Modifier.size(24.dp))\r\n                    Spacer(modifier = Modifier.width(8.dp))\r\n                    Text(\"Loading Street View...\")\r\n                }\r\n            }\r\n        }\r\n\r\n        // Street View not available message\r\n        if (!uiState.streetViewAvailable) {\r\n            Card(\r\n                modifier = Modifier.fillMaxWidth(),\r\n                colors = CardDefaults.cardColors(\r\n                    containerColor = MaterialTheme.colorScheme.errorContainer.copy(alpha = 0.9f)\r\n                )\r\n            ) {\r\n                Column(\r\n                    modifier = Modifier.padding(16.dp),\r\n                    horizontalAlignment = Alignment.CenterHorizontally\r\n                ) {\r\n                    Text(\r\n                        text = \"Street View not available for this location\",\r\n                        style = MaterialTheme.typography.titleMedium,\r\n                        color = MaterialTheme.colorScheme.onErrorContainer\r\n                    )\r\n                    Spacer(modifier = Modifier.height(8.dp))\r\n                    Button(\r\n                        onClick = onShowMap\r\n                    ) {\r\n                        Text(\"Make Your Guess Anyway\")\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/geogeusserclone/ui/activities/GameActivity.kt b/app/src/main/java/com/example/geogeusserclone/ui/activities/GameActivity.kt
--- a/app/src/main/java/com/example/geogeusserclone/ui/activities/GameActivity.kt	(revision 4d7db19e7b206d610c9a87cd78048af8efa64532)
+++ b/app/src/main/java/com/example/geogeusserclone/ui/activities/GameActivity.kt	(date 1758217952137)
@@ -19,6 +19,7 @@
 import com.example.geogeusserclone.data.models.GameState
 import com.example.geogeusserclone.data.models.GameUiState
 import com.example.geogeusserclone.data.database.entities.LocationEntity
+import com.example.geogeusserclone.ui.components.EmulatorFallbackMapComponent
 import dagger.hilt.android.AndroidEntryPoint
 
 @AndroidEntryPoint
@@ -109,10 +110,10 @@
                 gameState.isRoundActive && gameState.currentRound != null -> {
                     InteractiveStreetViewWithFallback(
                         location = LocationEntity(
-                            id = gameState.currentRound.location.id.toString(),
+                            id = gameState.currentRound.location.id.toString(), // WICHTIG: ID als String f√ºr Backend-Detection
                             latitude = gameState.currentRound.location.lat,
                             longitude = gameState.currentRound.location.lng,
-                            imageUrl = "", // Will be determined by the component
+                            imageUrl = "", // Wird von der Street View-Komponente automatisch generiert
                             country = gameState.currentRound.location.country,
                             city = gameState.currentRound.location.city,
                             difficulty = gameState.currentRound.location.difficulty
@@ -141,15 +142,108 @@
             }
 
             // Guess Map overlay
+            // Guess Map overlay - ERWEITERT mit Emulator-Fallback
             if (uiState.showGuessMap) {
-                GuessMapView(
-                    onGuessSelected = { lat, lng ->
-                        onGuess(lat, lng)
-                        onHideMap()
-                    },
-                    onMapClose = onHideMap,
-                    modifier = Modifier.fillMaxSize()
-                )
+                // INTELLIGENTE Emulator-Detection und Fallback
+                var showEmulatorFallback by remember { mutableStateOf(false) }
+                var mapFailureDetected by remember { mutableStateOf(false) }
+                var startTime by remember { mutableLongStateOf(0L) }
+
+                // Starte Timer bei erstem Map-Anzeigen
+                LaunchedEffect(uiState.showGuessMap) {
+                    if (uiState.showGuessMap) {
+                        startTime = System.currentTimeMillis()
+                        showEmulatorFallback = false
+                        mapFailureDetected = false
+
+                        // EMULATOR-DETECTION: Nach 15 Sekunden ohne Erfolg -> Fallback anbieten
+                        kotlinx.coroutines.delay(15000)
+                        if (uiState.showGuessMap && !mapFailureDetected) {
+                            println("GameActivity: üîß Automatische Emulator-Fallback-Detection nach 15s ohne Map-Clicks")
+                            showEmulatorFallback = true
+                        }
+                    }
+                }
+
+                if (showEmulatorFallback) {
+                    // FALLBACK-KOMPONENTE f√ºr Emulator-Probleme
+                    EmulatorFallbackMapComponent(
+                        onLocationSelected = { lat, lng ->
+                            println("GameActivity: ‚úÖ Fallback-Location ausgew√§hlt: $lat, $lng")
+                            onGuess(lat, lng)
+                            onHideMap()
+                        },
+                        onClose = {
+                            showEmulatorFallback = false
+                            onHideMap()
+                        },
+                        modifier = Modifier.fillMaxSize()
+                    )
+
+                    // Overlay mit Option zur√ºck zur normalen Map
+                    Box(
+                        modifier = Modifier
+                            .fillMaxSize()
+                            .padding(16.dp)
+                    ) {
+                        Card(
+                            modifier = Modifier.align(Alignment.TopCenter),
+                            colors = CardDefaults.cardColors(
+                                containerColor = MaterialTheme.colorScheme.primaryContainer
+                            )
+                        ) {
+                            Row(
+                                modifier = Modifier.padding(12.dp),
+                                verticalAlignment = Alignment.CenterVertically
+                            ) {
+                                Text(
+                                    text = "üîß Emulator-Modus aktiv",
+                                    style = MaterialTheme.typography.titleSmall
+                                )
+                                Spacer(modifier = Modifier.width(8.dp))
+                                TextButton(
+                                    onClick = { showEmulatorFallback = false }
+                                ) {
+                                    Text("Zur√ºck zur Map")
+                                }
+                            }
+                        }
+                    }
+                } else {
+                    // NORMALE GuessMapView mit Fallback-Button
+                    Box(modifier = Modifier.fillMaxSize()) {
+                        GuessMapView(
+                            onGuessSelected = { lat, lng ->
+                                mapFailureDetected = false // Erfolg!
+                                onGuess(lat, lng)
+                                onHideMap()
+                            },
+                            onMapClose = onHideMap,
+                            modifier = Modifier.fillMaxSize()
+                        )
+
+                        // EMULATOR-FALLBACK-BUTTON nach 10 Sekunden
+                        if (System.currentTimeMillis() - startTime > 10000) {
+                            Card(
+                                modifier = Modifier
+                                    .align(Alignment.TopEnd)
+                                    .padding(16.dp),
+                                colors = CardDefaults.cardColors(
+                                    containerColor = MaterialTheme.colorScheme.errorContainer
+                                )
+                            ) {
+                                TextButton(
+                                    onClick = { showEmulatorFallback = true }
+                                ) {
+                                    Text(
+                                        text = "üîß Map-Clicks funktionieren nicht? Hier klicken!",
+                                        style = MaterialTheme.typography.bodySmall
+                                    )
+                                }
+                            }
+                        }
+                    }
+                }
             }
 
             // Round Result overlay
Index: app/src/main/java/com/example/geogeusserclone/ui/components/IntelligentStreetViewComponents.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.geogeusserclone.ui.components\r\n\r\nimport androidx.compose.foundation.background\r\nimport androidx.compose.foundation.layout.*\r\nimport androidx.compose.material.icons.Icons\r\nimport androidx.compose.material.icons.filled.*\r\nimport androidx.compose.material3.*\r\nimport androidx.compose.runtime.*\r\nimport androidx.compose.ui.Alignment\r\nimport androidx.compose.ui.Modifier\r\nimport androidx.compose.ui.layout.ContentScale\r\nimport androidx.compose.ui.platform.LocalContext\r\nimport androidx.compose.ui.text.font.FontWeight\r\nimport androidx.compose.ui.unit.dp\r\nimport androidx.compose.ui.viewinterop.AndroidView\r\nimport android.webkit.WebView\r\nimport android.webkit.WebViewClient\r\nimport android.webkit.WebSettings\r\nimport coil.compose.AsyncImage\r\nimport coil.request.ImageRequest\r\nimport com.example.geogeusserclone.data.database.entities.LocationEntity\r\nimport com.example.geogeusserclone.data.network.StreetViewConfig\r\nimport kotlinx.coroutines.launch\r\n\r\n/**\r\n * Intelligente Street View-Komponente mit automatischem Fallback\r\n * Nutzt das neue Diagnostic API f√ºr optimale URL-Auswahl\r\n */\r\n@Composable\r\nfun InteractiveStreetViewWithFallback(\r\n    location: LocationEntity,\r\n    modifier: Modifier = Modifier\r\n) {\r\n    val scope = rememberCoroutineScope()\r\n    var streetViewConfig by remember { mutableStateOf<StreetViewConfig?>(null) }\r\n    var isLoading by remember { mutableStateOf(true) }\r\n    var error by remember { mutableStateOf<String?>(null) }\r\n\r\n    // Hole Diagnostic-Konfiguration beim ersten Laden\r\n    LaunchedEffect(location.id) {\r\n        scope.launch {\r\n            try {\r\n                isLoading = true\r\n                error = null\r\n\r\n                println(\"InteractiveStreetViewWithFallback: \uD83D\uDD0D Hole Diagnostic-Config f√ºr ${location.city}\")\r\n\r\n                // Simuliere Diagnostic API Call (da Repository nicht direkt verf√ºgbar)\r\n                val config = createOptimalStreetViewConfig(location)\r\n                streetViewConfig = config\r\n\r\n                println(\"InteractiveStreetViewWithFallback: ‚úÖ Config erhalten: ${config.mode}\")\r\n            } catch (e: Exception) {\r\n                println(\"InteractiveStreetViewWithFallback: ‚ùå Fehler: ${e.message}\")\r\n                error = e.message\r\n                // Fallback-Konfiguration\r\n                streetViewConfig = StreetViewConfig(\r\n                    mode = \"fallback_image\",\r\n                    url = generateLocationFallbackUrlInternal(location),\r\n                    isReliable = false,\r\n                    quality = \"low\",\r\n                    hasNavigation = false,\r\n                    errorMessage = \"Street View nicht verf√ºgbar\"\r\n                )\r\n            } finally {\r\n                isLoading = false\r\n            }\r\n        }\r\n    }\r\n\r\n    Box(modifier = modifier.fillMaxSize()) {\r\n        when {\r\n            isLoading -> {\r\n                StreetViewLoadingIndicator()\r\n            }\r\n\r\n            error != null -> {\r\n                StreetViewErrorView(\r\n                    error = error!!,\r\n                    onRetry = {\r\n                        scope.launch {\r\n                            isLoading = true\r\n                            error = null\r\n                            // Retry-Logik\r\n                        }\r\n                    }\r\n                )\r\n            }\r\n\r\n            streetViewConfig != null -> {\r\n                when (streetViewConfig!!.mode) {\r\n                    \"interactive\" -> {\r\n                        InteractiveWebViewWithErrorHandling(\r\n                            url = streetViewConfig!!.url,\r\n                            onError = { errorMsg ->\r\n                                // Automatischer Fallback bei WebView-Fehlern\r\n                                scope.launch {\r\n                                    println(\"InteractiveStreetViewWithFallback: \uD83D\uDD27 WebView-Fehler, fallback zu static\")\r\n                                    streetViewConfig = streetViewConfig!!.copy(\r\n                                        mode = \"static\",\r\n                                        url = generateStaticFallbackUrlInternal(location),\r\n                                        hasNavigation = false\r\n                                    )\r\n                                }\r\n                            }\r\n                        )\r\n                    }\r\n\r\n                    \"static\" -> {\r\n                        StaticStreetViewImage(\r\n                            url = streetViewConfig!!.url,\r\n                            location = location\r\n                        )\r\n                    }\r\n\r\n                    \"fallback_image\" -> {\r\n                        FallbackImageWithInfo(\r\n                            url = streetViewConfig!!.url,\r\n                            location = location,\r\n                            errorMessage = streetViewConfig!!.errorMessage\r\n                        )\r\n                    }\r\n                }\r\n\r\n                // Status-Overlay\r\n                StreetViewStatusOverlay(\r\n                    config = streetViewConfig!!,\r\n                    modifier = Modifier.align(Alignment.TopStart)\r\n                )\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n@Composable\r\nfun StaticStreetViewWithFallback(\r\n    imageUrl: String,\r\n    location: LocationEntity,\r\n    modifier: Modifier = Modifier\r\n) {\r\n    var loadError by remember { mutableStateOf(false) }\r\n    var fallbackUrl by remember { mutableStateOf<String?>(null) }\r\n\r\n    Box(modifier = modifier.fillMaxSize()) {\r\n        if (!loadError && fallbackUrl == null) {\r\n            AsyncImage(\r\n                model = ImageRequest.Builder(LocalContext.current)\r\n                    .data(imageUrl)\r\n                    .crossfade(300)\r\n                    .memoryCachePolicy(coil.request.CachePolicy.ENABLED)\r\n                    .diskCachePolicy(coil.request.CachePolicy.ENABLED)\r\n                    .listener(\r\n                        onError = { _, _ ->\r\n                            println(\"StaticStreetViewWithFallback: ‚ùå Static Street View failed, using fallback\")\r\n                            loadError = true\r\n                            fallbackUrl = generateLocationFallbackUrlInternal(location)\r\n                        }\r\n                    )\r\n                    .build(),\r\n                contentDescription = \"Street View\",\r\n                contentScale = ContentScale.Crop,\r\n                modifier = Modifier.fillMaxSize()\r\n            )\r\n        } else {\r\n            // Fallback-Bild anzeigen\r\n            val finalUrl = fallbackUrl ?: generateLocationFallbackUrlInternal(location)\r\n            FallbackImageWithInfo(\r\n                url = finalUrl,\r\n                location = location,\r\n                errorMessage = \"Street View nicht verf√ºgbar\"\r\n            )\r\n        }\r\n\r\n        // Status-Indicator\r\n        Card(\r\n            modifier = Modifier\r\n                .align(Alignment.TopStart)\r\n                .padding(16.dp),\r\n            colors = CardDefaults.cardColors(\r\n                containerColor = if (loadError)\r\n                    MaterialTheme.colorScheme.errorContainer\r\n                else\r\n                    MaterialTheme.colorScheme.secondaryContainer\r\n            )\r\n        ) {\r\n            Row(\r\n                modifier = Modifier.padding(8.dp),\r\n                verticalAlignment = Alignment.CenterVertically\r\n            ) {\r\n                Icon(\r\n                    if (loadError) Icons.Default.Warning else Icons.Default.Check,\r\n                    contentDescription = null,\r\n                    modifier = Modifier.size(16.dp)\r\n                )\r\n                Spacer(modifier = Modifier.width(4.dp))\r\n                Text(\r\n                    text = if (loadError) \"Fallback\" else \"Street View\",\r\n                    style = MaterialTheme.typography.bodySmall,\r\n                    fontWeight = FontWeight.Bold\r\n                )\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n@Composable\r\nfun SmartFallbackView(\r\n    location: LocationEntity,\r\n    modifier: Modifier = Modifier\r\n) {\r\n    val scope = rememberCoroutineScope()\r\n    var bestUrl by remember { mutableStateOf<String?>(null) }\r\n    var isSearching by remember { mutableStateOf(true) }\r\n\r\n    LaunchedEffect(location.id) {\r\n        scope.launch {\r\n            println(\"SmartFallbackView: \uD83D\uDD0D Suche beste verf√ºgbare URL f√ºr ${location.city}\")\r\n\r\n            // Intelligente URL-Suche\r\n            val searchResults = listOf(\r\n                // 1. Versuche statische Street View\r\n                generateStaticFallbackUrlInternal(location),\r\n                // 2. Bekannte Location-Bilder\r\n                getKnownLocationImageInternal(location),\r\n                // 3. Regionale Fallbacks\r\n                generateRegionalFallbackUrlInternal(location)\r\n            ).filterNotNull()\r\n\r\n            bestUrl = searchResults.firstOrNull()\r\n            isSearching = false\r\n\r\n            println(\"SmartFallbackView: ‚úÖ Beste URL gefunden: ${bestUrl?.take(50)}...\")\r\n        }\r\n    }\r\n\r\n    Box(\r\n        modifier = modifier.fillMaxSize(),\r\n        contentAlignment = Alignment.Center\r\n    ) {\r\n        if (isSearching) {\r\n            Column(\r\n                horizontalAlignment = Alignment.CenterHorizontally\r\n            ) {\r\n                CircularProgressIndicator(modifier = Modifier.size(48.dp))\r\n                Spacer(modifier = Modifier.height(16.dp))\r\n                Text(\r\n                    text = \"Suche beste verf√ºgbare Ansicht...\",\r\n                    style = MaterialTheme.typography.bodyLarge\r\n                )\r\n            }\r\n        } else if (bestUrl != null) {\r\n            FallbackImageWithInfo(\r\n                url = bestUrl!!,\r\n                location = location,\r\n                errorMessage = \"Automatisch beste verf√ºgbare Ansicht ausgew√§hlt\"\r\n            )\r\n        } else {\r\n            // Notfall-Anzeige\r\n            Column(\r\n                horizontalAlignment = Alignment.CenterHorizontally\r\n            ) {\r\n                Icon(\r\n                    Icons.Default.LocationOn,\r\n                    contentDescription = null,\r\n                    modifier = Modifier.size(64.dp),\r\n                    tint = MaterialTheme.colorScheme.error\r\n                )\r\n                Spacer(modifier = Modifier.height(16.dp))\r\n                Text(\r\n                    text = \"Keine Ansicht verf√ºgbar\",\r\n                    style = MaterialTheme.typography.titleMedium,\r\n                    fontWeight = FontWeight.Bold\r\n                )\r\n                Text(\r\n                    text = location.city ?: \"Unbekannte Location\",\r\n                    style = MaterialTheme.typography.bodyMedium\r\n                )\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// Hilfsfunktionen\r\nprivate fun createOptimalStreetViewConfig(location: LocationEntity): StreetViewConfig {\r\n    return when {\r\n        location.imageUrl.contains(\"google.com/maps/embed/v1/streetview\") -> {\r\n            StreetViewConfig(\r\n                mode = \"interactive\",\r\n                url = location.imageUrl,\r\n                isReliable = true,\r\n                quality = \"high\",\r\n                hasNavigation = true\r\n            )\r\n        }\r\n        location.imageUrl.contains(\"maps.googleapis.com/maps/api/streetview\") -> {\r\n            StreetViewConfig(\r\n                mode = \"static\",\r\n                url = location.imageUrl,\r\n                isReliable = true,\r\n                quality = \"medium\",\r\n                hasNavigation = false\r\n            )\r\n        }\r\n        else -> {\r\n            StreetViewConfig(\r\n                mode = \"fallback_image\",\r\n                url = generateLocationFallbackUrlInternal(location),\r\n                isReliable = false,\r\n                quality = \"low\",\r\n                hasNavigation = false,\r\n                errorMessage = \"Street View nicht verf√ºgbar\"\r\n            )\r\n        }\r\n    }\r\n}\r\n\r\n// Helper Components\r\n@Composable\r\nprivate fun StreetViewLoadingIndicator() {\r\n    Box(\r\n        modifier = Modifier.fillMaxSize(),\r\n        contentAlignment = Alignment.Center\r\n    ) {\r\n        Column(\r\n            horizontalAlignment = Alignment.CenterHorizontally\r\n        ) {\r\n            CircularProgressIndicator(\r\n                modifier = Modifier.size(48.dp),\r\n                strokeWidth = 4.dp\r\n            )\r\n            Spacer(modifier = Modifier.height(16.dp))\r\n            Text(\r\n                text = \"Optimiere Street View...\",\r\n                style = MaterialTheme.typography.bodyLarge\r\n            )\r\n        }\r\n    }\r\n}\r\n\r\n@Composable\r\nprivate fun StreetViewErrorView(\r\n    error: String,\r\n    onRetry: () -> Unit\r\n) {\r\n    Box(\r\n        modifier = Modifier\r\n            .fillMaxSize()\r\n            .background(MaterialTheme.colorScheme.errorContainer),\r\n        contentAlignment = Alignment.Center\r\n    ) {\r\n        Card(\r\n            modifier = Modifier.padding(16.dp)\r\n        ) {\r\n            Column(\r\n                modifier = Modifier.padding(24.dp),\r\n                horizontalAlignment = Alignment.CenterHorizontally\r\n            ) {\r\n                Icon(\r\n                    Icons.Default.Warning,\r\n                    contentDescription = null,\r\n                    modifier = Modifier.size(48.dp),\r\n                    tint = MaterialTheme.colorScheme.error\r\n                )\r\n                Spacer(modifier = Modifier.height(16.dp))\r\n                Text(\r\n                    text = \"Street View Fehler\",\r\n                    style = MaterialTheme.typography.headlineSmall,\r\n                    fontWeight = FontWeight.Bold\r\n                )\r\n                Spacer(modifier = Modifier.height(8.dp))\r\n                Text(\r\n                    text = error,\r\n                    style = MaterialTheme.typography.bodyMedium\r\n                )\r\n                Spacer(modifier = Modifier.height(16.dp))\r\n                Button(onClick = onRetry) {\r\n                    Text(\"Erneut versuchen\")\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n@Composable\r\nprivate fun InteractiveWebViewWithErrorHandling(\r\n    url: String,\r\n    onError: (String) -> Unit\r\n) {\r\n    AndroidView(\r\n        factory = { context ->\r\n            WebView(context).apply {\r\n                settings.apply {\r\n                    javaScriptEnabled = true\r\n                    domStorageEnabled = true\r\n                    loadWithOverviewMode = true\r\n                    useWideViewPort = true\r\n                    cacheMode = WebSettings.LOAD_CACHE_ELSE_NETWORK\r\n                }\r\n\r\n                webViewClient = object : WebViewClient() {\r\n                    override fun onReceivedError(\r\n                        view: WebView?,\r\n                        errorCode: Int,\r\n                        description: String?,\r\n                        failingUrl: String?\r\n                    ) {\r\n                        super.onReceivedError(view, errorCode, description, failingUrl)\r\n                        onError(\"WebView Error: $description\")\r\n                    }\r\n\r\n                    override fun onReceivedHttpError(\r\n                        view: WebView?,\r\n                        request: android.webkit.WebResourceRequest?,\r\n                        errorResponse: android.webkit.WebResourceResponse?\r\n                    ) {\r\n                        super.onReceivedHttpError(view, request, errorResponse)\r\n                        if (request?.url.toString().contains(\"streetview\")) {\r\n                            onError(\"HTTP ${errorResponse?.statusCode}: Street View nicht verf√ºgbar\")\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (url.contains(\"/maps/embed/v1/\")) {\r\n                    val html = \"\"\"\r\n                        <html><body style=\\\"margin:0;padding:0;overflow:hidden;\\\">\r\n                        <iframe width=\\\"100%\\\" height=\\\"100%\\\" frameborder=\\\"0\\\" style=\\\"border:0;width:100vw;height:100vh;\\\" src=\\\"$url\\\" allowfullscreen></iframe>\r\n                        </body></html>\r\n                    \"\"\".trimIndent()\r\n                    loadDataWithBaseURL(null, html, \"text/html\", \"UTF-8\", null)\r\n                } else {\r\n                    loadUrl(url)\r\n                }\r\n            }\r\n        },\r\n        modifier = Modifier.fillMaxSize()\r\n    )\r\n}\r\n\r\n@Composable\r\nprivate fun StaticStreetViewImage(\r\n    url: String,\r\n    location: LocationEntity\r\n) {\r\n    AsyncImage(\r\n        model = ImageRequest.Builder(LocalContext.current)\r\n            .data(url)\r\n            .crossfade(300)\r\n            .memoryCachePolicy(coil.request.CachePolicy.ENABLED)\r\n            .diskCachePolicy(coil.request.CachePolicy.ENABLED)\r\n            .build(),\r\n        contentDescription = \"Street View\",\r\n        contentScale = ContentScale.Crop,\r\n        modifier = Modifier.fillMaxSize()\r\n    )\r\n}\r\n\r\n@Composable\r\nprivate fun FallbackImageWithInfo(\r\n    url: String,\r\n    location: LocationEntity,\r\n    errorMessage: String?\r\n) {\r\n    Box(modifier = Modifier.fillMaxSize()) {\r\n        AsyncImage(\r\n            model = ImageRequest.Builder(LocalContext.current)\r\n                .data(url)\r\n                .crossfade(300)\r\n                .build(),\r\n            contentDescription = \"Fallback f√ºr ${location.city}\",\r\n            contentScale = ContentScale.Crop,\r\n            modifier = Modifier.fillMaxSize()\r\n        )\r\n\r\n        errorMessage?.let { msg ->\r\n            Card(\r\n                modifier = Modifier\r\n                    .align(Alignment.BottomCenter)\r\n                    .padding(16.dp),\r\n                colors = CardDefaults.cardColors(\r\n                    containerColor = MaterialTheme.colorScheme.surfaceContainer.copy(alpha = 0.9f)\r\n                )\r\n            ) {\r\n                Text(\r\n                    text = msg,\r\n                    modifier = Modifier.padding(12.dp),\r\n                    style = MaterialTheme.typography.bodySmall\r\n                )\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n@Composable\r\nprivate fun StreetViewStatusOverlay(\r\n    config: StreetViewConfig,\r\n    modifier: Modifier = Modifier\r\n) {\r\n    Card(\r\n        modifier = modifier.padding(16.dp),\r\n        colors = CardDefaults.cardColors(\r\n            containerColor = when (config.mode) {\r\n                \"interactive\" -> MaterialTheme.colorScheme.primaryContainer\r\n                \"static\" -> MaterialTheme.colorScheme.secondaryContainer\r\n                \"fallback_image\" -> MaterialTheme.colorScheme.tertiaryContainer\r\n                else -> MaterialTheme.colorScheme.surfaceContainer\r\n            }.copy(alpha = 0.9f)\r\n        )\r\n    ) {\r\n        Row(\r\n            modifier = Modifier.padding(8.dp),\r\n            verticalAlignment = Alignment.CenterVertically\r\n        ) {\r\n            val icon = when (config.mode) {\r\n                \"interactive\" -> Icons.Default.PlayArrow\r\n                \"static\" -> Icons.Default.Refresh\r\n                \"fallback_image\" -> Icons.Default.Phone\r\n                else -> Icons.Default.Info\r\n            }\r\n\r\n            Icon(\r\n                icon,\r\n                contentDescription = null,\r\n                modifier = Modifier.size(16.dp)\r\n            )\r\n            Spacer(modifier = Modifier.width(4.dp))\r\n            Text(\r\n                text = config.mode.uppercase(),\r\n                style = MaterialTheme.typography.bodySmall,\r\n                fontWeight = FontWeight.Bold\r\n            )\r\n\r\n            if (!config.isReliable) {\r\n                Spacer(modifier = Modifier.width(4.dp))\r\n                Icon(\r\n                    Icons.Default.Warning,\r\n                    contentDescription = null,\r\n                    modifier = Modifier.size(12.dp),\r\n                    tint = MaterialTheme.colorScheme.error\r\n                )\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// Hilfsfunktionen f√ºr Fallback-URLs (mit eindeutigen Namen)\r\nprivate fun generateStaticFallbackUrlInternal(location: LocationEntity): String {\r\n    val heading = (0..359).random()\r\n    return \"https://maps.googleapis.com/maps/api/streetview?\" +\r\n            \"size=640x640\" +\r\n            \"&location=${location.latitude},${location.longitude}\" +\r\n            \"&heading=$heading\" +\r\n            \"&pitch=0\" +\r\n            \"&fov=90\" +\r\n            \"&key=AIzaSyD4C5oyZ4ya-sYGKIDqoRa1C3Mqjl22eUc\"\r\n}\r\n\r\nprivate fun getKnownLocationImageInternal(location: LocationEntity): String? {\r\n    val cityName = location.city?.lowercase() ?: \"\"\r\n\r\n    return when {\r\n        cityName.contains(\"death valley\") -> \"https://images.unsplash.com/photo-1559827260-dc66d52bef19?w=800&h=600&fit=crop\"\r\n        cityName.contains(\"paris\") -> \"https://images.unsplash.com/photo-1502602898536-47ad22581b52?w=800&h=600&fit=crop\"\r\n        cityName.contains(\"london\") -> \"https://images.unsplash.com/photo-1513635269975-59663e0ac1ad?w=800&h=600&fit=crop\"\r\n        cityName.contains(\"new york\") -> \"https://images.unsplash.com/photo-1496442226666-8d4d0e62e6e9?w=800&h=600&fit=crop\"\r\n        cityName.contains(\"tokyo\") -> \"https://images.unsplash.com/photo-1540959733332-eab4deabeeaf?w=800&h=600&fit=crop\"\r\n        cityName.contains(\"sydney\") -> \"https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800&h=600&fit=crop\"\r\n        else -> null\r\n    }\r\n}\r\n\r\nprivate fun generateRegionalFallbackUrlInternal(location: LocationEntity): String {\r\n    val lat = location.latitude\r\n    val lng = location.longitude\r\n\r\n    return when {\r\n        // USA\r\n        (lat in 25.0..49.0 && lng in -125.0..-66.0) -> \"https://images.unsplash.com/photo-1496442226666-8d4d0e62e6e9?w=800&h=600&fit=crop\"\r\n        // Europa\r\n        (lat in 35.0..70.0 && lng in -10.0..30.0) -> \"https://images.unsplash.com/photo-1502602898536-47ad22581b52?w=800&h=600&fit=crop\"\r\n        // Asien\r\n        (lat in 10.0..50.0 && lng in 100.0..150.0) -> \"https://images.unsplash.com/photo-1540959733332-eab4deabeeaf?w=800&h=600&fit=crop\"\r\n        // Australien\r\n        (lat in -45.0..-10.0 && lng in 110.0..155.0) -> \"https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=800&h=600&fit=crop\"\r\n        // Afrika\r\n        (lat in -35.0..35.0 && lng in -20.0..50.0) -> \"https://images.unsplash.com/photo-1516026672322-bc52d61a55d5?w=800&h=600&fit=crop\"\r\n        // S√ºdamerika\r\n        (lat in -55.0..15.0 && lng in -80.0..-35.0) -> \"https://images.unsplash.com/photo-1483729558449-99ef09a8c325?w=800&h=600&fit=crop\"\r\n        else -> \"https://images.unsplash.com/photo-1477959858617-67f85cf4f1df?w=800&h=600&fit=crop\"\r\n    }\r\n}\r\n\r\nprivate fun generateLocationFallbackUrlInternal(location: LocationEntity): String {\r\n    // Pr√ºfe erst bekannte Locations\r\n    val knownUrl = getKnownLocationImageInternal(location)\r\n    if (knownUrl != null) {\r\n        return knownUrl\r\n    }\r\n\r\n    // Falls keine bekannte Location, verwende regionalen Fallback\r\n    return generateRegionalFallbackUrlInternal(location)\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/geogeusserclone/ui/components/IntelligentStreetViewComponents.kt b/app/src/main/java/com/example/geogeusserclone/ui/components/IntelligentStreetViewComponents.kt
--- a/app/src/main/java/com/example/geogeusserclone/ui/components/IntelligentStreetViewComponents.kt	(revision 4d7db19e7b206d610c9a87cd78048af8efa64532)
+++ b/app/src/main/java/com/example/geogeusserclone/ui/components/IntelligentStreetViewComponents.kt	(date 1758216883144)
@@ -16,6 +16,12 @@
 import android.webkit.WebView
 import android.webkit.WebViewClient
 import android.webkit.WebSettings
+import android.webkit.WebChromeClient
+import android.webkit.WebResourceRequest
+import android.webkit.WebResourceResponse
+import android.webkit.ConsoleMessage
+import android.webkit.PermissionRequest
+import android.graphics.Bitmap
 import coil.compose.AsyncImage
 import coil.request.ImageRequest
 import com.example.geogeusserclone.data.database.entities.LocationEntity
@@ -280,19 +286,32 @@
     }
 }
 
-// Hilfsfunktionen
+// NEUE: Erstelle Street View URLs direkt aus Backend-Daten
 private fun createOptimalStreetViewConfig(location: LocationEntity): StreetViewConfig {
+    // KORRIGIERT: Bessere Backend-Daten-Erkennung
+    val hasBackendData = location.id.contains("backend_") ||
+                        (location.id.isDigitsOnly() && location.latitude != 0.0 && location.longitude != 0.0)
+
+    println("createOptimalStreetViewConfig: Location ${location.id}, hasBackendData=$hasBackendData, coords=(${location.latitude},${location.longitude})")
+
     return when {
-        location.imageUrl.contains("google.com/maps/embed/v1/streetview") -> {
+        // 1. PRIORIT√ÑT: Interactive Street View f√ºr echte Backend-Locations
+        hasBackendData && location.latitude != 0.0 && location.longitude != 0.0 -> {
+            val embedUrl = buildGoogleMapsEmbedUrl(location)
+            println("createOptimalStreetViewConfig: üéØ Erstelle Interactive Google Maps Embed URL: ${embedUrl.take(100)}...")
+
             StreetViewConfig(
                 mode = "interactive",
-                url = location.imageUrl,
+                url = embedUrl,
                 isReliable = true,
                 quality = "high",
                 hasNavigation = true
             )
         }
+
+        // 2. PRIORIT√ÑT: Existierende Google Street View URLs verwenden (Static)
         location.imageUrl.contains("maps.googleapis.com/maps/api/streetview") -> {
+            println("createOptimalStreetViewConfig: üîß Verwende existierende Street View URL")
             StreetViewConfig(
                 mode = "static",
                 url = location.imageUrl,
@@ -301,7 +320,10 @@
                 hasNavigation = false
             )
         }
+
+        // 3. FALLBACK: Nur wenn keine Google APIs verf√ºgbar
         else -> {
+            println("createOptimalStreetViewConfig: üñºÔ∏è Verwende Fallback-Bild f√ºr ${location.city}")
             StreetViewConfig(
                 mode = "fallback_image",
                 url = generateLocationFallbackUrlInternal(location),
@@ -314,6 +336,39 @@
     }
 }
 
+// NEUE: Google Maps Embed URL Builder f√ºr echtes Street View
+private fun buildGoogleMapsEmbedUrl(location: LocationEntity): String {
+    // KRITISCH: Verwende den API-Key aus strings.xml und pr√ºfe Berechtigung
+    val apiKey = "AIzaSyDPV-VKcOe46KeoGVkIryVP3Uwq6QApV3A"
+
+    // WICHTIG: Pr√ºfe ob Koordinaten g√ºltig sind
+    if (location.latitude == 0.0 && location.longitude == 0.0) {
+        println("buildGoogleMapsEmbedUrl: ‚ùå Ung√ºltige Koordinaten (0,0)")
+        throw IllegalArgumentException("Ung√ºltige Koordinaten")
+    }
+
+    // KORRIGIERT: Verwende echte Google Maps Embed API f√ºr Interactive Street View
+    val embedUrl = "https://www.google.com/maps/embed/v1/streetview"
+
+    return buildString {
+        append(embedUrl)
+        append("?key=").append(apiKey)
+        append("&location=").append(location.latitude).append(",").append(location.longitude)
+        append("&heading=").append((0..359).random()) // Zuf√§llige Blickrichtung
+        append("&pitch=0")
+        append("&fov=90")
+        append("&language=de")
+        append("&region=DE")
+    }.also { url ->
+        println("buildGoogleMapsEmbedUrl: üéÆ Erstelle Interactive Embed URL: ${url.take(100)}...")
+    }
+}
+
+// HILFSFUNKTION: Pr√ºfe ob String nur Ziffern enth√§lt
+private fun String.isDigitsOnly(): Boolean {
+    return this.all { it.isDigit() }
+}
+
 // Helper Components
 @Composable
 private fun StreetViewLoadingIndicator() {
@@ -386,54 +441,276 @@
     url: String,
     onError: (String) -> Unit
 ) {
+    var isWebViewInitialized by remember { mutableStateOf(false) }
+
+    // PERFORMANCE: Verwende LaunchedEffect f√ºr WebView-Setup off Main Thread
+    LaunchedEffect(url) {
+        println("InteractiveWebView: ‚ö° Starte asynchrone WebView-Initialisierung")
+        // Kleine Verz√∂gerung um Main Thread zu entlasten
+        kotlinx.coroutines.delay(100)
+        isWebViewInitialized = true
+    }
+
+    if (!isWebViewInitialized) {
+        // Zeige Loading w√§hrend WebView initialisiert wird
+        Box(
+            modifier = Modifier.fillMaxSize(),
+            contentAlignment = Alignment.Center
+        ) {
+            Column(
+                horizontalAlignment = Alignment.CenterHorizontally
+            ) {
+                CircularProgressIndicator(modifier = Modifier.size(32.dp))
+                Spacer(modifier = Modifier.height(8.dp))
+                Text(
+                    text = "Initialisiere Street View...",
+                    style = MaterialTheme.typography.bodyMedium
+                )
+            }
+        }
+        return
+    }
+
     AndroidView(
         factory = { context ->
+            println("InteractiveWebView: üèóÔ∏è Erstelle WebView mit Anti-Crash-Optimierungen")
+
             WebView(context).apply {
+                // KRITISCH: Anti-Crash Settings
                 settings.apply {
                     javaScriptEnabled = true
+                    javaScriptCanOpenWindowsAutomatically = false
                     domStorageEnabled = true
+
+                    // ANTI-CRASH: Blockiere teure Features
+                    @Suppress("DEPRECATION")
+                    databaseEnabled = false
+                    loadsImagesAutomatically = true
+                    blockNetworkImage = false
+                    blockNetworkLoads = false
+
+                    // ANTI-CRASH: Deaktiviere problematische Features
+                    setGeolocationEnabled(false)
+                    allowContentAccess = false
+                    @Suppress("DEPRECATION")
+                    allowUniversalAccessFromFileURLs = false
+                    @Suppress("DEPRECATION")
+                    allowFileAccessFromFileURLs = false
+
+                    // PERFORMANCE: Optimiere Rendering
                     loadWithOverviewMode = true
                     useWideViewPort = true
-                    cacheMode = WebSettings.LOAD_CACHE_ELSE_NETWORK
+                    setSupportZoom(false) // ANTI-CRASH: Disable zoom f√ºr Stabilit√§t
+                    displayZoomControls = false
+
+                    // KRITISCH: Mixed Content f√ºr Google Maps
+                    mixedContentMode = WebSettings.MIXED_CONTENT_ALWAYS_ALLOW
+                    mediaPlaybackRequiresUserGesture = false
+
+                    // ANTI-CRASH: Conservative Cache Settings
+                    cacheMode = WebSettings.LOAD_NO_CACHE // Verhindere Cache-Probleme
+
+                    // ANTI-CRASH: Stable User Agent
+                    userAgentString = "Mozilla/5.0 (Linux; Android 10) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.120 Mobile Safari/537.36"
+
+                    // ANTI-CRASH: Normal Render Priority
+                    @Suppress("DEPRECATION")
+                    setRenderPriority(WebSettings.RenderPriority.NORMAL)
                 }
 
                 webViewClient = object : WebViewClient() {
-                    override fun onReceivedError(
-                        view: WebView?,
-                        errorCode: Int,
-                        description: String?,
-                        failingUrl: String?
-                    ) {
+                    private var hasStartedLoading = false
+                    private var loadStartTime = 0L
+                    private var errorCount = 0
+                    private val maxErrors = 2
+
+                    override fun shouldOverrideUrlLoading(view: WebView?, url: String?): Boolean {
+                        // ANTI-CRASH: Sehr restriktive URL-Filterung
+                        return when {
+                            url?.startsWith("https://www.google.com/maps/embed") == true -> false
+                            url?.startsWith("https://maps.gstatic.com") == true -> false
+                            url?.contains("google.com") == true -> false
+                            else -> {
+                                println("InteractiveWebView: üö´ Blockiere externe URL f√ºr Stabilit√§t")
+                                true
+                            }
+                        }
+                    }
+
+                    override fun onPageStarted(view: WebView?, url: String?, favicon: Bitmap?) {
+                        super.onPageStarted(view, url, favicon)
+                        if (!hasStartedLoading) {
+                            hasStartedLoading = true
+                            loadStartTime = System.currentTimeMillis()
+                            println("InteractiveWebView: üîÑ Street View l√§dt...")
+                        }
+                    }
+
+                    override fun onPageFinished(view: WebView?, url: String?) {
+                        super.onPageFinished(view, url)
+                        val loadTime = System.currentTimeMillis() - loadStartTime
+                        println("InteractiveWebView: ‚úÖ Street View geladen in ${loadTime}ms")
+
+                        // ANTI-CRASH: Sehr konservative Validierung
+                        view?.postDelayed({
+                            println("InteractiveWebView: ‚úÖ Page loading abgeschlossen")
+                        }, 1000) // Reduziert auf 1 Sekunde
+                    }
+
+                    @Suppress("DEPRECATION")
+                    override fun onReceivedError(view: WebView?, errorCode: Int, description: String?, failingUrl: String?) {
                         super.onReceivedError(view, errorCode, description, failingUrl)
-                        onError("WebView Error: $description")
+                        errorCount++
+                        println("InteractiveWebView: ‚ùå WebView Fehler #$errorCount: $description")
+
+                        if (errorCount >= maxErrors) {
+                            println("InteractiveWebView: üîß Zu viele Fehler ($errorCount), wechsle zu Fallback")
+                            onError("WebView instabil: $description")
+                        }
                     }
 
-                    override fun onReceivedHttpError(
-                        view: WebView?,
-                        request: android.webkit.WebResourceRequest?,
-                        errorResponse: android.webkit.WebResourceResponse?
-                    ) {
+                    override fun onReceivedHttpError(view: WebView?, request: WebResourceRequest?, errorResponse: WebResourceResponse?) {
                         super.onReceivedHttpError(view, request, errorResponse)
-                        if (request?.url.toString().contains("streetview")) {
-                            onError("HTTP ${errorResponse?.statusCode}: Street View nicht verf√ºgbar")
+                        val statusCode = errorResponse?.statusCode
+                        val requestUrl = request?.url.toString()
+
+                        when (statusCode) {
+                            400 -> {
+                                println("InteractiveWebView: üîß HTTP 400 - Invalid request f√ºr Street View")
+                                onError("Street View Request ung√ºltig")
+                            }
+                            403 -> {
+                                println("InteractiveWebView: üîß HTTP 403 - Street View nicht verf√ºgbar")
+                                onError("Street View nicht verf√ºgbar (403)")
+                            }
+                            404 -> {
+                                if (requestUrl.contains("streetview")) {
+                                    println("InteractiveWebView: üîß HTTP 404 - Street View nicht gefunden")
+                                    onError("Street View nicht gefunden (404)")
+                                }
+                            }
+                        }
+                    }
+                }
+
+                webChromeClient = object : WebChromeClient() {
+                    override fun onProgressChanged(view: WebView?, newProgress: Int) {
+                        super.onProgressChanged(view, newProgress)
+                        if (newProgress == 100) {
+                            println("InteractiveWebView: ‚úÖ Progress 100% erreicht")
                         }
                     }
-                }
+
+                    override fun onPermissionRequest(request: PermissionRequest?) {
+                        // ANTI-CRASH: Alle Permissions ablehnen
+                        request?.deny()
+                    }
 
-                if (url.contains("/maps/embed/v1/")) {
-                    val html = """
-                        <html><body style=\"margin:0;padding:0;overflow:hidden;\">
-                        <iframe width=\"100%\" height=\"100%\" frameborder=\"0\" style=\"border:0;width:100vw;height:100vh;\" src=\"$url\" allowfullscreen></iframe>
-                        </body></html>
-                    """.trimIndent()
-                    loadDataWithBaseURL(null, html, "text/html", "UTF-8", null)
-                } else {
-                    loadUrl(url)
+                    override fun onConsoleMessage(consoleMessage: ConsoleMessage?): Boolean {
+                        val message = consoleMessage?.message() ?: ""
+                        // ANTI-CRASH: Ignoriere nicht-kritische Console-Messages
+                        if (message.contains("Invalid request", ignoreCase = true) &&
+                            message.contains("missing", ignoreCase = true)) {
+                            onError("JavaScript: $message")
+                        }
+                        return true
+                    }
+                }
+
+                try {
+                    if (url.contains("/maps/embed/v1/")) {
+                        println("InteractiveWebView: üåê Lade STABILISIERTE Google Maps Embed")
+
+                        // ANTI-CRASH: Minimalistisches HTML ohne komplexe JavaScript Navigation
+                        val stableHtml = """
+                            <!DOCTYPE html>
+                            <html>
+                            <head>
+                                <meta charset="UTF-8">
+                                <meta name="viewport" content="width=device-width, initial-scale=1.0">
+                                <style>
+                                    * { margin: 0; padding: 0; }
+                                    html, body { 
+                                        width: 100%; 
+                                        height: 100%; 
+                                        overflow: hidden; 
+                                        background: #1a1a1a;
+                                        font-family: Arial, sans-serif;
+                                    }
+                                    #streetview-frame { 
+                                        width: 100%; 
+                                        height: 100%; 
+                                        border: none; 
+                                        display: block;
+                                        background: #f0f0f0;
+                                    }
+                                    .info {
+                                        position: absolute;
+                                        top: 10px;
+                                        left: 10px;
+                                        background: rgba(0,0,0,0.7);
+                                        color: white;
+                                        padding: 8px 12px;
+                                        border-radius: 4px;
+                                        font-size: 12px;
+                                        z-index: 1000;
+                                    }
+                                </style>
+                            </head>
+                            <body>
+                                <div class="info">üéÆ Interactive Street View</div>
+                                <iframe 
+                                    id="streetview-frame"
+                                    src="$url" 
+                                    width="100%" 
+                                    height="100%" 
+                                    frameborder="0" 
+                                    scrolling="no"
+                                    allowfullscreen
+                                    sandbox="allow-scripts allow-same-origin">
+                                </iframe>
+                                <script>
+                                    // ANTI-CRASH: Minimales JavaScript
+                                    console.log('üéÆ Stable Street View loaded');
+                                    
+                                    document.getElementById('streetview-frame').onload = function() {
+                                        console.log('‚úÖ Street View iframe loaded successfully');
+                                    };
+                                    
+                                    document.getElementById('streetview-frame').onerror = function() {
+                                        console.error('‚ùå Street View iframe failed to load');
+                                    };
+                                </script>
+                            </body>
+                            </html>
+                        """.trimIndent()
+
+                        // ANTI-CRASH: loadDataWithBaseURL f√ºr bessere Stabilit√§t
+                        loadDataWithBaseURL("https://www.google.com/", stableHtml, "text/html", "UTF-8", null)
+                        println("InteractiveWebView: üåê Stable HTML geladen")
+                    } else {
+                        // ANTI-CRASH: Direkte URL-Ladung mit Stabilit√§t
+                        val headers = mapOf(
+                            "Accept" to "text/html,application/xhtml+xml",
+                            "Accept-Language" to "de-DE,de;q=0.9"
+                        )
+                        loadUrl(url, headers)
+                    }
+                } catch (e: Exception) {
+                    println("InteractiveWebView: ‚ùå URL-Ladefehler: ${e.message}")
+                    onError("URL-Ladefehler: ${e.message}")
                 }
             }
         },
         modifier = Modifier.fillMaxSize()
     )
+
+    // ANTI-CRASH: Cleanup
+    DisposableEffect(url) {
+        onDispose {
+            println("InteractiveWebView: üßπ WebView Cleanup")
+        }
+    }
 }
 
 @Composable
Index: app/src/main/java/com/example/geogeusserclone/ui/components/EmulatorFallbackMapComponent.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/geogeusserclone/ui/components/EmulatorFallbackMapComponent.kt b/app/src/main/java/com/example/geogeusserclone/ui/components/EmulatorFallbackMapComponent.kt
new file mode 100644
--- /dev/null	(date 1758217805971)
+++ b/app/src/main/java/com/example/geogeusserclone/ui/components/EmulatorFallbackMapComponent.kt	(date 1758217805971)
@@ -0,0 +1,317 @@
+package com.example.geogeusserclone.ui.components
+
+import androidx.compose.foundation.background
+import androidx.compose.foundation.clickable
+import androidx.compose.foundation.layout.*
+import androidx.compose.foundation.text.KeyboardOptions
+import androidx.compose.material.icons.Icons
+import androidx.compose.material.icons.filled.*
+import androidx.compose.material3.*
+import androidx.compose.runtime.*
+import androidx.compose.ui.Alignment
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.graphics.Color
+import androidx.compose.ui.text.font.FontWeight
+import androidx.compose.ui.text.input.KeyboardType
+import androidx.compose.ui.unit.dp
+
+/**
+ * Fallback-Komponente f√ºr Emulator-Situationen, wo normale Map-Clicks nicht funktionieren
+ * Bietet alternative Eingabemethoden f√ºr Koordinaten
+ */
+@Composable
+fun EmulatorFallbackMapComponent(
+    onLocationSelected: (Double, Double) -> Unit,
+    onClose: () -> Unit,
+    modifier: Modifier = Modifier
+) {
+    var latText by remember { mutableStateOf("") }
+    var lngText by remember { mutableStateOf("") }
+    var selectedPreset by remember { mutableStateOf<String?>(null) }
+    var showManualInput by remember { mutableStateOf(false) }
+
+    // Bekannte Locations f√ºr schnelle Auswahl
+    val presetLocations = listOf(
+        "Berlin, Germany" to Pair(52.5200, 13.4050),
+        "New York, USA" to Pair(40.7128, -74.0060),
+        "Tokyo, Japan" to Pair(35.6762, 139.6503),
+        "London, UK" to Pair(51.5074, -0.1278),
+        "Paris, France" to Pair(48.8566, 2.3522),
+        "Sydney, Australia" to Pair(-33.8688, 151.2093),
+        "Cairo, Egypt" to Pair(30.0444, 31.2357),
+        "S√£o Paulo, Brazil" to Pair(-23.5505, -46.6333),
+        "Mumbai, India" to Pair(19.0760, 72.8777),
+        "Random Location" to Pair((Math.random() * 180 - 90), (Math.random() * 360 - 180))
+    )
+
+    Card(
+        modifier = modifier
+            .fillMaxSize()
+            .padding(16.dp),
+        colors = CardDefaults.cardColors(
+            containerColor = MaterialTheme.colorScheme.surface
+        )
+    ) {
+        Column(
+            modifier = Modifier
+                .fillMaxSize()
+                .padding(24.dp)
+        ) {
+            // Header
+            Row(
+                modifier = Modifier.fillMaxWidth(),
+                horizontalArrangement = Arrangement.SpaceBetween,
+                verticalAlignment = Alignment.CenterVertically
+            ) {
+                Column {
+                    Text(
+                        text = "üîß Emulator-Fallback",
+                        style = MaterialTheme.typography.headlineSmall,
+                        fontWeight = FontWeight.Bold
+                    )
+                    Text(
+                        text = "Alternative Eingabemethoden",
+                        style = MaterialTheme.typography.bodyMedium,
+                        color = MaterialTheme.colorScheme.onSurfaceVariant
+                    )
+                }
+
+                IconButton(onClick = onClose) {
+                    Icon(Icons.Default.Close, contentDescription = "Schlie√üen")
+                }
+            }
+
+            Spacer(modifier = Modifier.height(24.dp))
+
+            // Warnung
+            Card(
+                colors = CardDefaults.cardColors(
+                    containerColor = MaterialTheme.colorScheme.errorContainer
+                )
+            ) {
+                Row(
+                    modifier = Modifier.padding(16.dp),
+                    verticalAlignment = Alignment.CenterVertically
+                ) {
+                    Icon(
+                        Icons.Default.Warning,
+                        contentDescription = null,
+                        tint = MaterialTheme.colorScheme.error
+                    )
+                    Spacer(modifier = Modifier.width(12.dp))
+                    Text(
+                        text = "Map-Clicks funktionieren nicht im Emulator. W√§hle eine Alternative:",
+                        style = MaterialTheme.typography.bodyMedium
+                    )
+                }
+            }
+
+            Spacer(modifier = Modifier.height(24.dp))
+
+            // Preset-Locations
+            Text(
+                text = "üìç Bekannte Locations",
+                style = MaterialTheme.typography.titleMedium,
+                fontWeight = FontWeight.Bold
+            )
+
+            Spacer(modifier = Modifier.height(12.dp))
+
+            LazyColumn(
+                modifier = Modifier.weight(1f),
+                verticalArrangement = Arrangement.spacedBy(8.dp)
+            ) {
+                items(presetLocations.size) { index ->
+                    val (name, coords) = presetLocations[index]
+                    val isSelected = selectedPreset == name
+
+                    Card(
+                        modifier = Modifier
+                            .fillMaxWidth()
+                            .clickable {
+                                selectedPreset = name
+                                onLocationSelected(coords.first, coords.second)
+                            },
+                        colors = CardDefaults.cardColors(
+                            containerColor = if (isSelected)
+                                MaterialTheme.colorScheme.primaryContainer
+                            else
+                                MaterialTheme.colorScheme.surfaceContainer
+                        )
+                    ) {
+                        Row(
+                            modifier = Modifier
+                                .fillMaxWidth()
+                                .padding(16.dp),
+                            horizontalArrangement = Arrangement.SpaceBetween,
+                            verticalAlignment = Alignment.CenterVertically
+                        ) {
+                            Column {
+                                Text(
+                                    text = name,
+                                    style = MaterialTheme.typography.titleSmall,
+                                    fontWeight = FontWeight.Bold
+                                )
+                                Text(
+                                    text = "${coords.first.format(4)}, ${coords.second.format(4)}",
+                                    style = MaterialTheme.typography.bodySmall,
+                                    color = MaterialTheme.colorScheme.onSurfaceVariant
+                                )
+                            }
+
+                            if (isSelected) {
+                                Icon(
+                                    Icons.Default.Check,
+                                    contentDescription = "Ausgew√§hlt",
+                                    tint = MaterialTheme.colorScheme.primary
+                                )
+                            } else {
+                                Icon(
+                                    Icons.Default.LocationOn,
+                                    contentDescription = "Ausw√§hlen",
+                                    tint = MaterialTheme.colorScheme.onSurfaceVariant
+                                )
+                            }
+                        }
+                    }
+                }
+            }
+
+            Spacer(modifier = Modifier.height(16.dp))
+
+            // Manuelle Eingabe Toggle
+            Row(
+                modifier = Modifier.fillMaxWidth(),
+                horizontalArrangement = Arrangement.SpaceBetween,
+                verticalAlignment = Alignment.CenterVertically
+            ) {
+                Text(
+                    text = "üéØ Manuelle Koordinaten-Eingabe",
+                    style = MaterialTheme.typography.titleMedium,
+                    fontWeight = FontWeight.Bold
+                )
+
+                Switch(
+                    checked = showManualInput,
+                    onCheckedChange = { showManualInput = it }
+                )
+            }
+
+            // Manuelle Eingabe
+            if (showManualInput) {
+                Spacer(modifier = Modifier.height(12.dp))
+
+                Card(
+                    colors = CardDefaults.cardColors(
+                        containerColor = MaterialTheme.colorScheme.surfaceContainer
+                    )
+                ) {
+                    Column(
+                        modifier = Modifier.padding(16.dp)
+                    ) {
+                        // Latitude Input
+                        OutlinedTextField(
+                            value = latText,
+                            onValueChange = { latText = it },
+                            label = { Text("Latitude (-90 bis 90)") },
+                            placeholder = { Text("z.B. 52.5200") },
+                            keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Decimal),
+                            modifier = Modifier.fillMaxWidth(),
+                            leadingIcon = { Icon(Icons.Default.Place, contentDescription = null) }
+                        )
+
+                        Spacer(modifier = Modifier.height(8.dp))
+
+                        // Longitude Input
+                        OutlinedTextField(
+                            value = lngText,
+                            onValueChange = { lngText = it },
+                            label = { Text("Longitude (-180 bis 180)") },
+                            placeholder = { Text("z.B. 13.4050") },
+                            keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Decimal),
+                            modifier = Modifier.fillMaxWidth(),
+                            leadingIcon = { Icon(Icons.Default.Place, contentDescription = null) }
+                        )
+
+                        Spacer(modifier = Modifier.height(16.dp))
+
+                        // Submit Button f√ºr manuelle Eingabe
+                        Button(
+                            onClick = {
+                                val lat = latText.toDoubleOrNull()
+                                val lng = lngText.toDoubleOrNull()
+
+                                if (lat != null && lng != null &&
+                                    lat >= -90 && lat <= 90 &&
+                                    lng >= -180 && lng <= 180) {
+                                    onLocationSelected(lat, lng)
+                                }
+                            },
+                            modifier = Modifier.fillMaxWidth(),
+                            enabled = run {
+                                val lat = latText.toDoubleOrNull()
+                                val lng = lngText.toDoubleOrNull()
+                                lat != null && lng != null &&
+                                lat >= -90 && lat <= 90 &&
+                                lng >= -180 && lng <= 180
+                            }
+                        ) {
+                            Icon(Icons.Default.Send, contentDescription = null)
+                            Spacer(modifier = Modifier.width(8.dp))
+                            Text("Koordinaten verwenden")
+                        }
+
+                        // Validation feedback
+                        val lat = latText.toDoubleOrNull()
+                        val lng = lngText.toDoubleOrNull()
+
+                        if (latText.isNotEmpty() && (lat == null || lat !in -90.0..90.0)) {
+                            Text(
+                                text = "‚ö†Ô∏è Latitude muss zwischen -90 und 90 liegen",
+                                style = MaterialTheme.typography.bodySmall,
+                                color = MaterialTheme.colorScheme.error
+                            )
+                        }
+
+                        if (lngText.isNotEmpty() && (lng == null || lng !in -180.0..180.0)) {
+                            Text(
+                                text = "‚ö†Ô∏è Longitude muss zwischen -180 und 180 liegen",
+                                style = MaterialTheme.typography.bodySmall,
+                                color = MaterialTheme.colorScheme.error
+                            )
+                        }
+                    }
+                }
+            }
+
+            Spacer(modifier = Modifier.height(16.dp))
+
+            // Action Buttons
+            Row(
+                modifier = Modifier.fillMaxWidth(),
+                horizontalArrangement = Arrangement.spacedBy(12.dp)
+            ) {
+                OutlinedButton(
+                    onClick = onClose,
+                    modifier = Modifier.weight(1f)
+                ) {
+                    Text("Abbrechen")
+                }
+
+                if (selectedPreset != null) {
+                    Button(
+                        onClick = {
+                            val coords = presetLocations.find { it.first == selectedPreset }?.second
+                            coords?.let { onLocationSelected(it.first, it.second) }
+                        },
+                        modifier = Modifier.weight(1f)
+                    ) {
+                        Text("Verwenden")
+                    }
+                }
+            }
+        }
+    }
+}
+
+private fun Double.format(digits: Int) = "%.${digits}f".format(this)
Index: .idea/copilotDiffState.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"CopilotDiffPersistence\">\r\n    <option name=\"pendingDiffs\">\r\n      <map>\r\n        <entry key=\"$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/network/LocationResponse.kt\">\r\n          <value>\r\n            <PendingDiffInfo>\r\n              <option name=\"filePath\" value=\"$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/network/LocationResponse.kt\" />\r\n              <option name=\"updatedContent\" value=\"package com.example.geogeusserclone.data.network&#10;&#10;data class LocationResponse(&#10;    val id: String,&#10;    val latitude: Double,&#10;    val longitude: Double,&#10;    val imageUrl: String,&#10;    val country: String? = null,&#10;    val city: String? = null,&#10;    val difficulty: Int = 1&#10;)&#10;&#10;data class LocationsResponse(&#10;    val locations: List&lt;LocationResponse&gt;,&#10;    val total: Int = 0,&#10;    val page: Int = 1,&#10;    val limit: Int = 10&#10;)\" />\r\n            </PendingDiffInfo>\r\n          </value>\r\n        </entry>\r\n        <entry key=\"$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/network/NetworkConfig.kt\">\r\n          <value>\r\n            <PendingDiffInfo>\r\n              <option name=\"filePath\" value=\"$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/network/NetworkConfig.kt\" />\r\n              <option name=\"originalContent\" value=\"package com.example.geogeusserclone.data.network&#10;&#10;import com.example.geogeusserclone.BuildConfig&#10;&#10;object NetworkConfig {&#10;    // Android Emulator&#10;    const val EMULATOR_BASE_URL = &quot;http://10.0.2.2:3000/api/&quot;&#10;&#10;    // Lokales Netzwerk (IP-Adresse anpassen)&#10;    const val LOCAL_BASE_URL = &quot;http://192.168.1.100:3000/api/&quot;&#10;&#10;    // Production (falls vorhanden)&#10;    const val PROD_BASE_URL = &quot;https://your-domain.com/api/&quot;&#10;&#10;    val BASE_URL = if (BuildConfig.DEBUG) {&#10;        EMULATOR_BASE_URL // F√ºr Android Emulator&#10;        // LOCAL_BASE_URL // Uncomment f√ºr echtes Ger√§t&#10;    } else {&#10;        PROD_BASE_URL&#10;    }&#10;&#10;    // Timeout-Konfiguration&#10;    const val CONNECT_TIMEOUT = 30L&#10;    const val READ_TIMEOUT = 30L&#10;    const val WRITE_TIMEOUT = 30L&#10;}&#10;\" />\r\n              <option name=\"updatedContent\" value=\"package com.example.geogeusserclone.data.network&#10;&#10;object NetworkConfig {&#10;    // Android Emulator&#10;    const val EMULATOR_BASE_URL = &quot;http://10.0.2.2:3000/api/&quot;&#10;&#10;    // Lokales Netzwerk (IP-Adresse anpassen)&#10;    const val LOCAL_BASE_URL = &quot;http://192.168.1.100:3000/api/&quot;&#10;&#10;    // Production (falls vorhanden)&#10;    const val PROD_BASE_URL = &quot;https://your-domain.com/api/&quot;&#10;&#10;    val BASE_URL = EMULATOR_BASE_URL // Verwende Emulator URL direkt&#10;&#10;    // Timeout-Konfiguration&#10;    const val CONNECT_TIMEOUT = 30L&#10;    const val READ_TIMEOUT = 30L&#10;    const val WRITE_TIMEOUT = 30L&#10;}\" />\r\n            </PendingDiffInfo>\r\n          </value>\r\n        </entry>\r\n        <entry key=\"$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/repositories/LocationCacheRepository.kt\">\r\n          <value>\r\n            <PendingDiffInfo>\r\n              <option name=\"filePath\" value=\"$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/repositories/LocationCacheRepository.kt\" />\r\n              <option name=\"originalContent\" value=\"&#10;\" />\r\n              <option name=\"updatedContent\" value=\"package com.example.geogeusserclone.data.repositories&#13;&#10;&#13;&#10;import com.example.geogeusserclone.data.database.dao.LocationDao&#13;&#10;import com.example.geogeusserclone.data.database.entities.LocationEntity&#13;&#10;import com.example.geogeusserclone.data.network.ApiService&#13;&#10;import kotlinx.coroutines.Dispatchers&#13;&#10;import kotlinx.coroutines.flow.Flow&#13;&#10;import kotlinx.coroutines.withContext&#13;&#10;import javax.inject.Inject&#13;&#10;import javax.inject.Singleton&#13;&#10;&#13;&#10;@Singleton&#13;&#10;class LocationCacheRepository @Inject constructor(&#13;&#10;    private val apiService: ApiService,&#13;&#10;    private val locationDao: LocationDao&#13;&#10;) {&#13;&#10;&#13;&#10;    suspend fun preloadLocationsInBackground() = withContext(Dispatchers.IO) {&#13;&#10;        try {&#13;&#10;            // Lade nur wenn weniger als 10 Locations im Cache&#13;&#10;            val cachedCount = locationDao.getCachedLocationCount()&#13;&#10;            if (cachedCount &lt; 10) {&#13;&#10;                val response = apiService.getRandomLocations(50)&#13;&#10;                if (response.isSuccessful) {&#13;&#10;                    val locationsResponse = response.body()!!&#13;&#10;                    val locationEntities = locationsResponse.data.locations.map { backendLocation -&gt;&#13;&#10;                        LocationEntity(&#13;&#10;                            id = backendLocation.id.toString(),&#13;&#10;                            latitude = backendLocation.coordinates.latitude,&#13;&#10;                            longitude = backendLocation.coordinates.longitude,&#13;&#10;                            imageUrl = backendLocation.imageUrls.firstOrNull() ?: &quot;&quot;,&#13;&#10;                            country = backendLocation.country,&#13;&#10;                            city = backendLocation.city,&#13;&#10;                            difficulty = backendLocation.difficulty,&#13;&#10;                            isCached = true,&#13;&#10;                            isUsed = false&#13;&#10;                        )&#13;&#10;                    }&#13;&#10;&#13;&#10;                    // Batch insert f√ºr bessere Performance&#13;&#10;                    locationDao.insertLocations(locationEntities)&#13;&#10;&#13;&#10;                    // Preload images im Hintergrund&#13;&#10;                    preloadImages(locationEntities.take(5)) // Nur erste 5 Bilder&#13;&#10;                }&#13;&#10;            }&#13;&#10;        } catch (e: Exception) {&#13;&#10;            // Silent fail - App funktioniert weiter mit Fallback Locations&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private suspend fun preloadImages(locations: List&lt;LocationEntity&gt;) = withContext(Dispatchers.IO) {&#13;&#10;        // Implementierung f√ºr Image Preloading&#13;&#10;        // Dies w√ºrde die Bilder in den Cache laden ohne sie anzuzeigen&#13;&#10;    }&#13;&#10;&#13;&#10;    suspend fun getNextLocations(count: Int = 3): List&lt;LocationEntity&gt; = withContext(Dispatchers.IO) {&#13;&#10;        locationDao.getUnusedLocations(count)&#13;&#10;    }&#13;&#10;}\" />\r\n            </PendingDiffInfo>\r\n          </value>\r\n        </entry>\r\n        <entry key=\"$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/repositories/StreetViewLocationRepository.kt\">\r\n          <value>\r\n            <PendingDiffInfo>\r\n              <option name=\"filePath\" value=\"$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/data/repositories/StreetViewLocationRepository.kt\" />\r\n              <option name=\"updatedContent\" value=\"package com.example.geogeusserclone.data.repositories&#10;&#10;import com.example.geogeusserclone.data.database.dao.LocationDao&#10;import com.example.geogeusserclone.data.database.entities.LocationEntity&#10;import com.example.geogeusserclone.data.network.ApiService&#10;import com.example.geogeusserclone.data.network.MapillaryApiService&#10;import com.example.geogeusserclone.utils.Constants&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.withTimeoutOrNull&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class StreetViewLocationRepository @Inject constructor(&#10;    private val apiService: ApiService,&#10;    private val mapillaryApiService: MapillaryApiService,&#10;    private val locationDao: LocationDao&#10;) : BaseRepository() {&#10;&#10;    suspend fun getRandomLocationWithStreetView(): Result&lt;LocationEntity&gt; {&#10;        return try {&#10;            // 1. Versuche zuerst lokale unbenutzte Location&#10;            val unusedLocation = locationDao.getRandomUnusedLocation()&#10;            if (unusedLocation != null) {&#10;                locationDao.markLocationAsUsed(unusedLocation.id)&#10;                return Result.success(unusedLocation)&#10;            }&#10;&#10;            // 2. Erstelle Fallback-Locations mit echten 360¬∞ StreetView-Bildern&#10;            val streetViewLocations = createStreetViewFallbackLocations()&#10;            locationDao.insertLocations(streetViewLocations)&#10;            &#10;            val randomLocation = streetViewLocations.random()&#10;            locationDao.markLocationAsUsed(randomLocation.id)&#10;            &#10;            return Result.success(randomLocation)&#10;&#10;        } catch (e: Exception) {&#10;            // Emergency Fallback&#10;            val emergencyLocation = createEmergencyLocation()&#10;            try {&#10;                locationDao.insertLocation(emergencyLocation)&#10;                locationDao.markLocationAsUsed(emergencyLocation.id)&#10;                Result.success(emergencyLocation)&#10;            } catch (dbError: Exception) {&#10;                Result.failure(Exception(&quot;Kritischer Fehler: Kann keine Location laden&quot;))&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun createStreetViewFallbackLocations(): List&lt;LocationEntity&gt; {&#10;        val fallbackLocations = mutableListOf&lt;LocationEntity&gt;()&#10;        &#10;        // Versuche echte Mapillary-Bilder f√ºr beliebte St√§dte zu holen&#10;        val popularCities = listOf(&#10;            Triple(48.8566, 2.3522, &quot;Paris&quot;),      // Paris&#10;            Triple(51.5074, -0.1278, &quot;London&quot;),   // London&#10;            Triple(40.7128, -74.0060, &quot;New York&quot;), // New York&#10;            Triple(35.6762, 139.6503, &quot;Tokyo&quot;),   // Tokyo&#10;            Triple(-33.8688, 151.2093, &quot;Sydney&quot;), // Sydney&#10;            Triple(52.5200, 13.4050, &quot;Berlin&quot;),   // Berlin&#10;            Triple(41.9028, 12.4964, &quot;Rome&quot;),     // Rome&#10;            Triple(41.3851, 2.1734, &quot;Barcelona&quot;)  // Barcelona&#10;        )&#10;&#10;        popularCities.forEachIndexed { index, (lat, lng, cityName) -&gt;&#10;            try {&#10;                val streetViewImage = fetchMapillaryImageForLocation(lat, lng)&#10;                if (streetViewImage != null) {&#10;                    fallbackLocations.add(&#10;                        LocationEntity(&#10;                            id = &quot;streetview_${cityName.lowercase()}_$index&quot;,&#10;                            latitude = streetViewImage.geometry.coordinates[1], // Mapillary coords&#10;                            longitude = streetViewImage.geometry.coordinates[0],&#10;                            imageUrl = streetViewImage.thumb_2048_url ?: streetViewImage.thumb_1024_url ?: &quot;&quot;,&#10;                            country = getCountryFromCity(cityName),&#10;                            city = cityName,&#10;                            difficulty = 2,&#10;                            isCached = true,&#10;                            isUsed = false&#10;                        )&#10;                    )&#10;                } else {&#10;                    // Fallback auf hochwertige Unsplash-Bilder&#10;                    fallbackLocations.add(createHighQualityFallbackLocation(lat, lng, cityName, index))&#10;                }&#10;            } catch (e: Exception) {&#10;                // Fallback auf statische Bilder&#10;                fallbackLocations.add(createHighQualityFallbackLocation(lat, lng, cityName, index))&#10;            }&#10;        }&#10;&#10;        return fallbackLocations&#10;    }&#10;&#10;    private suspend fun fetchMapillaryImageForLocation(lat: Double, lng: Double): com.example.geogeusserclone.data.network.MapillaryImage? {&#10;        return try {&#10;            // Erstelle Bounding Box (ca. 1km Radius)&#10;            val offset = 0.01 // Ungef√§hr 1km&#10;            val bbox = &quot;${lng - offset},${lat - offset},${lng + offset},${lat + offset}&quot;&#10;            &#10;            val response = withTimeoutOrNull(3000) {&#10;                mapillaryApiService.getImagesNearby(&#10;                    bbox = bbox,&#10;                    isPano = true,&#10;                    limit = 5,&#10;                    accessToken = Constants.MAPILLARY_ACCESS_TOKEN&#10;                )&#10;            }&#10;&#10;            if (response?.isSuccessful == true) {&#10;                response.body()?.data?.firstOrNull()&#10;            } else null&#10;        } catch (e: Exception) {&#10;            null&#10;        }&#10;    }&#10;&#10;    private fun createHighQualityFallbackLocation(lat: Double, lng: Double, cityName: String, index: Int): LocationEntity {&#10;        val imageUrls = mapOf(&#10;            &quot;Paris&quot; to &quot;https://images.unsplash.com/photo-1502602898536-47ad22581b52?w=1200&amp;h=800&amp;fit=crop&quot;,&#10;            &quot;London&quot; to &quot;https://images.unsplash.com/photo-1513635269975-59663e0ac1ad?w=1200&amp;h=800&amp;fit=crop&quot;,&#10;            &quot;New York&quot; to &quot;https://images.unsplash.com/photo-1496442226666-8d4d0e62e6e9?w=1200&amp;h=800&amp;fit=crop&quot;,&#10;            &quot;Tokyo&quot; to &quot;https://images.unsplash.com/photo-1540959733332-eab4deabeeaf?w=1200&amp;h=800&amp;fit=crop&quot;,&#10;            &quot;Sydney&quot; to &quot;https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=1200&amp;h=800&amp;fit=crop&quot;,&#10;            &quot;Berlin&quot; to &quot;https://images.unsplash.com/photo-1587330979470-3016b6702d89?w=1200&amp;h=800&amp;fit=crop&quot;,&#10;            &quot;Rome&quot; to &quot;https://images.unsplash.com/photo-1552832230-c0197dd311b5?w=1200&amp;h=800&amp;fit=crop&quot;,&#10;            &quot;Barcelona&quot; to &quot;https://images.unsplash.com/photo-1539037116277-4db20889f2d4?w=1200&amp;h=800&amp;fit=crop&quot;&#10;        )&#10;&#10;        return LocationEntity(&#10;            id = &quot;fallback_${cityName.lowercase()}_$index&quot;,&#10;            latitude = lat,&#10;            longitude = lng,&#10;            imageUrl = imageUrls[cityName] ?: &quot;https://images.unsplash.com/photo-1502602898536-47ad22581b52?w=1200&amp;h=800&amp;fit=crop&quot;,&#10;            country = getCountryFromCity(cityName),&#10;            city = cityName,&#10;            difficulty = 2,&#10;            isCached = true,&#10;            isUsed = false&#10;        )&#10;    }&#10;&#10;    private fun createEmergencyLocation(): LocationEntity {&#10;        return LocationEntity(&#10;            id = &quot;emergency_paris&quot;,&#10;            latitude = 48.8566,&#10;            longitude = 2.3522,&#10;            imageUrl = &quot;https://images.unsplash.com/photo-1502602898536-47ad22581b52?w=1200&amp;h=800&amp;fit=crop&quot;,&#10;            country = &quot;France&quot;,&#10;            city = &quot;Paris&quot;,&#10;            difficulty = 2,&#10;            isCached = true,&#10;            isUsed = false&#10;        )&#10;    }&#10;&#10;    private fun getCountryFromCity(cityName: String): String {&#10;        return when (cityName) {&#10;            &quot;Paris&quot; -&gt; &quot;France&quot;&#10;            &quot;London&quot; -&gt; &quot;United Kingdom&quot;&#10;            &quot;New York&quot; -&gt; &quot;United States&quot;&#10;            &quot;Tokyo&quot; -&gt; &quot;Japan&quot;&#10;            &quot;Sydney&quot; -&gt; &quot;Australia&quot;&#10;            &quot;Berlin&quot; -&gt; &quot;Germany&quot;&#10;            &quot;Rome&quot; -&gt; &quot;Italy&quot;&#10;            &quot;Barcelona&quot; -&gt; &quot;Spain&quot;&#10;            else -&gt; &quot;Unknown&quot;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Preloade Locations mit echten StreetView-Bildern&#10;     */&#10;    suspend fun preloadStreetViewLocations() {&#10;        try {&#10;            val streetViewLocations = createStreetViewFallbackLocations()&#10;            locationDao.insertLocations(streetViewLocations)&#10;        } catch (e: Exception) {&#10;            // Fallback auf normale Locations&#10;            val normalFallbacks = createStreetViewFallbackLocations()&#10;            locationDao.insertLocations(normalFallbacks)&#10;        }&#10;    }&#10;}\" />\r\n            </PendingDiffInfo>\r\n          </value>\r\n        </entry>\r\n        <entry key=\"$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/di/NetworkModule.kt\">\r\n          <value>\r\n            <PendingDiffInfo>\r\n              <option name=\"filePath\" value=\"$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/di/NetworkModule.kt\" />\r\n              <option name=\"updatedContent\" value=\"package com.example.geogeusserclone.di&#10;&#10;import com.example.geogeusserclone.data.network.ApiService&#10;import com.example.geogeusserclone.data.network.AuthInterceptor&#10;import com.example.geogeusserclone.utils.Constants&#10;import dagger.Module&#10;import dagger.Provides&#10;import dagger.hilt.InstallIn&#10;import dagger.hilt.components.SingletonComponent&#10;import okhttp3.OkHttpClient&#10;import okhttp3.logging.HttpLoggingInterceptor&#10;import retrofit2.Retrofit&#10;import retrofit2.converter.gson.GsonConverterFactory&#10;import java.util.concurrent.TimeUnit&#10;import javax.inject.Singleton&#10;&#10;@Module&#10;@InstallIn(SingletonComponent::class)&#10;object NetworkModule {&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideHttpLoggingInterceptor(): HttpLoggingInterceptor {&#10;        return HttpLoggingInterceptor().apply {&#10;            level = HttpLoggingInterceptor.Level.BODY&#10;        }&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideOkHttpClient(&#10;        authInterceptor: AuthInterceptor,&#10;        loggingInterceptor: HttpLoggingInterceptor&#10;    ): OkHttpClient {&#10;        return OkHttpClient.Builder()&#10;            .addInterceptor(authInterceptor)&#10;            .addInterceptor(loggingInterceptor)&#10;            .connectTimeout(Constants.CONNECT_TIMEOUT, TimeUnit.SECONDS)&#10;            .readTimeout(Constants.READ_TIMEOUT, TimeUnit.SECONDS)&#10;            .writeTimeout(Constants.WRITE_TIMEOUT, TimeUnit.SECONDS)&#10;            .build()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {&#10;        return Retrofit.Builder()&#10;            .baseUrl(Constants.BASE_URL)&#10;            .client(okHttpClient)&#10;            .addConverterFactory(GsonConverterFactory.create())&#10;            .build()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideApiService(retrofit: Retrofit): ApiService {&#10;        return retrofit.create(ApiService::class.java)&#10;    }&#10;}\" />\r\n            </PendingDiffInfo>\r\n          </value>\r\n        </entry>\r\n        <entry key=\"$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/di/RepositoryModule.kt\">\r\n          <value>\r\n            <PendingDiffInfo>\r\n              <option name=\"filePath\" value=\"$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/di/RepositoryModule.kt\" />\r\n              <option name=\"updatedContent\" value=\"package com.example.geogeusserclone.di&#10;&#10;import com.example.geogeusserclone.data.database.dao.GameDao&#10;import com.example.geogeusserclone.data.database.dao.GuessDao&#10;import com.example.geogeusserclone.data.database.dao.LocationDao&#10;import com.example.geogeusserclone.data.database.dao.UserDao&#10;import com.example.geogeusserclone.data.network.ApiService&#10;import com.example.geogeusserclone.data.network.MapillaryApiService&#10;import com.example.geogeusserclone.data.repositories.*&#10;import dagger.Module&#10;import dagger.Provides&#10;import dagger.hilt.InstallIn&#10;import dagger.hilt.components.SingletonComponent&#10;import javax.inject.Singleton&#10;&#10;@Module&#10;@InstallIn(SingletonComponent::class)&#10;object RepositoryModule {&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideUserRepository(&#10;        apiService: ApiService,&#10;        userDao: UserDao,&#10;        authInterceptor: com.example.geogeusserclone.data.network.AuthInterceptor&#10;    ): UserRepository {&#10;        return UserRepository(apiService, userDao, authInterceptor)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideLocationRepository(&#10;        apiService: ApiService,&#10;        mapillaryApiService: MapillaryApiService,&#10;        locationDao: LocationDao&#10;    ): LocationRepository {&#10;        return LocationRepository(apiService, mapillaryApiService, locationDao)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideGameRepository(&#10;        apiService: ApiService,&#10;        gameDao: GameDao,&#10;        guessDao: GuessDao,&#10;        locationDao: LocationDao,&#10;        userRepository: UserRepository&#10;    ): GameRepository {&#10;        return GameRepository(apiService, gameDao, guessDao, locationDao, userRepository)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideLocationCacheRepository(&#10;        apiService: ApiService,&#10;        locationDao: LocationDao&#10;    ): LocationCacheRepository {&#10;        return LocationCacheRepository(apiService, locationDao)&#10;    }&#10;}\" />\r\n            </PendingDiffInfo>\r\n          </value>\r\n        </entry>\r\n        <entry key=\"$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/ui/components/MapViewScreen.kt\">\r\n          <value>\r\n            <PendingDiffInfo>\r\n              <option name=\"filePath\" value=\"$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/ui/components/MapViewScreen.kt\" />\r\n            </PendingDiffInfo>\r\n          </value>\r\n        </entry>\r\n        <entry key=\"$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/utils/MapCacheManager.kt\">\r\n          <value>\r\n            <PendingDiffInfo>\r\n              <option name=\"filePath\" value=\"$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/utils/MapCacheManager.kt\" />\r\n              <option name=\"updatedContent\" value=\"package com.example.geogeusserclone.utils&#10;&#10;import android.content.Context&#10;import androidx.work.*&#10;import com.example.geogeusserclone.data.repositories.LocationCacheRepository&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#10;import java.util.concurrent.TimeUnit&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;/**&#10; * Background-Service f√ºr Map Tile Preloading&#10; */&#10;@Singleton&#10;class MapCacheManager @Inject constructor(&#10;    @ApplicationContext private val context: Context,&#10;    private val locationCacheRepository: LocationCacheRepository&#10;) {&#10;&#10;    /**&#10;     * Startet Background-Preloading von Map Tiles&#10;     */&#10;    fun startMapTilePreloading() {&#10;        val constraints = Constraints.Builder()&#10;            .setRequiredNetworkType(NetworkType.UNMETERED) // Nur WLAN&#10;            .setRequiresBatteryNotLow(true)&#10;            .setRequiresCharging(false)&#10;            .build()&#10;&#10;        val preloadWork = OneTimeWorkRequestBuilder&lt;MapTilePreloadWorker&gt;()&#10;            .setConstraints(constraints)&#10;            .setBackoffCriteria(&#10;                BackoffPolicy.EXPONENTIAL,&#10;                WorkRequest.MIN_BACKOFF_MILLIS,&#10;                TimeUnit.MILLISECONDS&#10;            )&#10;            .build()&#10;&#10;        WorkManager.getInstance(context)&#10;            .enqueueUniqueWork(&#10;                &quot;map_tile_preload&quot;,&#10;                ExistingWorkPolicy.KEEP,&#10;                preloadWork&#10;            )&#10;    }&#10;&#10;    /**&#10;     * Bereinigt alte Map Tiles bei Low Memory&#10;     */&#10;    fun cleanupOldTiles() {&#10;        val cleanupWork = OneTimeWorkRequestBuilder&lt;MapTileCleanupWorker&gt;()&#10;            .build()&#10;&#10;        WorkManager.getInstance(context)&#10;            .enqueue(cleanupWork)&#10;    }&#10;&#10;    /**&#10;     * √úberwacht Map Performance Metriken&#10;     */&#10;    fun trackMapPerformance(&#10;        loadTime: Long,&#10;        tileCount: Int,&#10;        memoryUsage: Long&#10;    ) {&#10;        // Performance Tracking f√ºr Optimierungen&#10;        if (loadTime &gt; 3000) { // √úber 3 Sekunden&#10;            // Trigger f√ºr Cache-Optimierung&#10;            cleanupOldTiles()&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Worker f√ºr Map Tile Preloading&#10; */&#10;class MapTilePreloadWorker(&#10;    context: Context,&#10;    params: WorkerParameters&#10;) : CoroutineWorker(context, params) {&#10;&#10;    override suspend fun doWork(): Result {&#10;        return try {&#10;            // Preload h√§ufig verwendete Gebiete&#10;            preloadPopularRegions()&#10;            Result.success()&#10;        } catch (e: Exception) {&#10;            Result.retry()&#10;        }&#10;    }&#10;&#10;    private suspend fun preloadPopularRegions() {&#10;        val popularRegions = listOf(&#10;            Pair(54.5260, 15.2551), // Europa&#10;            Pair(39.8283, -98.5795), // USA&#10;            Pair(35.6762, 139.6503), // Tokyo&#10;            Pair(-33.8688, 151.2093) // Sydney&#10;        )&#10;&#10;        // Implementierung des Tile-Preloadings&#10;        // Dies w√ºrde die Tiles f√ºr diese Regionen im Cache speichern&#10;    }&#10;}&#10;&#10;/**&#10; * Worker f√ºr Map Cache Cleanup&#10; */&#10;class MapTileCleanupWorker(&#10;    context: Context,&#10;    params: WorkerParameters&#10;) : CoroutineWorker(context, params) {&#10;&#10;    override suspend fun doWork(): Result {&#10;        return try {&#10;            val cacheDir = applicationContext.cacheDir&#10;            val mapCacheDir = java.io.File(cacheDir, &quot;osmdroid&quot;)&#10;            &#10;            if (mapCacheDir.exists()) {&#10;                // L√∂sche Tiles √§lter als 7 Tage&#10;                val weekAgo = System.currentTimeMillis() - (7 * 24 * 60 * 60 * 1000)&#10;                &#10;                mapCacheDir.listFiles()?.forEach { file -&gt;&#10;                    if (file.lastModified() &lt; weekAgo) {&#10;                        file.delete()&#10;                    }&#10;                }&#10;            }&#10;            &#10;            Result.success()&#10;        } catch (e: Exception) {&#10;            Result.failure()&#10;        }&#10;    }&#10;}\" />\r\n            </PendingDiffInfo>\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/copilotDiffState.xml b/.idea/copilotDiffState.xml
--- a/.idea/copilotDiffState.xml	(revision 4d7db19e7b206d610c9a87cd78048af8efa64532)
+++ b/.idea/copilotDiffState.xml	(date 1758217806429)
@@ -53,6 +53,32 @@
             </PendingDiffInfo>
           </value>
         </entry>
+        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/ui/activities/GameActivity.kt">
+          <value>
+            <PendingDiffInfo>
+              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/ui/activities/GameActivity.kt" />
+              <option name="originalContent" value="package com.example.geogeusserclone.ui.activities&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.activity.viewModels&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import com.example.geogeusserclone.ui.components.InteractiveStreetViewWithFallback&#10;import com.example.geogeusserclone.ui.components.GuessMapView&#10;import com.example.geogeusserclone.ui.components.EmulatorFallbackMapComponent&#10;import com.example.geogeusserclone.ui.components.RoundResultView&#10;import com.example.geogeusserclone.ui.theme.GeoGeusserCloneTheme&#10;import com.example.geogeusserclone.viewmodels.GameViewModel&#10;import com.example.geogeusserclone.data.models.GameState&#10;import com.example.geogeusserclone.data.models.GameUiState&#10;import com.example.geogeusserclone.data.database.entities.LocationEntity&#10;import dagger.hilt.android.AndroidEntryPoint&#10;&#10;@AndroidEntryPoint&#10;class GameActivity : ComponentActivity() {&#10;&#10;    private val gameViewModel: GameViewModel by viewModels()&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;&#10;        setContent {&#10;            GeoGeusserCloneTheme {&#10;                val gameState by gameViewModel.gameState.collectAsState()&#10;                val uiState by gameViewModel.uiState.collectAsState()&#10;&#10;                LaunchedEffect(Unit) {&#10;                    gameViewModel.startNewRound()&#10;                }&#10;&#10;                StreetViewGameScreen(&#10;                    gameState = gameState,&#10;                    uiState = uiState,&#10;                    onGuess = { lat, lng -&gt; gameViewModel.submitGuess(lat, lng) },&#10;                    onNextRound = { gameViewModel.nextRound() },&#10;                    onShowMap = { gameViewModel.showGuessMap() },&#10;                    onHideMap = { gameViewModel.hideGuessMap() },&#10;                    onStreetViewReady = { gameViewModel.onStreetViewReady() },&#10;                    onBack = { finish() },&#10;                    onClearError = { gameViewModel.clearError() }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun StreetViewGameScreen(&#10;    gameState: GameState,&#10;    uiState: GameUiState,&#10;    onGuess: (Double, Double) -&gt; Unit,&#10;    onNextRound: () -&gt; Unit,&#10;    onShowMap: () -&gt; Unit,&#10;    onHideMap: () -&gt; Unit,&#10;    onStreetViewReady: () -&gt; Unit,&#10;    onBack: () -&gt; Unit,&#10;    onClearError: () -&gt; Unit&#10;) {&#10;    val snackbarHostState = remember { SnackbarHostState() }&#10;&#10;    // Handle errors&#10;    LaunchedEffect(uiState.error) {&#10;        uiState.error?.let {&#10;            snackbarHostState.showSnackbar(&#10;                message = it,&#10;                duration = SnackbarDuration.Short&#10;            )&#10;            onClearError()&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        snackbarHost = { SnackbarHost(snackbarHostState) }&#10;    ) { padding -&gt;&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(padding)&#10;        ) {&#10;            when {&#10;                // Loading state&#10;                uiState.isLoading -&gt; {&#10;                    Box(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        Column(&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            CircularProgressIndicator()&#10;                            Spacer(modifier = Modifier.height(16.dp))&#10;                            Text(&quot;Loading new location...&quot;)&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Active round with Street View&#10;                gameState.isRoundActive &amp;&amp; gameState.currentRound != null -&gt; {&#10;                    InteractiveStreetViewWithFallback(&#10;                        location = LocationEntity(&#10;                            id = gameState.currentRound.location.id.toString(), // WICHTIG: ID als String f√ºr Backend-Detection&#10;                            latitude = gameState.currentRound.location.lat,&#10;                            longitude = gameState.currentRound.location.lng,&#10;                            imageUrl = &quot;&quot;, // Wird von der Street View-Komponente automatisch generiert&#10;                            country = gameState.currentRound.location.country,&#10;                            city = gameState.currentRound.location.city,&#10;                            difficulty = gameState.currentRound.location.difficulty&#10;                        ),&#10;                        modifier = Modifier.fillMaxSize()&#10;                    )&#10;&#10;                    // Game UI overlay&#10;                    GameUIOverlay(&#10;                        uiState = uiState,&#10;                        gameState = gameState,&#10;                        onShowMap = onShowMap,&#10;                        onBack = onBack&#10;                    )&#10;                }&#10;&#10;                // No active round&#10;                else -&gt; {&#10;                    Box(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        Text(&quot;No active round&quot;)&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Guess Map overlay&#10;            if (uiState.showGuessMap) {&#10;                GuessMapView(&#10;                    onGuessSelected = { lat, lng -&gt;&#10;                        onGuess(lat, lng)&#10;                        onHideMap()&#10;                    },&#10;                    onMapClose = onHideMap,&#10;                    modifier = Modifier.fillMaxSize()&#10;                )&#10;            }&#10;&#10;            // Round Result overlay&#10;            if (uiState.showResults &amp;&amp; uiState.lastScoreResponse != null) {&#10;                RoundResultView(&#10;                    scoreResponse = uiState.lastScoreResponse,&#10;                    gameState = gameState,&#10;                    onNextRound = onNextRound,&#10;                    modifier = Modifier.fillMaxSize()&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun GameUIOverlay(&#10;    uiState: GameUiState,&#10;    gameState: GameState,&#10;    onShowMap: () -&gt; Unit,&#10;    onBack: () -&gt; Unit&#10;) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;    ) {&#10;        // Top bar with back button and score&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;            verticalAlignment = Alignment.Top&#10;        ) {&#10;            Button(&#10;                onClick = onBack,&#10;                colors = ButtonDefaults.buttonColors(&#10;                    containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.8f)&#10;                )&#10;            ) {&#10;                Text(&quot;‚Üê Back&quot;)&#10;            }&#10;&#10;            Card(&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.8f)&#10;                )&#10;            ) {&#10;                Text(&#10;                    text = &quot;Score: ${gameState.totalScore}&quot;,&#10;                    modifier = Modifier.padding(8.dp),&#10;                    style = MaterialTheme.typography.titleMedium&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.weight(1f))&#10;&#10;        // Bottom action area&#10;        if (uiState.streetViewReady &amp;&amp; !uiState.showGuessMap &amp;&amp; !uiState.showResults) {&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.9f)&#10;                )&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(16.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Where do you think this is?&quot;,&#10;                        style = MaterialTheme.typography.titleLarge&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    Button(&#10;                        onClick = onShowMap,&#10;                        modifier = Modifier.fillMaxWidth()&#10;                    ) {&#10;                        Text(&quot;Make Your Guess&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Loading indicator when Street View is not ready&#10;        if (!uiState.streetViewReady &amp;&amp; uiState.streetViewAvailable) {&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.9f)&#10;                )&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier&#10;                        .padding(16.dp)&#10;                        .fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.Center,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    CircularProgressIndicator(modifier = Modifier.size(24.dp))&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;                    Text(&quot;Loading Street View...&quot;)&#10;                }&#10;            }&#10;        }&#10;&#10;        // Street View not available message&#10;        if (!uiState.streetViewAvailable) {&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.errorContainer.copy(alpha = 0.9f)&#10;                )&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(16.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Street View not available for this location&quot;,&#10;                        style = MaterialTheme.typography.titleMedium,&#10;                        color = MaterialTheme.colorScheme.onErrorContainer&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    Button(&#10;                        onClick = onShowMap&#10;                    ) {&#10;                        Text(&quot;Make Your Guess Anyway&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
+              <option name="updatedContent" value="package com.example.geogeusserclone.ui.activities&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.activity.viewModels&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import com.example.geogeusserclone.ui.components.InteractiveStreetViewWithFallback&#10;import com.example.geogeusserclone.ui.components.GuessMapView&#10;import com.example.geogeusserclone.ui.components.EmulatorFallbackMapComponent&#10;import com.example.geogeusserclone.ui.components.RoundResultView&#10;import com.example.geogeusserclone.ui.theme.GeoGeusserCloneTheme&#10;import com.example.geogeusserclone.viewmodels.GameViewModel&#10;import com.example.geogeusserclone.data.models.GameState&#10;import com.example.geogeusserclone.data.models.GameUiState&#10;import com.example.geogeusserclone.data.database.entities.LocationEntity&#10;import dagger.hilt.android.AndroidEntryPoint&#10;&#10;@AndroidEntryPoint&#10;class GameActivity : ComponentActivity() {&#10;&#10;    private val gameViewModel: GameViewModel by viewModels()&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;&#10;        setContent {&#10;            GeoGeusserCloneTheme {&#10;                val gameState by gameViewModel.gameState.collectAsState()&#10;                val uiState by gameViewModel.uiState.collectAsState()&#10;&#10;                LaunchedEffect(Unit) {&#10;                    gameViewModel.startNewRound()&#10;                }&#10;&#10;                StreetViewGameScreen(&#10;                    gameState = gameState,&#10;                    uiState = uiState,&#10;                    onGuess = { lat, lng -&gt; gameViewModel.submitGuess(lat, lng) },&#10;                    onNextRound = { gameViewModel.nextRound() },&#10;                    onShowMap = { gameViewModel.showGuessMap() },&#10;                    onHideMap = { gameViewModel.hideGuessMap() },&#10;                    onStreetViewReady = { gameViewModel.onStreetViewReady() },&#10;                    onBack = { finish() },&#10;                    onClearError = { gameViewModel.clearError() }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun StreetViewGameScreen(&#10;    gameState: GameState,&#10;    uiState: GameUiState,&#10;    onGuess: (Double, Double) -&gt; Unit,&#10;    onNextRound: () -&gt; Unit,&#10;    onShowMap: () -&gt; Unit,&#10;    onHideMap: () -&gt; Unit,&#10;    onStreetViewReady: () -&gt; Unit,&#10;    onBack: () -&gt; Unit,&#10;    onClearError: () -&gt; Unit&#10;) {&#10;    val snackbarHostState = remember { SnackbarHostState() }&#10;&#10;    // Handle errors&#10;    LaunchedEffect(uiState.error) {&#10;        uiState.error?.let {&#10;            snackbarHostState.showSnackbar(&#10;                message = it,&#10;                duration = SnackbarDuration.Short&#10;            )&#10;            onClearError()&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        snackbarHost = { SnackbarHost(snackbarHostState) }&#10;    ) { padding -&gt;&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(padding)&#10;        ) {&#10;            when {&#10;                // Loading state&#10;                uiState.isLoading -&gt; {&#10;                    Box(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        Column(&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            CircularProgressIndicator()&#10;                            Spacer(modifier = Modifier.height(16.dp))&#10;                            Text(&quot;Loading new location...&quot;)&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Active round with Street View&#10;                gameState.isRoundActive &amp;&amp; gameState.currentRound != null -&gt; {&#10;                    InteractiveStreetViewWithFallback(&#10;                        location = LocationEntity(&#10;                            id = gameState.currentRound.location.id.toString(), // WICHTIG: ID als String f√ºr Backend-Detection&#10;                            latitude = gameState.currentRound.location.lat,&#10;                            longitude = gameState.currentRound.location.lng,&#10;                            imageUrl = &quot;&quot;, // Wird von der Street View-Komponente automatisch generiert&#10;                            country = gameState.currentRound.location.country,&#10;                            city = gameState.currentRound.location.city,&#10;                            difficulty = gameState.currentRound.location.difficulty&#10;                        ),&#10;                        modifier = Modifier.fillMaxSize()&#10;                    )&#10;&#10;                    // Game UI overlay&#10;                    GameUIOverlay(&#10;                        uiState = uiState,&#10;                        gameState = gameState,&#10;                        onShowMap = onShowMap,&#10;                        onBack = onBack&#10;                    )&#10;                }&#10;&#10;                // No active round&#10;                else -&gt; {&#10;                    Box(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        Text(&quot;No active round&quot;)&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Guess Map overlay - ERWEITERT mit Emulator-Fallback&#10;            if (uiState.showGuessMap) {&#10;                // INTELLIGENTE Emulator-Detection und Fallback&#10;                var showEmulatorFallback by remember { mutableStateOf(false) }&#10;                var mapFailureDetected by remember { mutableStateOf(false) }&#10;                var startTime by remember { mutableLongStateOf(0L) }&#10;&#10;                // Starte Timer bei erstem Map-Anzeigen&#10;                LaunchedEffect(uiState.showGuessMap) {&#10;                    if (uiState.showGuessMap) {&#10;                        startTime = System.currentTimeMillis()&#10;                        showEmulatorFallback = false&#10;                        mapFailureDetected = false&#10;&#10;                        // EMULATOR-DETECTION: Nach 15 Sekunden ohne Erfolg -&gt; Fallback anbieten&#10;                        kotlinx.coroutines.delay(15000)&#10;                        if (uiState.showGuessMap &amp;&amp; !mapFailureDetected) {&#10;                            println(&quot;GameActivity:  Automatische Emulator-Fallback-Detection nach 15s ohne Map-Clicks&quot;)&#10;                            showEmulatorFallback = true&#10;                        }&#10;                    }&#10;                }&#10;&#10;                if (showEmulatorFallback) {&#10;                    // FALLBACK-KOMPONENTE f√ºr Emulator-Probleme&#10;                    EmulatorFallbackMapComponent(&#10;                        onLocationSelected = { lat, lng -&gt;&#10;                            println(&quot;GameActivity: ‚úÖ Fallback-Location ausgew√§hlt: $lat, $lng&quot;)&#10;                            onGuess(lat, lng)&#10;                            onHideMap()&#10;                        },&#10;                        onClose = {&#10;                            showEmulatorFallback = false&#10;                            onHideMap()&#10;                        },&#10;                        modifier = Modifier.fillMaxSize()&#10;                    )&#10;&#10;                    // Overlay mit Option zur√ºck zur normalen Map&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxSize()&#10;                            .padding(16.dp)&#10;                    ) {&#10;                        Card(&#10;                            modifier = Modifier.align(Alignment.TopCenter),&#10;                            colors = CardDefaults.cardColors(&#10;                                containerColor = MaterialTheme.colorScheme.primaryContainer&#10;                            )&#10;                        ) {&#10;                            Row(&#10;                                modifier = Modifier.padding(12.dp),&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                Text(&#10;                                    text = &quot; Emulator-Modus aktiv&quot;,&#10;                                    style = MaterialTheme.typography.titleSmall&#10;                                )&#10;                                Spacer(modifier = Modifier.width(8.dp))&#10;                                TextButton(&#10;                                    onClick = { showEmulatorFallback = false }&#10;                                ) {&#10;                                    Text(&quot;Zur√ºck zur Map&quot;)&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                } else {&#10;                    // NORMALE GuessMapView mit Fallback-Button&#10;                    Box(modifier = Modifier.fillMaxSize()) {&#10;                        GuessMapView(&#10;                            onGuessSelected = { lat, lng -&gt;&#10;                                mapFailureDetected = false // Erfolg!&#10;                                onGuess(lat, lng)&#10;                                onHideMap()&#10;                            },&#10;                            onMapClose = onHideMap,&#10;                            modifier = Modifier.fillMaxSize()&#10;                        )&#10;&#10;                        // EMULATOR-FALLBACK-BUTTON nach 10 Sekunden&#10;                        if (System.currentTimeMillis() - startTime &gt; 10000) {&#10;                            Card(&#10;                                modifier = Modifier&#10;                                    .align(Alignment.TopEnd)&#10;                                    .padding(16.dp),&#10;                                colors = CardDefaults.cardColors(&#10;                                    containerColor = MaterialTheme.colorScheme.errorContainer&#10;                                )&#10;                            ) {&#10;                                TextButton(&#10;                                    onClick = { showEmulatorFallback = true }&#10;                                ) {&#10;                                    Text(&#10;                                        text = &quot; Map-Clicks funktionieren nicht? Hier klicken!&quot;,&#10;                                        style = MaterialTheme.typography.bodySmall&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Round Result overlay&#10;            if (uiState.showResults &amp;&amp; uiState.lastScoreResponse != null) {&#10;                RoundResultView(&#10;                    scoreResponse = uiState.lastScoreResponse,&#10;                    gameState = gameState,&#10;                    onNextRound = onNextRound,&#10;                    modifier = Modifier.fillMaxSize()&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun GameUIOverlay(&#10;    uiState: GameUiState,&#10;    gameState: GameState,&#10;    onShowMap: () -&gt; Unit,&#10;    onBack: () -&gt; Unit&#10;) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;    ) {&#10;        // Top bar with back button and score&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;            verticalAlignment = Alignment.Top&#10;        ) {&#10;            Button(&#10;                onClick = onBack,&#10;                colors = ButtonDefaults.buttonColors(&#10;                    containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.8f)&#10;                )&#10;            ) {&#10;                Text(&quot;‚Üê Back&quot;)&#10;            }&#10;&#10;            Card(&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.8f)&#10;                )&#10;            ) {&#10;                Text(&#10;                    text = &quot;Score: ${gameState.totalScore}&quot;,&#10;                    modifier = Modifier.padding(8.dp),&#10;                    style = MaterialTheme.typography.titleMedium&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.weight(1f))&#10;&#10;        // Bottom action area&#10;        if (uiState.streetViewReady &amp;&amp; !uiState.showGuessMap &amp;&amp; !uiState.showResults) {&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.9f)&#10;                )&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(16.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Where do you think this is?&quot;,&#10;                        style = MaterialTheme.typography.titleLarge&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    Button(&#10;                        onClick = onShowMap,&#10;                        modifier = Modifier.fillMaxWidth()&#10;                    ) {&#10;                        Text(&quot;Make Your Guess&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Loading indicator when Street View is not ready&#10;        if (!uiState.streetViewReady &amp;&amp; uiState.streetViewAvailable) {&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.9f)&#10;                )&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier&#10;                        .padding(16.dp)&#10;                        .fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.Center,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    CircularProgressIndicator(modifier = Modifier.size(24.dp))&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;                    Text(&quot;Loading Street View...&quot;)&#10;                }&#10;            }&#10;        }&#10;&#10;        // Street View not available message&#10;        if (!uiState.streetViewAvailable) {&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.errorContainer.copy(alpha = 0.9f)&#10;                )&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(16.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Street View not available for this location&quot;,&#10;                        style = MaterialTheme.typography.titleMedium,&#10;                        color = MaterialTheme.colorScheme.onErrorContainer&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    Button(&#10;                        onClick = onShowMap&#10;                    ) {&#10;                        Text(&quot;Make Your Guess Anyway&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
+            </PendingDiffInfo>
+          </value>
+        </entry>
+        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/ui/components/EmulatorFallbackMapComponent.kt">
+          <value>
+            <PendingDiffInfo>
+              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/ui/components/EmulatorFallbackMapComponent.kt" />
+              <option name="updatedContent" value="package com.example.geogeusserclone.ui.components&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.input.KeyboardType&#10;import androidx.compose.ui.unit.dp&#10;&#10;/**&#10; * Fallback-Komponente f√ºr Emulator-Situationen, wo normale Map-Clicks nicht funktionieren&#10; * Bietet alternative Eingabemethoden f√ºr Koordinaten&#10; */&#10;@Composable&#10;fun EmulatorFallbackMapComponent(&#10;    onLocationSelected: (Double, Double) -&gt; Unit,&#10;    onClose: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    var latText by remember { mutableStateOf(&quot;&quot;) }&#10;    var lngText by remember { mutableStateOf(&quot;&quot;) }&#10;    var selectedPreset by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    var showManualInput by remember { mutableStateOf(false) }&#10;&#10;    // Bekannte Locations f√ºr schnelle Auswahl&#10;    val presetLocations = listOf(&#10;        &quot;Berlin, Germany&quot; to Pair(52.5200, 13.4050),&#10;        &quot;New York, USA&quot; to Pair(40.7128, -74.0060),&#10;        &quot;Tokyo, Japan&quot; to Pair(35.6762, 139.6503),&#10;        &quot;London, UK&quot; to Pair(51.5074, -0.1278),&#10;        &quot;Paris, France&quot; to Pair(48.8566, 2.3522),&#10;        &quot;Sydney, Australia&quot; to Pair(-33.8688, 151.2093),&#10;        &quot;Cairo, Egypt&quot; to Pair(30.0444, 31.2357),&#10;        &quot;S√£o Paulo, Brazil&quot; to Pair(-23.5505, -46.6333),&#10;        &quot;Mumbai, India&quot; to Pair(19.0760, 72.8777),&#10;        &quot;Random Location&quot; to Pair((Math.random() * 180 - 90), (Math.random() * 360 - 180))&#10;    )&#10;&#10;    Card(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surface&#10;        )&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(24.dp)&#10;        ) {&#10;            // Header&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Column {&#10;                    Text(&#10;                        text = &quot; Emulator-Fallback&quot;,&#10;                        style = MaterialTheme.typography.headlineSmall,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                    Text(&#10;                        text = &quot;Alternative Eingabemethoden&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                }&#10;&#10;                IconButton(onClick = onClose) {&#10;                    Icon(Icons.Default.Close, contentDescription = &quot;Schlie√üen&quot;)&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(24.dp))&#10;&#10;            // Warnung&#10;            Card(&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.errorContainer&#10;                )&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier.padding(16.dp),&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Icon(&#10;                        Icons.Default.Warning,&#10;                        contentDescription = null,&#10;                        tint = MaterialTheme.colorScheme.error&#10;                    )&#10;                    Spacer(modifier = Modifier.width(12.dp))&#10;                    Text(&#10;                        text = &quot;Map-Clicks funktionieren nicht im Emulator. W√§hle eine Alternative:&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(24.dp))&#10;&#10;            // Preset-Locations&#10;            Text(&#10;                text = &quot; Bekannte Locations&quot;,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            LazyColumn(&#10;                modifier = Modifier.weight(1f),&#10;                verticalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                items(presetLocations.size) { index -&gt;&#10;                    val (name, coords) = presetLocations[index]&#10;                    val isSelected = selectedPreset == name&#10;&#10;                    Card(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .clickable {&#10;                                selectedPreset = name&#10;                                onLocationSelected(coords.first, coords.second)&#10;                            },&#10;                        colors = CardDefaults.cardColors(&#10;                            containerColor = if (isSelected)&#10;                                MaterialTheme.colorScheme.primaryContainer&#10;                            else&#10;                                MaterialTheme.colorScheme.surfaceContainer&#10;                        )&#10;                    ) {&#10;                        Row(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(16.dp),&#10;                            horizontalArrangement = Arrangement.SpaceBetween,&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Column {&#10;                                Text(&#10;                                    text = name,&#10;                                    style = MaterialTheme.typography.titleSmall,&#10;                                    fontWeight = FontWeight.Bold&#10;                                )&#10;                                Text(&#10;                                    text = &quot;${coords.first.format(4)}, ${coords.second.format(4)}&quot;,&#10;                                    style = MaterialTheme.typography.bodySmall,&#10;                                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                                )&#10;                            }&#10;&#10;                            if (isSelected) {&#10;                                Icon(&#10;                                    Icons.Default.Check,&#10;                                    contentDescription = &quot;Ausgew√§hlt&quot;,&#10;                                    tint = MaterialTheme.colorScheme.primary&#10;                                )&#10;                            } else {&#10;                                Icon(&#10;                                    Icons.Default.LocationOn,&#10;                                    contentDescription = &quot;Ausw√§hlen&quot;,&#10;                                    tint = MaterialTheme.colorScheme.onSurfaceVariant&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            // Manuelle Eingabe Toggle&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = &quot; Manuelle Koordinaten-Eingabe&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;&#10;                Switch(&#10;                    checked = showManualInput,&#10;                    onCheckedChange = { showManualInput = it }&#10;                )&#10;            }&#10;&#10;            // Manuelle Eingabe&#10;            if (showManualInput) {&#10;                Spacer(modifier = Modifier.height(12.dp))&#10;&#10;                Card(&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = MaterialTheme.colorScheme.surfaceContainer&#10;                    )&#10;                ) {&#10;                    Column(&#10;                        modifier = Modifier.padding(16.dp)&#10;                    ) {&#10;                        // Latitude Input&#10;                        OutlinedTextField(&#10;                            value = latText,&#10;                            onValueChange = { latText = it },&#10;                            label = { Text(&quot;Latitude (-90 bis 90)&quot;) },&#10;                            placeholder = { Text(&quot;z.B. 52.5200&quot;) },&#10;                            keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Decimal),&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            leadingIcon = { Icon(Icons.Default.Place, contentDescription = null) }&#10;                        )&#10;&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                        // Longitude Input&#10;                        OutlinedTextField(&#10;                            value = lngText,&#10;                            onValueChange = { lngText = it },&#10;                            label = { Text(&quot;Longitude (-180 bis 180)&quot;) },&#10;                            placeholder = { Text(&quot;z.B. 13.4050&quot;) },&#10;                            keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Decimal),&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            leadingIcon = { Icon(Icons.Default.Place, contentDescription = null) }&#10;                        )&#10;&#10;                        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                        // Submit Button f√ºr manuelle Eingabe&#10;                        Button(&#10;                            onClick = {&#10;                                val lat = latText.toDoubleOrNull()&#10;                                val lng = lngText.toDoubleOrNull()&#10;&#10;                                if (lat != null &amp;&amp; lng != null &amp;&amp; &#10;                                    lat &gt;= -90 &amp;&amp; lat &lt;= 90 &amp;&amp; &#10;                                    lng &gt;= -180 &amp;&amp; lng &lt;= 180) {&#10;                                    onLocationSelected(lat, lng)&#10;                                }&#10;                            },&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            enabled = run {&#10;                                val lat = latText.toDoubleOrNull()&#10;                                val lng = lngText.toDoubleOrNull()&#10;                                lat != null &amp;&amp; lng != null &amp;&amp; &#10;                                lat &gt;= -90 &amp;&amp; lat &lt;= 90 &amp;&amp; &#10;                                lng &gt;= -180 &amp;&amp; lng &lt;= 180&#10;                            }&#10;                        ) {&#10;                            Icon(Icons.Default.Send, contentDescription = null)&#10;                            Spacer(modifier = Modifier.width(8.dp))&#10;                            Text(&quot;Koordinaten verwenden&quot;)&#10;                        }&#10;&#10;                        // Validation feedback&#10;                        val lat = latText.toDoubleOrNull()&#10;                        val lng = lngText.toDoubleOrNull()&#10;                        &#10;                        if (latText.isNotEmpty() &amp;&amp; (lat == null || lat !in -90.0..90.0)) {&#10;                            Text(&#10;                                text = &quot;‚ö†Ô∏è Latitude muss zwischen -90 und 90 liegen&quot;,&#10;                                style = MaterialTheme.typography.bodySmall,&#10;                                color = MaterialTheme.colorScheme.error&#10;                            )&#10;                        }&#10;                        &#10;                        if (lngText.isNotEmpty() &amp;&amp; (lng == null || lng !in -180.0..180.0)) {&#10;                            Text(&#10;                                text = &quot;‚ö†Ô∏è Longitude muss zwischen -180 und 180 liegen&quot;,&#10;                                style = MaterialTheme.typography.bodySmall,&#10;                                color = MaterialTheme.colorScheme.error&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            // Action Buttons&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;            ) {&#10;                OutlinedButton(&#10;                    onClick = onClose,&#10;                    modifier = Modifier.weight(1f)&#10;                ) {&#10;                    Text(&quot;Abbrechen&quot;)&#10;                }&#10;&#10;                if (selectedPreset != null) {&#10;                    Button(&#10;                        onClick = {&#10;                            val coords = presetLocations.find { it.first == selectedPreset }?.second&#10;                            coords?.let { onLocationSelected(it.first, it.second) }&#10;                        },&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        Text(&quot;Verwenden&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;private fun Double.format(digits: Int) = &quot;%.${digits}f&quot;.format(this)" />
+            </PendingDiffInfo>
+          </value>
+        </entry>
+        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/ui/components/GuessMapView.kt">
+          <value>
+            <PendingDiffInfo>
+              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/ui/components/GuessMapView.kt" />
+              <option name="originalContent" value="package com.example.geogeusserclone.ui.components&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Close&#10;import androidx.compose.material.icons.filled.LocationOn&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalLifecycleOwner&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;import androidx.lifecycle.Lifecycle&#10;import androidx.lifecycle.LifecycleEventObserver&#10;import com.google.android.gms.maps.CameraUpdateFactory&#10;import com.google.android.gms.maps.GoogleMap&#10;import com.google.android.gms.maps.MapView&#10;import com.google.android.gms.maps.model.LatLng&#10;import com.google.android.gms.maps.model.MarkerOptions&#10;&#10;@Composable&#10;fun GuessMapView(&#10;    onGuessSelected: (Double, Double) -&gt; Unit,&#10;    onMapClose: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val lifecycleOwner = LocalLifecycleOwner.current&#10;    var googleMap by remember { mutableStateOf&lt;GoogleMap?&gt;(null) }&#10;    var selectedLocation by remember { mutableStateOf&lt;LatLng?&gt;(null) }&#10;    var mapView by remember { mutableStateOf&lt;MapView?&gt;(null) }&#10;    var isMapReady by remember { mutableStateOf(false) }&#10;&#10;    // ERWEITERT: Debug-State f√ºr Map-Clicks mit mehr Details&#10;    var clickCount by remember { mutableIntStateOf(0) }&#10;    var lastClickTime by remember { mutableLongStateOf(0L) }&#10;    var touchEventCount by remember { mutableIntStateOf(0) }&#10;    var mapLoadTime by remember { mutableLongStateOf(0L) }&#10;&#10;    Box(modifier = modifier.fillMaxSize()) {&#10;        // Google Map - VERBESSERT f√ºr Emulator-Kompatibilit√§t&#10;        AndroidView(&#10;            factory = { context -&gt;&#10;                println(&quot;GuessMapView: Ô∏è Erstelle MapView f√ºr Emulator...&quot;)&#10;                mapLoadTime = System.currentTimeMillis()&#10;&#10;                MapView(context).apply {&#10;                    onCreate(null)&#10;                    mapView = this&#10;&#10;                    // KRITISCH: Emulator-optimierte Touch-Settings&#10;                    isClickable = true&#10;                    isFocusable = true&#10;                    isFocusableInTouchMode = true&#10;                    isLongClickable = true&#10;&#10;                    // EMULATOR FIX: Explizite Touch-Event-Behandlung&#10;                    setOnTouchListener { view, motionEvent -&gt;&#10;                        touchEventCount++&#10;                        println(&quot;GuessMapView:  RAW TOUCH EVENT #$touchEventCount: ${motionEvent.action}&quot;)&#10;&#10;                        // WICHTIG: Lass die MapView die Touch-Events normal verarbeiten&#10;                        false // Return false = lasse das Event an die MapView weiter&#10;                    }&#10;&#10;                    getMapAsync { map: GoogleMap -&gt;&#10;                        val initTime = System.currentTimeMillis() - mapLoadTime&#10;                        println(&quot;GuessMapView: ‚úÖ GoogleMap initialisiert in ${initTime}ms&quot;)&#10;                        googleMap = map&#10;                        isMapReady = true&#10;&#10;                        // EMULATOR-OPTIMIERTE Map-Konfiguration&#10;                        map.apply {&#10;                            // Setze initiale Kamera-Position&#10;                            moveCamera(CameraUpdateFactory.newLatLngZoom(LatLng(20.0, 0.0), 2f))&#10;&#10;                            // KRITISCH: Emulator-optimierte UI-Einstellungen&#10;                            uiSettings.apply {&#10;                                isZoomControlsEnabled = true // Hilfreich f√ºr Emulator&#10;                                isCompassEnabled = true&#10;                                isMyLocationButtonEnabled = false&#10;                                isMapToolbarEnabled = false&#10;&#10;                                // EMULATOR FIX: Alle Gesten explizit aktivieren&#10;                                isScrollGesturesEnabled = true&#10;                                isZoomGesturesEnabled = true&#10;                                isRotateGesturesEnabled = true&#10;                                isTiltGesturesEnabled = true&#10;                                isIndoorLevelPickerEnabled = false // Reduziere Komplexit√§t&#10;                            }&#10;&#10;                            // VERBESSERT: Robuste Map-Click-Listener&#10;                            setOnMapClickListener { latLng: LatLng -&gt;&#10;                                val currentTime = System.currentTimeMillis()&#10;                                clickCount++&#10;                                lastClickTime = currentTime&#10;&#10;                                println(&quot;GuessMapView:  MAP CLICK DETECTED! Count: $clickCount&quot;)&#10;                                println(&quot;GuessMapView:  Location: ${latLng.latitude}, ${latLng.longitude}&quot;)&#10;                                println(&quot;GuessMapView: ‚è∞ Time: $currentTime&quot;)&#10;                                println(&quot;GuessMapView:  Touch Events: $touchEventCount&quot;)&#10;&#10;                                // Clear previous markers&#10;                                clear()&#10;&#10;                                // Add new marker mit verbesserter Visualisierung&#10;                                addMarker(&#10;                                    MarkerOptions()&#10;                                        .position(latLng)&#10;                                        .title(&quot;Your Guess&quot;)&#10;                                        .snippet(&quot;Lat: ${latLng.latitude.format(4)}, Lng: ${latLng.longitude.format(4)}&quot;)&#10;                                )&#10;&#10;                                // WICHTIG: Smooth camera movement zum Marker&#10;                                animateCamera(&#10;                                    CameraUpdateFactory.newLatLngZoom(latLng, maxOf(cameraPosition.zoom, 8f)),&#10;                                    1000,&#10;                                    null&#10;                                )&#10;&#10;                                // Update state&#10;                                selectedLocation = latLng&#10;                                println(&quot;GuessMapView: ‚úÖ Marker gesetzt und State aktualisiert&quot;)&#10;                            }&#10;&#10;                            // EMULATOR FALLBACK: Long-Click als prim√§rer Fallback&#10;                            setOnMapLongClickListener { latLng: LatLng -&gt;&#10;                                val currentTime = System.currentTimeMillis()&#10;                                clickCount++&#10;&#10;                                println(&quot;GuessMapView:  LONG CLICK DETECTED als Emulator-Fallback!&quot;)&#10;                                println(&quot;GuessMapView:  Long-Click Location: ${latLng.latitude}, ${latLng.longitude}&quot;)&#10;&#10;                                // Verwende den gleichen Code wie bei normalem Click&#10;                                clear()&#10;                                addMarker(&#10;                                    MarkerOptions()&#10;                                        .position(latLng)&#10;                                        .title(&quot;Your Guess (Long Click)&quot;)&#10;                                        .snippet(&quot;Lat: ${latLng.latitude.format(4)}, Lng: ${latLng.longitude.format(4)}&quot;)&#10;                                )&#10;&#10;                                // Smooth camera movement&#10;                                animateCamera(&#10;                                    CameraUpdateFactory.newLatLngZoom(latLng, maxOf(cameraPosition.zoom, 8f)),&#10;                                    1000,&#10;                                    null&#10;                                )&#10;&#10;                                selectedLocation = latLng&#10;                                println(&quot;GuessMapView: ‚úÖ Long-Click Marker gesetzt&quot;)&#10;                            }&#10;&#10;                            // DEBUGGING: Verschiedene Map-Event-Listener&#10;                            setOnMarkerClickListener { marker -&gt;&#10;                                println(&quot;GuessMapView: Ô∏è Marker clicked: ${marker.title}&quot;)&#10;                                false // Return false um Standard-Verhalten zu erlauben&#10;                            }&#10;&#10;                            setOnCameraMoveStartedListener { reason -&gt;&#10;                                when (reason) {&#10;                                    GoogleMap.OnCameraMoveStartedListener.REASON_GESTURE -&gt;&#10;                                        println(&quot;GuessMapView:  Camera move - GESTURE detected&quot;)&#10;                                    GoogleMap.OnCameraMoveStartedListener.REASON_API_ANIMATION -&gt;&#10;                                        println(&quot;GuessMapView:  Camera move - API animation&quot;)&#10;                                    GoogleMap.OnCameraMoveStartedListener.REASON_DEVELOPER_ANIMATION -&gt;&#10;                                        println(&quot;GuessMapView:  Camera move - Developer animation&quot;)&#10;                                }&#10;                            }&#10;&#10;                            setOnCameraIdleListener {&#10;                                println(&quot;GuessMapView:  Camera idle - zoom: ${cameraPosition.zoom}&quot;)&#10;                            }&#10;&#10;                            println(&quot;GuessMapView: ‚úÖ Alle Map-Listener konfiguriert (Emulator-optimiert)&quot;)&#10;                        }&#10;                    }&#10;                }&#10;            },&#10;            modifier = Modifier.fillMaxSize(),&#10;            update = { mapView -&gt;&#10;                // EMULATOR FIX: Stelle sicher, dass Touch-Events korrekt verarbeitet werden&#10;                println(&quot;GuessMapView:  AndroidView Update - ensuring touch handling&quot;)&#10;            }&#10;        )&#10;&#10;        // Handle lifecycle events&#10;        DisposableEffect(lifecycleOwner) {&#10;            val observer = LifecycleEventObserver { _, event -&gt;&#10;                when (event) {&#10;                    Lifecycle.Event.ON_CREATE -&gt; {&#10;                        println(&quot;GuessMapView:  Lifecycle ON_CREATE&quot;)&#10;                        mapView?.onCreate(null)&#10;                    }&#10;                    Lifecycle.Event.ON_START -&gt; {&#10;                        println(&quot;GuessMapView:  Lifecycle ON_START&quot;)&#10;                        mapView?.onStart()&#10;                    }&#10;                    Lifecycle.Event.ON_RESUME -&gt; {&#10;                        println(&quot;GuessMapView:  Lifecycle ON_RESUME&quot;)&#10;                        mapView?.onResume()&#10;                    }&#10;                    Lifecycle.Event.ON_PAUSE -&gt; {&#10;                        println(&quot;GuessMapView:  Lifecycle ON_PAUSE&quot;)&#10;                        mapView?.onPause()&#10;                    }&#10;                    Lifecycle.Event.ON_STOP -&gt; {&#10;                        println(&quot;GuessMapView:  Lifecycle ON_STOP&quot;)&#10;                        mapView?.onStop()&#10;                    }&#10;                    Lifecycle.Event.ON_DESTROY -&gt; {&#10;                        println(&quot;GuessMapView:  Lifecycle ON_DESTROY&quot;)&#10;                        mapView?.onDestroy()&#10;                    }&#10;                    else -&gt; {}&#10;                }&#10;            }&#10;&#10;            lifecycleOwner.lifecycle.addObserver(observer)&#10;&#10;            onDispose {&#10;                lifecycleOwner.lifecycle.removeObserver(observer)&#10;                mapView?.onDestroy()&#10;            }&#10;        }&#10;&#10;        // Loading Indicator&#10;        if (!isMapReady) {&#10;            Box(&#10;                modifier = Modifier.fillMaxSize(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Card(&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.9f)&#10;                    )&#10;                ) {&#10;                    Column(&#10;                        modifier = Modifier.padding(24.dp),&#10;                        horizontalAlignment = Alignment.CenterHorizontally&#10;                    ) {&#10;                        CircularProgressIndicator()&#10;                        Spacer(modifier = Modifier.height(16.dp))&#10;                        Text(&quot;Loading Map...&quot;)&#10;                        if (clickCount &gt; 0) {&#10;                            Text(&#10;                                &quot;Clicks detected: $clickCount&quot;,&#10;                                style = MaterialTheme.typography.bodySmall,&#10;                                color = MaterialTheme.colorScheme.primary&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Top bar with close button&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.9f)&#10;            )&#10;        ) {&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(12.dp),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Column {&#10;                    Text(&#10;                        text = &quot;Make Your Guess&quot;,&#10;                        style = MaterialTheme.typography.titleMedium,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                    Text(&#10;                        text = &quot;Tap anywhere on the map&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                    // DEBUG INFO&#10;                    if (clickCount &gt; 0) {&#10;                        Text(&#10;                            text = &quot;Debug: $clickCount clicks detected&quot;,&#10;                            style = MaterialTheme.typography.bodySmall,&#10;                            color = MaterialTheme.colorScheme.primary&#10;                        )&#10;                    }&#10;                }&#10;&#10;                IconButton(onClick = onMapClose) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Close,&#10;                        contentDescription = &quot;Close Map&quot;&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Bottom action area - VERBESSERT&#10;        Card(&#10;            modifier = Modifier&#10;                .align(Alignment.BottomCenter)&#10;                .fillMaxWidth()&#10;                .padding(16.dp),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.95f)&#10;            )&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp)&#10;            ) {&#10;                // Status Text&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Icon(&#10;                        Icons.Default.LocationOn,&#10;                        contentDescription = null,&#10;                        tint = if (selectedLocation != null)&#10;                            MaterialTheme.colorScheme.primary&#10;                        else&#10;                            MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        modifier = Modifier.size(20.dp)&#10;                    )&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;&#10;                    if (selectedLocation != null) {&#10;                        Column {&#10;                            Text(&#10;                                text = &quot;Location Selected ‚úÖ&quot;,&#10;                                style = MaterialTheme.typography.titleSmall,&#10;                                fontWeight = FontWeight.Bold,&#10;                                color = MaterialTheme.colorScheme.primary&#10;                            )&#10;                            Text(&#10;                                text = &quot;${selectedLocation!!.latitude.format(4)}, ${selectedLocation!!.longitude.format(4)}&quot;,&#10;                                style = MaterialTheme.typography.bodySmall,&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                        }&#10;                    } else {&#10;                        Column {&#10;                            Text(&#10;                                text = &quot;No location selected - tap on the map&quot;,&#10;                                style = MaterialTheme.typography.bodyMedium,&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                            if (isMapReady &amp;&amp; clickCount == 0) {&#10;                                Text(&#10;                                    text = &quot;Map ready - waiting for tap...&quot;,&#10;                                    style = MaterialTheme.typography.bodySmall,&#10;                                    color = MaterialTheme.colorScheme.secondary&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                // Action Buttons&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    // Cancel Button&#10;                    OutlinedButton(&#10;                        onClick = onMapClose,&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        Text(&quot;Cancel&quot;)&#10;                    }&#10;&#10;                    // Clear Button (only when location selected)&#10;                    if (selectedLocation != null) {&#10;                        OutlinedButton(&#10;                            onClick = {&#10;                                println(&quot;GuessMapView:  Clearing selection&quot;)&#10;                                googleMap?.clear()&#10;                                selectedLocation = null&#10;                            },&#10;                            modifier = Modifier.weight(1f)&#10;                        ) {&#10;                            Text(&quot;Clear&quot;)&#10;                        }&#10;                    }&#10;&#10;                    // VERBESSERT: Submit Button mit besserem Feedback&#10;                    Button(&#10;                        onClick = {&#10;                            selectedLocation?.let { location -&gt;&#10;                                println(&quot;GuessMapView: ‚úÖ Submitting guess: ${location.latitude}, ${location.longitude}&quot;)&#10;                                onGuessSelected(location.latitude, location.longitude)&#10;                            }&#10;                        },&#10;                        modifier = Modifier.weight(2f),&#10;                        enabled = selectedLocation != null&#10;                    ) {&#10;                        Icon(&#10;                            Icons.Default.LocationOn,&#10;                            contentDescription = null,&#10;                            modifier = Modifier.size(18.dp)&#10;                        )&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                        Text(&#10;                            if (selectedLocation != null) &quot;Submit Guess&quot; else &quot;Select Location First&quot;,&#10;                            fontWeight = FontWeight.Bold&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Helpful hint + Debug info&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;                if (selectedLocation == null) {&#10;                    Text(&#10;                        text = &quot; Tip: Zoom in for better accuracy. ${if (isMapReady) &quot;Map is ready!&quot; else &quot;Loading...&quot;}&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        modifier = Modifier.fillMaxWidth()&#10;                    )&#10;                }&#10;&#10;                // DEBUG: Zeige Map-Status&#10;                if (isMapReady) {&#10;                    Text(&#10;                        text = &quot;Ô∏è Map Status: Ready | Clicks: $clickCount | Selected: ${selectedLocation != null}&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.primary,&#10;                        modifier = Modifier.fillMaxWidth()&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;private fun Double.format(digits: Int) = &quot;%.${digits}f&quot;.format(this)&#10;" />
+              <option name="updatedContent" value="package com.example.geogeusserclone.ui.components&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Close&#10;import androidx.compose.material.icons.filled.LocationOn&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalLifecycleOwner&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.viewinterop.AndroidView&#10;import androidx.lifecycle.Lifecycle&#10;import androidx.lifecycle.LifecycleEventObserver&#10;import com.google.android.gms.maps.CameraUpdateFactory&#10;import com.google.android.gms.maps.GoogleMap&#10;import com.google.android.gms.maps.MapView&#10;import com.google.android.gms.maps.model.LatLng&#10;import com.google.android.gms.maps.model.MarkerOptions&#10;&#10;@Composable&#10;fun GuessMapView(&#10;    onGuessSelected: (Double, Double) -&gt; Unit,&#10;    onMapClose: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val lifecycleOwner = LocalLifecycleOwner.current&#10;    var googleMap by remember { mutableStateOf&lt;GoogleMap?&gt;(null) }&#10;    var selectedLocation by remember { mutableStateOf&lt;LatLng?&gt;(null) }&#10;    var mapView by remember { mutableStateOf&lt;MapView?&gt;(null) }&#10;    var isMapReady by remember { mutableStateOf(false) }&#10;&#10;    // ERWEITERT: Debug-State f√ºr Map-Clicks mit mehr Details&#10;    var clickCount by remember { mutableIntStateOf(0) }&#10;    var lastClickTime by remember { mutableLongStateOf(0L) }&#10;    var touchEventCount by remember { mutableIntStateOf(0) }&#10;    var mapLoadTime by remember { mutableLongStateOf(0L) }&#10;&#10;    Box(modifier = modifier.fillMaxSize()) {&#10;        // Google Map - VERBESSERT f√ºr Emulator-Kompatibilit√§t&#10;        AndroidView(&#10;            factory = { context -&gt;&#10;                println(&quot;GuessMapView: Ô∏è Erstelle MapView f√ºr Emulator...&quot;)&#10;                mapLoadTime = System.currentTimeMillis()&#10;&#10;                MapView(context).apply {&#10;                    onCreate(null)&#10;                    mapView = this&#10;&#10;                    // KRITISCH: Emulator-optimierte Touch-Settings&#10;                    isClickable = true&#10;                    isFocusable = true&#10;                    isFocusableInTouchMode = true&#10;                    isLongClickable = true&#10;&#10;                    // EMULATOR FIX: Explizite Touch-Event-Behandlung&#10;                    setOnTouchListener { view, motionEvent -&gt;&#10;                        touchEventCount++&#10;                        println(&quot;GuessMapView:  RAW TOUCH EVENT #$touchEventCount: ${motionEvent.action}&quot;)&#10;&#10;                        // WICHTIG: Lass die MapView die Touch-Events normal verarbeiten&#10;                        false // Return false = lasse das Event an die MapView weiter&#10;                    }&#10;&#10;                    getMapAsync { map: GoogleMap -&gt;&#10;                        val initTime = System.currentTimeMillis() - mapLoadTime&#10;                        println(&quot;GuessMapView: ‚úÖ GoogleMap initialisiert in ${initTime}ms&quot;)&#10;                        googleMap = map&#10;                        isMapReady = true&#10;&#10;                        // EMULATOR-OPTIMIERTE Map-Konfiguration&#10;                        map.apply {&#10;                            // Setze initiale Kamera-Position&#10;                            moveCamera(CameraUpdateFactory.newLatLngZoom(LatLng(20.0, 0.0), 2f))&#10;&#10;                            // KRITISCH: Emulator-optimierte UI-Einstellungen&#10;                            uiSettings.apply {&#10;                                isZoomControlsEnabled = true // Hilfreich f√ºr Emulator&#10;                                isCompassEnabled = true&#10;                                isMyLocationButtonEnabled = false&#10;                                isMapToolbarEnabled = false&#10;&#10;                                // EMULATOR FIX: Alle Gesten explizit aktivieren&#10;                                isScrollGesturesEnabled = true&#10;                                isZoomGesturesEnabled = true&#10;                                isRotateGesturesEnabled = true&#10;                                isTiltGesturesEnabled = true&#10;                                isIndoorLevelPickerEnabled = false // Reduziere Komplexit√§t&#10;                            }&#10;&#10;                            // VERBESSERT: Robuste Map-Click-Listener&#10;                            setOnMapClickListener { latLng: LatLng -&gt;&#10;                                val currentTime = System.currentTimeMillis()&#10;                                clickCount++&#10;                                lastClickTime = currentTime&#10;&#10;                                println(&quot;GuessMapView:  MAP CLICK DETECTED! Count: $clickCount&quot;)&#10;                                println(&quot;GuessMapView:  Location: ${latLng.latitude}, ${latLng.longitude}&quot;)&#10;                                println(&quot;GuessMapView: ‚è∞ Time: $currentTime&quot;)&#10;                                println(&quot;GuessMapView:  Touch Events: $touchEventCount&quot;)&#10;&#10;                                // Clear previous markers&#10;                                clear()&#10;&#10;                                // Add new marker mit verbesserter Visualisierung&#10;                                addMarker(&#10;                                    MarkerOptions()&#10;                                        .position(latLng)&#10;                                        .title(&quot;Your Guess&quot;)&#10;                                        .snippet(&quot;Lat: ${latLng.latitude.format(4)}, Lng: ${latLng.longitude.format(4)}&quot;)&#10;                                )&#10;&#10;                                // WICHTIG: Smooth camera movement zum Marker&#10;                                animateCamera(&#10;                                    CameraUpdateFactory.newLatLngZoom(latLng, maxOf(cameraPosition.zoom, 8f)),&#10;                                    1000,&#10;                                    null&#10;                                )&#10;&#10;                                // Update state&#10;                                selectedLocation = latLng&#10;                                println(&quot;GuessMapView: ‚úÖ Marker gesetzt und State aktualisiert&quot;)&#10;                            }&#10;&#10;                            // EMULATOR FALLBACK: Long-Click als prim√§rer Fallback&#10;                            setOnMapLongClickListener { latLng: LatLng -&gt;&#10;                                val currentTime = System.currentTimeMillis()&#10;                                clickCount++&#10;&#10;                                println(&quot;GuessMapView:  LONG CLICK DETECTED als Emulator-Fallback!&quot;)&#10;                                println(&quot;GuessMapView:  Long-Click Location: ${latLng.latitude}, ${latLng.longitude}&quot;)&#10;&#10;                                // Verwende den gleichen Code wie bei normalem Click&#10;                                clear()&#10;                                addMarker(&#10;                                    MarkerOptions()&#10;                                        .position(latLng)&#10;                                        .title(&quot;Your Guess (Long Click)&quot;)&#10;                                        .snippet(&quot;Lat: ${latLng.latitude.format(4)}, Lng: ${latLng.longitude.format(4)}&quot;)&#10;                                )&#10;&#10;                                // Smooth camera movement&#10;                                animateCamera(&#10;                                    CameraUpdateFactory.newLatLngZoom(latLng, maxOf(cameraPosition.zoom, 8f)),&#10;                                    1000,&#10;                                    null&#10;                                )&#10;&#10;                                selectedLocation = latLng&#10;                                println(&quot;GuessMapView: ‚úÖ Long-Click Marker gesetzt&quot;)&#10;                            }&#10;&#10;                            // DEBUGGING: Verschiedene Map-Event-Listener&#10;                            setOnMarkerClickListener { marker -&gt;&#10;                                println(&quot;GuessMapView: Ô∏è Marker clicked: ${marker.title}&quot;)&#10;                                false // Return false um Standard-Verhalten zu erlauben&#10;                            }&#10;&#10;                            setOnCameraMoveStartedListener { reason -&gt;&#10;                                when (reason) {&#10;                                    GoogleMap.OnCameraMoveStartedListener.REASON_GESTURE -&gt;&#10;                                        println(&quot;GuessMapView:  Camera move - GESTURE detected&quot;)&#10;                                    GoogleMap.OnCameraMoveStartedListener.REASON_API_ANIMATION -&gt;&#10;                                        println(&quot;GuessMapView:  Camera move - API animation&quot;)&#10;                                    GoogleMap.OnCameraMoveStartedListener.REASON_DEVELOPER_ANIMATION -&gt;&#10;                                        println(&quot;GuessMapView:  Camera move - Developer animation&quot;)&#10;                                }&#10;                            }&#10;&#10;                            setOnCameraIdleListener {&#10;                                println(&quot;GuessMapView:  Camera idle - zoom: ${cameraPosition.zoom}&quot;)&#10;                            }&#10;&#10;                            println(&quot;GuessMapView: ‚úÖ Alle Map-Listener konfiguriert (Emulator-optimiert)&quot;)&#10;                        }&#10;                    }&#10;                }&#10;            },&#10;            modifier = Modifier.fillMaxSize(),&#10;            update = { mapView -&gt;&#10;                // EMULATOR FIX: Stelle sicher, dass Touch-Events korrekt verarbeitet werden&#10;                println(&quot;GuessMapView:  AndroidView Update - ensuring touch handling&quot;)&#10;            }&#10;        )&#10;&#10;        // Handle lifecycle events&#10;        DisposableEffect(lifecycleOwner) {&#10;            val observer = LifecycleEventObserver { _, event -&gt;&#10;                when (event) {&#10;                    Lifecycle.Event.ON_CREATE -&gt; {&#10;                        println(&quot;GuessMapView:  Lifecycle ON_CREATE&quot;)&#10;                        mapView?.onCreate(null)&#10;                    }&#10;                    Lifecycle.Event.ON_START -&gt; {&#10;                        println(&quot;GuessMapView:  Lifecycle ON_START&quot;)&#10;                        mapView?.onStart()&#10;                    }&#10;                    Lifecycle.Event.ON_RESUME -&gt; {&#10;                        println(&quot;GuessMapView:  Lifecycle ON_RESUME&quot;)&#10;                        mapView?.onResume()&#10;                    }&#10;                    Lifecycle.Event.ON_PAUSE -&gt; {&#10;                        println(&quot;GuessMapView:  Lifecycle ON_PAUSE&quot;)&#10;                        mapView?.onPause()&#10;                    }&#10;                    Lifecycle.Event.ON_STOP -&gt; {&#10;                        println(&quot;GuessMapView:  Lifecycle ON_STOP&quot;)&#10;                        mapView?.onStop()&#10;                    }&#10;                    Lifecycle.Event.ON_DESTROY -&gt; {&#10;                        println(&quot;GuessMapView:  Lifecycle ON_DESTROY&quot;)&#10;                        mapView?.onDestroy()&#10;                    }&#10;                    else -&gt; {}&#10;                }&#10;            }&#10;&#10;            lifecycleOwner.lifecycle.addObserver(observer)&#10;&#10;            onDispose {&#10;                lifecycleOwner.lifecycle.removeObserver(observer)&#10;                mapView?.onDestroy()&#10;            }&#10;        }&#10;&#10;        // Loading Indicator&#10;        if (!isMapReady) {&#10;            Box(&#10;                modifier = Modifier.fillMaxSize(),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Card(&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.9f)&#10;                    )&#10;                ) {&#10;                    Column(&#10;                        modifier = Modifier.padding(24.dp),&#10;                        horizontalAlignment = Alignment.CenterHorizontally&#10;                    ) {&#10;                        CircularProgressIndicator()&#10;                        Spacer(modifier = Modifier.height(16.dp))&#10;                        Text(&quot;Loading Map...&quot;)&#10;                        if (clickCount &gt; 0) {&#10;                            Text(&#10;                                &quot;Clicks detected: $clickCount&quot;,&#10;                                style = MaterialTheme.typography.bodySmall,&#10;                                color = MaterialTheme.colorScheme.primary&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Top bar with close button&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.9f)&#10;            )&#10;        ) {&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(12.dp),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Column {&#10;                    Text(&#10;                        text = &quot;Make Your Guess&quot;,&#10;                        style = MaterialTheme.typography.titleMedium,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;                    Text(&#10;                        text = &quot;Tap anywhere on the map&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;                    // DEBUG INFO&#10;                    if (clickCount &gt; 0) {&#10;                        Text(&#10;                            text = &quot;Debug: $clickCount clicks detected&quot;,&#10;                            style = MaterialTheme.typography.bodySmall,&#10;                            color = MaterialTheme.colorScheme.primary&#10;                        )&#10;                    }&#10;                }&#10;&#10;                IconButton(onClick = onMapClose) {&#10;                    Icon(&#10;                        imageVector = Icons.Default.Close,&#10;                        contentDescription = &quot;Close Map&quot;&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Bottom action area - VERBESSERT&#10;        Card(&#10;            modifier = Modifier&#10;                .align(Alignment.BottomCenter)&#10;                .fillMaxWidth()&#10;                .padding(16.dp),&#10;            colors = CardDefaults.cardColors(&#10;                containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.95f)&#10;            )&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp)&#10;            ) {&#10;                // Status Text&#10;                Row(&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Icon(&#10;                        Icons.Default.LocationOn,&#10;                        contentDescription = null,&#10;                        tint = if (selectedLocation != null)&#10;                            MaterialTheme.colorScheme.primary&#10;                        else&#10;                            MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        modifier = Modifier.size(20.dp)&#10;                    )&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;&#10;                    if (selectedLocation != null) {&#10;                        Column {&#10;                            Text(&#10;                                text = &quot;Location Selected ‚úÖ&quot;,&#10;                                style = MaterialTheme.typography.titleSmall,&#10;                                fontWeight = FontWeight.Bold,&#10;                                color = MaterialTheme.colorScheme.primary&#10;                            )&#10;                            Text(&#10;                                text = &quot;${selectedLocation!!.latitude.format(4)}, ${selectedLocation!!.longitude.format(4)}&quot;,&#10;                                style = MaterialTheme.typography.bodySmall,&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                        }&#10;                    } else {&#10;                        Column {&#10;                            Text(&#10;                                text = &quot;No location selected - tap on the map&quot;,&#10;                                style = MaterialTheme.typography.bodyMedium,&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                            if (isMapReady &amp;&amp; clickCount == 0) {&#10;                                Text(&#10;                                    text = &quot;Map ready - waiting for tap...&quot;,&#10;                                    style = MaterialTheme.typography.bodySmall,&#10;                                    color = MaterialTheme.colorScheme.secondary&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                // Action Buttons&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp)&#10;                ) {&#10;                    // Cancel Button&#10;                    OutlinedButton(&#10;                        onClick = onMapClose,&#10;                        modifier = Modifier.weight(1f)&#10;                    ) {&#10;                        Text(&quot;Cancel&quot;)&#10;                    }&#10;&#10;                    // Clear Button (only when location selected)&#10;                    if (selectedLocation != null) {&#10;                        OutlinedButton(&#10;                            onClick = {&#10;                                println(&quot;GuessMapView:  Clearing selection&quot;)&#10;                                googleMap?.clear()&#10;                                selectedLocation = null&#10;                            },&#10;                            modifier = Modifier.weight(1f)&#10;                        ) {&#10;                            Text(&quot;Clear&quot;)&#10;                        }&#10;                    }&#10;&#10;                    // VERBESSERT: Submit Button mit besserem Feedback&#10;                    Button(&#10;                        onClick = {&#10;                            selectedLocation?.let { location -&gt;&#10;                                println(&quot;GuessMapView: ‚úÖ Submitting guess: ${location.latitude}, ${location.longitude}&quot;)&#10;                                onGuessSelected(location.latitude, location.longitude)&#10;                            }&#10;                        },&#10;                        modifier = Modifier.weight(2f),&#10;                        enabled = selectedLocation != null&#10;                    ) {&#10;                        Icon(&#10;                            Icons.Default.LocationOn,&#10;                            contentDescription = null,&#10;                            modifier = Modifier.size(18.dp)&#10;                        )&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                        Text(&#10;                            if (selectedLocation != null) &quot;Submit Guess&quot; else &quot;Select Location First&quot;,&#10;                            fontWeight = FontWeight.Bold&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // Helpful hint + Debug info - ERWEITERT f√ºr Emulator&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;                if (selectedLocation == null) {&#10;                    Column {&#10;                        Text(&#10;                            text = &quot; Tip: Zoom in for better accuracy. ${if (isMapReady) &quot;Map is ready!&quot; else &quot;Loading...&quot;}&quot;,&#10;                            style = MaterialTheme.typography.bodySmall,&#10;                            color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                            modifier = Modifier.fillMaxWidth()&#10;                        )&#10;                        &#10;                        // EMULATOR-SPEZIFISCHE HILFE&#10;                        if (isMapReady &amp;&amp; touchEventCount &gt; 0 &amp;&amp; clickCount == 0) {&#10;                            Text(&#10;                                text = &quot; Emulator-Tipp: Versuche einen langen Klick (Long-Press) auf die Karte&quot;,&#10;                                style = MaterialTheme.typography.bodySmall,&#10;                                color = MaterialTheme.colorScheme.error,&#10;                                modifier = Modifier.fillMaxWidth()&#10;                            )&#10;                        }&#10;                        &#10;                        if (isMapReady &amp;&amp; touchEventCount == 0) {&#10;                            Text(&#10;                                text = &quot;‚ö†Ô∏è Keine Touch-Events erkannt - pr√ºfe Emulator-Einstellungen&quot;,&#10;                                style = MaterialTheme.typography.bodySmall,&#10;                                color = MaterialTheme.colorScheme.error,&#10;                                modifier = Modifier.fillMaxWidth()&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // DEBUG: Erweiterte Map-Diagnose&#10;                if (isMapReady) {&#10;                    Column {&#10;                        Text(&#10;                            text = &quot;Ô∏è Map Status: Ready | Clicks: $clickCount | TouchEvents: $touchEventCount&quot;,&#10;                            style = MaterialTheme.typography.bodySmall,&#10;                            color = MaterialTheme.colorScheme.primary,&#10;                            modifier = Modifier.fillMaxWidth()&#10;                        )&#10;                        &#10;                        Text(&#10;                            text = &quot; Selected: ${selectedLocation != null} | LastClick: ${if (lastClickTime &gt; 0) &quot;${System.currentTimeMillis() - lastClickTime}ms ago&quot; else &quot;none&quot;}&quot;,&#10;                            style = MaterialTheme.typography.bodySmall,&#10;                            color = MaterialTheme.colorScheme.secondary,&#10;                            modifier = Modifier.fillMaxWidth()&#10;                        )&#10;                        &#10;                        // EMULATOR-DIAGNOSE&#10;                        if (touchEventCount &gt; 10 &amp;&amp; clickCount == 0) {&#10;                            Text(&#10;                                text = &quot; Touch-Events erkannt aber keine Map-Clicks - m√∂glicherweise Emulator-Problem&quot;,&#10;                                style = MaterialTheme.typography.bodySmall,&#10;                                color = MaterialTheme.colorScheme.error,&#10;                                modifier = Modifier.fillMaxWidth()&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;private fun Double.format(digits: Int) = &quot;%.${digits}f&quot;.format(this)" />
+            </PendingDiffInfo>
+          </value>
+        </entry>
         <entry key="$PROJECT_DIR$/app/src/main/java/com/example/geogeusserclone/ui/components/MapViewScreen.kt">
           <value>
             <PendingDiffInfo>
